-- Title: SPI Slave Hardware Sample
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Compiler: 2.4o
-- Revision: $Revision$
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: SPI Hardware Slave library for exchanging data through SPI bus.
--              To use this sample have your master SPI exchange 10 bytes
--              every 1 second with SPI_MODE_11,SPI_RATE_FOSC_64.
--
-- Sources:
-- http://www.justanotherlanguage.org/content/jallib/tutorials/tutorial_spi_introduction
-- Jallib spi_master_hw library - Written by William Welch
-- http://ww1.microchip.com/downloads/en/devicedoc/spi.pdf
--

-- include chip
include 18f4620                   -- target picmicro
pragma target osc INTOSC_NOCLKOUT              -- hs crystal or resonator
;pragma target osc hs              -- hs crystal or resonator
;pragma target clock 20_000_000    -- oscillator frequency
pragma target clock 32_000_000    -- oscillator frequency
--
pragma target wdt  disabled
pragma target lvp  disabled
pragma target MCLR external        -- reset externally
--;
;OSCCON_IRCF = 0b110  -- set int osc to 4mhz
OSCCON_IRCF = 0b111   -- set internal osc to 8mhz
OSCTUNE_PLLEN = true  -- multiply internal osc by 4
;--
enable_digital_io()                -- make all pins digital I/O
--
_usec_delay(100_000) -- wait for power to settle

-- Specify the pin to which the LED (with serial resistor!) is connected:
alias   led      is pin_A0
pin_A0_direction =  output

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

include print
include format

-- Setup SPI Slave Hardware
--
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = input    -- spi clock
--
alias spi_slave_hw_chip_select is pin_ss -- slave select / chip select pin.
alias spi_slave_hw_chip_select_direction is pin_ss_direction
spi_slave_hw_chip_select_direction = input
const SPI_SLAVE_HW_SS_ACTIVE_STATE = LOW -- chip select pin is active low
--
-- chip select must be pin_ss & active low if TRUE. See more notes in library.
const SPI_SLAVE_HW_SYNCHRONOUS = TRUE
--
const SPI_SLAVE_HW_ENABLE_INTERRUPT = TRUE -- enable spi interrupt
--
if SPI_SLAVE_HW_ENABLE_INTERRUPT == TRUE then
   const SPI_SLAVE_HW_TX_QUEUE_SIZE = 25 -- tx queue
   const SPI_SLAVE_HW_RX_QUEUE_SIZE = 25 -- rx queue
end if
--
-- Enable/Disable Packets. Currently only works with interrupts enabled.
-- (pin_ss = inactive) marks end of packet.
const SPI_SLAVE_ENABLE_ISR_PACKETS = TRUE
--
if SPI_SLAVE_ENABLE_ISR_PACKETS == TRUE then
   const SPI_SLAVE_HW_RX_PACKET_SIZES = 10 -- packet size queue
end if
--
include spi_slave_hw
spi_slave_init(SPI_MODE_11)
--
spi_slave_hw = 255 -- the first byte to go out

-- MAIN PROGRAM

var byte x,y
var byte step
for 10 using step loop
   spi_slave_hw = step
end loop

led = ON

forever loop
   
   -- EXAMPLE #1 - if ISR packets are enabled
   if (SPI_SLAVE_HW_ENABLE_INTERRUPT == TRUE) & (SPI_SLAVE_ENABLE_ISR_PACKETS == TRUE) then
      if spi_slave_hw_packet_available then
      
         -- get the packet size (only read this var once)
         var byte size = spi_slave_hw_rx_packet_size

         print_crlf(serial_data)
         const byte message[] = "Bytes in packet: "
         print_string(serial_data, message)
         print_byte_dec(serial_data,size)
         print_crlf(serial_data)
         
         for size loop

            ;spi_slave_hw = 50 -- set a SPI return value
            ;x = spi_slave_hw   -- read one byte
            x = spi_slave_hw_exchange(50)
            
            format_byte_dec(serial_data,x,3,0)
            serial_data = " "
         
         end loop

         print_crlf(serial_data)
         print_crlf(serial_data)
      end if

      -- do other things here
      _usec_delay(1000)
   end if
   
   -- EXAMPLE #2 - if ISR packets are disabled
   if (SPI_SLAVE_HW_ENABLE_INTERRUPT == TRUE) & (SPI_SLAVE_ENABLE_ISR_PACKETS == FALSE) then
      var byte y = 0
      while spi_slave_hw_rx_queue_nr_used > 0 loop
      
         ;spi_slave_hw = 50 -- set a SPI return value
         ;x = spi_slave_hw   -- read one byte
         x = spi_slave_hw_exchange(50)
         
         print_byte_dec(serial_data,x)
         serial_data = " "
         y = 1
      end loop
      
      if y == 1 then
         print_crlf(serial_data)
      end if
      -- do other things here
      _usec_delay(1000)
   end if

   -- EXAMPLE #3 - no interrupts
   -- this example assumes we are waiting for 10 bytes at a time
   var byte input_array[10] -- assuming packets are always 13 bytes
   if (SPI_SLAVE_HW_ENABLE_INTERRUPT == FALSE) then

      if spi_slave_hw_chip_select == SPI_SLAVE_HW_SS_ACTIVE_STATE then

         x = 0
         for count(input_array) loop
            input_array[x] = spi_slave_hw_exchange(50)
            x = x + 1
         end loop

         -- do other things here, you may loose data if more comes in.
         for count(input_array) using x loop
            print_byte_dec(serial_data,input_array[x])
            serial_data = " "
         end loop
      end if
   end if

end loop
