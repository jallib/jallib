<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
		<title>usb_drv_cdc_class - jallib API doc</title>
    </head>
    <body>
		
		        <div id="page">
        
            <div id="pagecontent">

			    
	<a href="#toc" name="usb_drv_cdc_class">
    <h1>usb_drv_cdc_class</h1>
	</a>

    <div>
		<font size="+1"><i>USB Communication Device Class driver</i></font>
	</div>

	<br/>

    <div class="narrow">
        
	<table>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Author</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			Albert Faber, Copyright (c) 2008..2009, all rights reserved.
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Adapted-by</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			-
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Compiler</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			>=2.4j
		</td>
	</tr>
	</table>

	<br/>
	
	<b>Description</b>
	<p>
		<pre>USB Communication Device Class (CDC) code
This USB library files contains the low level implementation to perform serial
communication over a USB interface. The usage of this library requires detailed
knowledge of the USB interface and requires that several configuration parameters
are defined correctly. In order to make USB serial communication more accessible 
for the end user, I would highly recommend to use the usb_serial library



</pre>

	</p>
	<br/>

	<b>Sources</b>
	<p>
		<pre>http://www.usb.org for USB specifications
</pre>

	</p>
	<br/>

	
	<b>Dependencies</b>
	<p>
		<i>No dependency found</i>
	</p>
	<br/>


			<br/>
				<h2><a name="summary">Summary</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#7556da82134cd54d3b9f264d4fdc8262">var volatile byte cdc_rx_free = USB_CDC_RX_BUFFER_SIZE
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#71609f676728e69f55db2787279fac82">var byte cdc_line_status = 0x00
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#43baaf214d667c37292047ce40705bec">const byte USB_REQ_SEND_BREAK = 0x23
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#0447b00cda1b2db1de36d03589de54e2">const byte USB_REQ_SET_LINE_CODING = 0x20
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#3545d5c6bfcf6cc873a2a0ec52524ca1">var volatile byte cdc_tx_wr=0
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#2b13db03a8ce80e5f64e518fed4c1794">var volatile byte cdc_rx_rd = 0
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#0a8b26a8614039d6513cdce19598d421">var volatile byte cdc_line_coding_parity at cdc_line_coding[5]       -- 0=None, 1=Odd, 2=Even, 3=Mark, 4=Space
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6acf65c04beedfb1f66868a8c54e3602">var volatile byte cdc_line_coding[7]
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#94ad025aa4c621b5bd9c33afa693cbde">const byte USB_REQ_SET_CONTROL_LINE_STATE = 0x22
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c40ddd1e6b1bfc17d1f2b5daa460a4a8">const byte USB_REQ_GET_ENCAPSULATED_RESPONSE = 0x01
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#845ceb8817c3405cd3c18c79959d0fb6">var volatile byte cdc_line_coding_stop_bits at cdc_line_coding[4]    -- 0=1 stop bit, 1=1.5 stop bits, 2=2 stop bits
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#7f99ff1a9c486751e961f38de9127aab">var volatile dword cdc_line_coding_dte_rate at cdc_line_coding[0]
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6574d4cb897f0fd0164790a711658bf9">var byte cdc_rx_buffer[USB_CDC_RX_BUFFER_SIZE]
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#ba0bfa0f3ccf687c4c17381333aa8bfe">const byte USB_REQ_SET_COMM_FEATURE = 0x02
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6aba3bd37543b244d784104febfba7a4">var bit last_packet_is_full = false
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#5a6cd246232de57216d562a0f604fb34">const byte USB_REQ_SEND_ENCAPSULATED_COMMAND	= 0x00
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#4ec121da305870f23890910c898958d3">var volatile byte cdc_tx_rd=0
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c8aa8d576828e4548870e5c9088df34f">const byte USB_REQ_CLEAR_COMM_FEATURE = 0x04
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#082b209717e04a026a8711afdd7e2370">var volatile byte cdc_rx_wr = 0
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#7516891a02608f7b905237ada1683074">var volatile byte cdc_line_coding_data_bits at cdc_line_coding[6]    -- 5,6,7,8 or 16 bits
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6a258c1082d55259975cb1b0d948fe53">const byte USB_REQ_GET_LINE_CODING = 0x21
</a></code></b>
		</li>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#821b320f21b4a76496eef997e2804acd">usb_handle_class_request_callback()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#ea6b1f15ff85043486e49c8e9bf0b063">usb_handle_class_ctrl_read_callback()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#26c043dd07cc5d50f99833052c5fb800">usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count)</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#b668997307b1ad66a40213380c6ed5cf">usb_cdc_putc(byte in c)</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#943b9721ceeae048bbc372b815ea6647">usb_cdc_handle_tx()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#cb5231cab1ade54cebf58ea5e5653fc5">usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count)</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#7fa585d1e13980a194c675bb6f6b2338">usb_handle_class_ctrl_write_callback()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#07e2ad4d28529381837dcb7694bbc2c4">usb_sof_callback()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#43d2c8422eb7a33e823a9f18407a5afb">usb_cdc_setup()</a></code></b>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#91826177975503d587283eaea06244a9">usb_cdc_rx_avail() return bit</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#5b81d62ed81745fa0be3273d607b2239">does_sie_owns_tx_buffer() return bit</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#f611f639cd92e026cf5d1d76d6d363d4">usb_cdc_line_status() return byte</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#89de70291f2716551b6e61cca508f295">usb_cdc_getc() return byte</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#708b9418c5edeae63cfe0a8e76a4d476">usb_cdc_tx_empty() return byte</a></code></b>
		</li>
	</ul>



			<br/>
				<h2><a name="api">API details</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="7556da82134cd54d3b9f264d4fdc8262" href="#summary">var volatile byte cdc_rx_free = USB_CDC_RX_BUFFER_SIZE
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="71609f676728e69f55db2787279fac82" href="#summary">var byte cdc_line_status = 0x00
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="43baaf214d667c37292047ce40705bec" href="#summary">const byte USB_REQ_SEND_BREAK = 0x23
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="0447b00cda1b2db1de36d03589de54e2" href="#summary">const byte USB_REQ_SET_LINE_CODING = 0x20
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="3545d5c6bfcf6cc873a2a0ec52524ca1" href="#summary">var volatile byte cdc_tx_wr=0
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="2b13db03a8ce80e5f64e518fed4c1794" href="#summary">var volatile byte cdc_rx_rd = 0
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="0a8b26a8614039d6513cdce19598d421" href="#summary">var volatile byte cdc_line_coding_parity at cdc_line_coding[5]       -- 0=None, 1=Odd, 2=Even, 3=Mark, 4=Space
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6acf65c04beedfb1f66868a8c54e3602" href="#summary">var volatile byte cdc_line_coding[7]
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="94ad025aa4c621b5bd9c33afa693cbde" href="#summary">const byte USB_REQ_SET_CONTROL_LINE_STATE = 0x22
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c40ddd1e6b1bfc17d1f2b5daa460a4a8" href="#summary">const byte USB_REQ_GET_ENCAPSULATED_RESPONSE = 0x01
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="845ceb8817c3405cd3c18c79959d0fb6" href="#summary">var volatile byte cdc_line_coding_stop_bits at cdc_line_coding[4]    -- 0=1 stop bit, 1=1.5 stop bits, 2=2 stop bits
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="7f99ff1a9c486751e961f38de9127aab" href="#summary">var volatile dword cdc_line_coding_dte_rate at cdc_line_coding[0]
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6574d4cb897f0fd0164790a711658bf9" href="#summary">var byte cdc_rx_buffer[USB_CDC_RX_BUFFER_SIZE]
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="ba0bfa0f3ccf687c4c17381333aa8bfe" href="#summary">const byte USB_REQ_SET_COMM_FEATURE = 0x02
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6aba3bd37543b244d784104febfba7a4" href="#summary">var bit last_packet_is_full = false
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="5a6cd246232de57216d562a0f604fb34" href="#summary">const byte USB_REQ_SEND_ENCAPSULATED_COMMAND	= 0x00
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="4ec121da305870f23890910c898958d3" href="#summary">var volatile byte cdc_tx_rd=0
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c8aa8d576828e4548870e5c9088df34f" href="#summary">const byte USB_REQ_CLEAR_COMM_FEATURE = 0x04
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="082b209717e04a026a8711afdd7e2370" href="#summary">var volatile byte cdc_rx_wr = 0
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="7516891a02608f7b905237ada1683074" href="#summary">var volatile byte cdc_line_coding_data_bits at cdc_line_coding[6]    -- 5,6,7,8 or 16 bits
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6a258c1082d55259975cb1b0d948fe53" href="#summary">const byte USB_REQ_GET_LINE_CODING = 0x21
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="821b320f21b4a76496eef997e2804acd" href="#summary">usb_handle_class_request_callback()</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="ea6b1f15ff85043486e49c8e9bf0b063" href="#summary">usb_handle_class_ctrl_read_callback()</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="26c043dd07cc5d50f99833052c5fb800" href="#summary">usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count)</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="b668997307b1ad66a40213380c6ed5cf" href="#summary">usb_cdc_putc(byte in c)</a></code></b>
				<p>	<pre>
This usb_cdc_putc will transmit the specified character. Under normal conditions
the character to be transmitted is placed into the fifo, so the call will be non
blocking. This implies that buffer overruns can occur when the transmit FIFO is full. 
Therefore it is adviced to check the transmit FIFO state before calling this procedure
to avoid buffer overruns. These buffer overrun issues have been addressed in the 
usb_serial library, therefore it is highly recommended to use this library instead 
of calling this low level procedure

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="943b9721ceeae048bbc372b815ea6647" href="#summary">usb_cdc_handle_tx()</a></code></b>
				<p>	<pre>
This procedure will handle the transmission of the (bulk) data. The procedure check
if there are pending characters in the tranmit FIFO. These character(s) are send in
chunk(s), the chunk size is dependent on the conifguration of the bulk interface
endpoint

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="cb5231cab1ade54cebf58ea5e5653fc5" href="#summary">usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count)</a></code></b>
				<p>	<pre>
This function is called when data can be transmitted via the bulk interface

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="7fa585d1e13980a194c675bb6f6b2338" href="#summary">usb_handle_class_ctrl_write_callback()</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="07e2ad4d28529381837dcb7694bbc2c4" href="#summary">usb_sof_callback()</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="43d2c8422eb7a33e823a9f18407a5afb" href="#summary">usb_cdc_setup()</a></code></b>
				<p>	<pre>
This procedure will intialize the line status of the communicatin device class

</pre>
</p>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="91826177975503d587283eaea06244a9" href="#summary">usb_cdc_rx_avail() return bit</a></code></b>
				<p>	<pre>
This function returns there has been a character received, function will return true 
if there is at least one pending receive character, false otherwise

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="5b81d62ed81745fa0be3273d607b2239" href="#summary">does_sie_owns_tx_buffer() return bit</a></code></b>
				<p>	<pre>
This function returns the status of the SIE tx buffer. Either the SIE can own the
transmit buffer (tranmit is pending) or it can be owned by the CPU. This function 
return true if the SIE owns the buffer, otherwise false is returned

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="f611f639cd92e026cf5d1d76d6d363d4" href="#summary">usb_cdc_line_status() return byte</a></code></b>
				<p>	<pre>
This function returns the line status. If on the host side the COM port has not been
opened, the return status will be 0x00, otherwise it will be != 0

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="89de70291f2716551b6e61cca508f295" href="#summary">usb_cdc_getc() return byte</a></code></b>
				<p>	<pre>
This usb_cdc_getc function wait (blocking) until a character has been received.
The byte value of the received character is returned by this function

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="708b9418c5edeae63cfe0a8e76a4d476" href="#summary">usb_cdc_tx_empty() return byte</a></code></b>
				<p>	<pre>
This function returns the empty status of the transmit FIFO, it will return true if
transmit FIFO is empty, false otherwise

</pre>
</p>
		</li>
	</ul>



			<br/>
				<h2><a name="related_samples">Related samples</a></h2>
		<i>No sample found</i>

			<br/>

            </div>
        </div>


	</body>
</html>

