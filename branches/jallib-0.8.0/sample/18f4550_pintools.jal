-- Title: Show how to access pins by number, controlling their direction and levels, using pintools.jal library
-- Author: SÃ©bastien Lelong, Copyright (c) 2008..2010, all rights reserved.
-- Adapted-by:
-- Compiler: 2.4m
-- Revision: $Revision$
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this sample show how to use pintools.jal library. pintools.jal allows to
-- access pins using a number. This number is first defined in kind of associative array.
-- Using pintools.jal, you don't have to use pin's name.
-- This sample uses LEDs and push-buttons:
--  - when switch SW1 is pushed, pin_A0 (LED1) switches between high and low level
--  - when switch SW2 is pushed, pin_C2 (LED2) switches between output and input direction
--    (if output, LED shines)
-- that is, we're controlling LED1 with its level, and LED2 with its direction
--
-- Notes:
-- pin A0 has one led + seriese resistor
-- pin C2 has one led + seriese resistor and also one pull-up resistor
-- switches are on D6 and D7
--

include 18f4550                    -- target PICmicro
--
-- Compiler directives
pragma target CLOCK    48_000_000  -- CPU frequency
--
-- Configuration memory settings (fuses)
pragma target OSC      HS_PLL      -- HS crystal or resonator
--                                    and using PLL
pragma target PLLDIV   P5          -- reduce OSC 20->4 MHz for PLL input
pragma target CPUDIV   P1          -- CPU freq. from PLL(96)/2 -> 48 MHz
--                                    (without PLL: CPU freq. = OSC freq.)
pragma target USBPLL   F48MHZ      -- USB clock from PLL module
pragma target FCMEN    DISABLED    -- no fail-safe clock monitoring
pragma target IESO     DISABLED    -- no int/ext clock switchover
pragma target BROWNOUT DISABLED    -- no brownout detection
pragma target VREGEN   ENABLED     -- enable USB voltage regulator
--                                    (when no external regulator at Vusb)
pragma target WDT      DISABLED    -- no watchdog
pragma target XINST    DISABLED    -- not supported by JalV2
pragma target DEBUG    DISABLED    -- no debugging
pragma target LVP      DISABLED    -- no Low Voltage Programming
pragma target ICPRT    DISABLED    -- no In Circuit Debug
pragma target MCLR     EXTERNAL    -- reset externally
--
-- Note: Not specified:
--       Code protection, Boot Block Code protection, Data EEPROM protection,
--       Write protection, Configuration Memory write protection,
--       Table Read protection, Boot Block Table Read protection,
--       and maybe some other configuration bits.
--
OSCCON_SCS = 0b00                  -- select primary clock source
--
enable_digital_io()                -- make all pins digital I/O

include delay -- include the delay library

-- Setup 2 pushbuttons, to control the LEDs
alias sw1 is pin_D6
alias sw2 is pin_D7
pin_D6_direction = input
pin_D7_direction = input

-- we here define our associate array, a mapping between
-- pin names and an arbitrary index. crumboard_shield.jal says:
--  - LED1 is on pin_A0: its index will be 0
--  - LED2 is on pin_C2: its index will be 1
-- Array map's elements go y two: [port,number], so
-- this translates to (size = 2 * 2 pins):
-- index:                        0      1
const byte pintools_map[4] = {"A",0, "C",2}
include pintools
alias pin is pintools_level
alias pin_direction is pintools_direction
--
-- set your pins to outputs
pin_direction[0] = output
pin_direction[1] = output -- this pin direction will change in main program

-- rename pins to led
alias led is pintools_level

forever loop
   -- "read" switch SW1
   if sw1 == high then
      -- here we set pin #0, which is pin_A0, to high or low level
	  -- according to previous level
	  led[0] = !led[0]
   end if

   -- same for SW2
   if sw2 == high then
	  -- here we set pin #1, which is pin_C2, to input or output direction
	  -- according to previous direction
	  pin_direction[1] = !pin_direction[1]
   end if

   -- debounce push buttons
   delay_1ms(200)
end loop

--
