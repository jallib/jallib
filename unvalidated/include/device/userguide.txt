

         J A L V 2   D E V I C E   I N C L U D E   F I L E S
         ===================================================
                           Rob Hamerling


 Introduction
 ------------
 When I started with JAL it struck me that there were so few JALV2 include
 files, in particular not for some of my favorite PICmicros (e.g. 16F690,
 12F683). Unfortunately the output of INC2JAL for these chips caused
 compile-time errors with my programs (I understood INC2JAL is not
 up-to-date for JalV2). Having some experience with scanning MPLAB files
 (for my Xwisp2 program) I decided to write a Rexx script to generate
 a set of include files myself!

 The advantages of using a script to generate files are obvious, such as:
  - Creation of device include files for all PICmicros available in MPLAB,
    automatically updated for new chips and corrections in new versions of
    MPLAB.
  - consistent layout
  - consistent naming convention
  - no typing errors

 The advantages of a standard naming convention are also obvious:
  - Easy migration of a program from one target PICmicro to another.
  - Same for libraries using this naming convention.

 This document gives some design and user information about my JalV2 device
 include files. Apart from the .dev files also the .lkr of MPLab are used.



                T H E   O V E R A L L   P I C T U R E
                =====================================

                      +----------+   +-----------+
                      | device   |   |  general  |
                      | specific |---|  include  |
                      | include  |   |chipdef.jal|
                      +----------+   +-----------+
                           |
           +---------------+---------------+-------------
           |               |               |
     +----------+    +----------+    +----------+    +---
     | function |    | function |    | function |    |
     | include  |    | include  |    | include  |    | etc
     | 'delay'  |    |  'adc'   |    |  'lcd'   |    |
     +----------+    +----------+    +----------+    +---


 General Include (chipdef.jal)
 -----------------------------
 The file 'chipdef.jal' which comes with these device include files replaces
 the file with the same name which comes with the compiler distribution.
 It is included by each of the device include files and contains:
 - Constants required by the compiler
 - Commonly used constants for the device include files

 With the statement 'pragma target chip = .....' in every device include
 file the compiler assigns a value to the variable 'target_chip'.
 The program may reference this variable with a symbolic name.  This
 symbolic name consists of 'pic_' followed by the type of the PIC.
 It makes it possible to use the same source file to generate a hex file
 for different types of PICs, as the following example shows:

    include 16f88

    if (target_chip == PIC_16F88) then          -- (not for 16F87)

      ....                                      -- 16F88 unique code

    end if

 By changing the include statement to 16f87 the statements between 'if' and
 'end if' will be skipped by the compiler.

 The list of targets in chipdef.jal makes sure that every possible target
 name and the corresponding value of target_chip is known by the compiler.
 Note: The original chipdef.jal file of the compiler package specifies
       different (and not as many) values for 'target_chip' and therefore it
       has to be replaced when using this set of include files.


 Device Include
 --------------
 The device specific include files contain:
 - CPU type (12-, 14- or 16-bits core)
 - Program memory size specification
 - Data memory (EEPROM) location and size specification
 - Configuration and ID memory specification.
 - General purpose register (GPR, RAM) location range and sharing.
 - Special function register (SFR) address and mirror adresses,
   alias names and bit naming.
 - Procedures and functions for shadowing of I/O ports.
 - Symbolic name declarations for configuration bits (fuses).


 Function Include
 ----------------
 Function specific include files have to be included by the program
 as required. In most cases these include files require some statements
 to couple function specific registers and pins with the device. See the
 corresponding libraries and accompanying documentation for instructions.



                  U S E R   I N F O R M A T I O N
                  ===============================

 Sample program
 --------------
 The device include files define static device (PICmicro) specific matter.
 This allows writing elementary programs, such as for a blinking LED, which
 become practically device independent.

 The device include files are also the base for extensions, such as
 libraries for more complicated functions, such as displaying text on an LCD
 display or handling analog devices.

 Below a simple blink-an-LED program (LED on pin 1 of POrt A) for a
 PIC16F886 using a 20 MHz resonator. In addition to the device-specific
 information obtained from the include file '16f886.jal' some run-time
 information is needed, like the speed and type of the oscillator and some
 other 'environmental' variables. No extra function libraries are required.

   -- ------ Blink-an-LED on pin A1 of a PIC16F886 --------------------------

   include 16f886                        -- target is a PIC16F886
                                         -- Notes: - The extension .jal is
                                         --          added by the compiler!
                                         --        - No other includes needed.

   pragma target clock 20_000_000        -- oscillator frequency (in Hz)
                                         -- required by _usec_delay

   pragma target OSC         HS          -- high speed external oscillator
   pragma target WDT         Disabled    -- watchdog off
   pragma target MCLR        External    -- external chip reset
   pragma target LVP         Disabled    -- no low voltage programming

   enable_digital_io()                   -- diable analog module(s)

   var volatile bit led is pin_A1        -- define alias for pin_A1
   var volatile bit led_direction is pin_A1_direction

   led_direction = output                -- make LED-pin output
   forever loop                          -- endless loop
     led = on                            -- there is light!
     _usec_delay(250000)                 -- spin 1/4 seconds
     led = off                           -- flip (on->off,off->on)
     _usec_delay(250000)                 -- spin 1/4 seconds
   end loop

 When loaded in a 16F886 with 20 MHz resonator or crystal an LED connected
 (with series resistor!) to pin 3 (RA1) should blink twice a second.


 Naming conventions for Ports and Port pins
 ------------------------------------------
 Unfortunately MPLAB of Microchip is not particularly consistent in its
 choice of names! The datasheets and various informational files in MPLAB
 not infrequently use different names for the same entity! Since programmers
 are supposed to read the datasheets, the most obvious would be to use the
 datasheet names, but these are not part of MPLAB and would have to be
 downloaded separately. And these PDF files are not so easily processed with
 a script. So the chosen names are possibly not what you may be used to.

 For all registers of the chip a name is defined and where appropriate also
 the individual bits or groups of bis are declared.  Also some popular
 aliases for registers are defined, for example: TMR0IF and T0IF, TMR0IE and
 T0IE, etc.

 For all ports and port pins a device independent alias is defined
 and a similar direction definition, as the following examples show:

 For PORTA and TRISA:
   var  volatile  byte  PORTA  at  <addr>
   var            byte  PORTA_low                 -- low order nibble
   var            byte  PORTA_high                -- high order nibble
   var  volatile  bit   pin_A0  at  PORTA : 0
   var  volatile  byte  TRISA  at  <addr>
   var  volatile  byte  PORTA_direction at TRISA
   var  volatile  bit   pin_A0_direction at TRISA : 0
   etc. (for all other existing pins and ports)

 Similarly for GPIO and TRISIO (with the smaller chips):
   var  volatile  byte  GPIO   at  <addr>
   var  volatile  byte  PORTA  at  GPIO
   var            byte  PORTA_low                -- low order nibble
   var            byte  PORTA_high               -- high order nibble
   var  volatile  bit   pin_A0  at  GPIO : 0
   var  volatile  byte  TRISIO  at <addr>
   var  volatile  byte  TRISA  at  TRISIO
   var  volatile  byte  PORTA_direction at TRISIO
   var  volatile  bit   pin_A0_direction at TRISIO : 0
   etc. (for all other existing pins)

 In addition procedures and functions are defined to read and set the
 lower and upper nibbles of ports and their direction:
   PORTx_low
   PORTx_high
   PORTx_low_direction
   PORTx_high_direction

 Notes: 1. When you have used Jal before you may notice some differences in
           naming convention:
           - PORTA is used consistently, while previously PORT_A was a
             popular naming convention especially for PORT_A_low/high,
             PORT_A_direction, etc. For individual pins the convention
             'pin_Ax' is maintained.
           - Subfields of registers have the registername as prefix, like
               var volatile bit  INTCON_GIE  at INTCON : 7
        2. See the extra alias declarations for the GPIO and TRISIO registers
           and their bits. Programs and function libraries can access the
           GPIO bits with PORTx and PIN_xy names, allowing easy program
           migration from one PIC to another.


 About Port Shadowing
 --------------------
 Port shadowing is a technique to prevent the Read-Modify-Write problem with
 I/O ports of PICmicro's. This is a problem related to its hardware design
 and may occur when a read of a port is immediately followed by writing to
 that port.
 With port shadowing a RAM location is used as replacement for the port.
 Reading is done from the port directly. Writing is done to the shadow
 register and then its contents flushed to the real port.

 With these device include files shadowing is automatic, as long as you use
 the following names:
   PORTx          - all bits of port x
   PORTx_low      - low order nibble of port x (bits 3..0)
   PORTx_high     - high order nibble of port x (bits 7..4)
   pin_xy         - single bit 'y' of port 'x'
 (in which 'x' is a port-letter and 'y' a bit number).

 If you want to use other names for pins or nibbles or the whole port you
 can specify an alias. For example when you have a red LED connected to pin
 0 of PortA, you could specify:

   var  bit led_red is pin_A0

 and use 'led_red = on' or 'led_red = off' in your program.

 You should avoid direct pin and I/O port manipulation, because it will be
 overruled by the automatic shadowing mechanism. For example do not specify:

   var bit led_red at portA : 0

 With this specification a 'led-red = on' will have the desired result, but
 it will not update the shadow register. Any next operation which uses the
 shadowing mechanism will override the previous direct control operation.

 The shadowing is also bypassed when you initialise the alias with the
 declaration. So declaring and initialising an alias as follows:

   var  bit led_red is pin_A0 = off

 is bad practice!



 Naming convention for configuration bitmasks (fuses)
 ----------------------------------------------------
 The configuration bits or groups of bits is such a large variety that it
 is not easy to have a naming convention which covers it all.
 The following design rules are used:
   - For all implemented config bits a option name and tags are defined,
     but:
      - duplicate option names may be generated
      - duplicate tags may be defined for a single option
      - some of the tags may not be acceptable for the compiler
   - When the compiler stalls over a fuse-def line a manual correction
     should be applied.
   - For the most popular config bits a 'standard' option name is
     defined, along with a 'standard' tag, see the list below.

 Only for the oscillator specification the MPLAB information files contain
 more than 140 different indications!! Because of the synonyms this number
 could be 'normalised' to a much smaller number! The first part is the
 oscillator type, the [optional] second part indicates secundary functions.
 For example it may indicate if the OSC2 pin is CLKOUT or I/O, or if PLL is
 active for the 18F series.
 Other names may appear when the script could not decipher the description
 in the MPLab device file.

 Fuse_Def OSC  (oscillator)
       LP              - Low Power crystal on OSC1,OSC2
       XT              - Crystal or Resonator on OSC1,OSC2
       HS              - High Speed Crystal or Resonator on OSC1,OSC2
       HS_PLL          - as HS + PLL
       HS_USB          - as HS + USB
       EC_CLKOUT       - External Clock (TTL) signal on OSC1, OSC2 is ClockOut
       EC_NOCLKOUT     - External Clock (TTL) signal on OSC1, OSC2 is I/O
       EC_PLL          - as EC + PLL active
       EC_USB          - as EC + USB
       RC_CLKOUT       - RC oscillator on OSC1, OSC2 is ClockOut
       RC_NOCLKOUT     - RC oscillator on OSC1, OSC2 is I/O
       EXTOSC_CLKOUT   - External oscillator on OSC1, ClockOut on OSC2
       EXTOSC_NOCLKOUT - External oscillator on OSC1, OSC2 is I/O
       INTOSC_CLKOUT   - Internal oscillator, OSC1 is I/O, ClockOut on OSC2
       INTOSC_NOCLKOUT - Internal oscillator, OSC1 and OSC2 are I/O
       (some other keywords may be used)

 Fuse_Def WDT  (watchdog)
       ENABLED          - Watchdog enabled
       DISABLED         - Watchdog disabled

 Fuse_Def WDTPS  (Watchdog postscaler)
       P32768           -  1 : 32,768
       P16384           -  1 : 16,384
       P...             -  1 : ...
       P2               -  1 : 2
       P1               -  1 : 1

 Fuse_Def MCLR  (reset)
       EXTERNAL         - /MCLR pin enabled
       INTERNAL         - /MCLR pin is digital I/O

 Fuse_Def PWRTE  (power reset timeout)
       ENABLED          - Power up timer enabled
       DISABLED         - Power Up timer disabled

 Fuse_Def BROWNOUT  (Brown Out detect)
       ENABLED          - BOD enabled, SBOREN disabled
       RUNONLY          - BOD enabled in run, disabled in sleep
       CONTROL          - SBOREN controls BOR function
       DISABLED         - BOD and SBOREN disabled

 Fuse_Def VOLTAGE  (Brownout voltage)
       V20              - 2.0 Volt
       V27              - 2.7 Volt
       V42              - 4.0 Volt
       V45              - 4.5 Volt
       ...  etc (whatever voltages are applicable)

 Fuse_Def LVP  (Low Voltage Programming)
       ENABLED          - LVP on, enabled
       DISABLED         - LVP off, disabled

 Fuse_Def CP  (Code Protection)
       ENABLED          - Code protection on, enabled
       DISABLED         - Code Protection off, disabled

 Fuse_Def CPD  (EEPROM Data Protection)
       ENABLED          - Data Protection on, enabled
       DISABLED         - Data Protection off, disabled

 Notes: 1. In addition to the 'standard' fuse_defs above there may be
           others, depending on the features of the specific PICmicro.
           Please read the include file to see which fuse-defs are
           available for your target PICmicro.
        2. The terms 'Enabled' and 'Disabled' may need to be specified where
           usually 'On' and 'Off' are used.

 When the fuse_def statements cause compile-time error messages you may
 simply delete these and specify the fuse-word(s) or -byte(s) explicitly
 with bit patterns in stead of using fuse option pragma statements.
 For example for the PIC16F690 the following group of statements:

   pragma target OSC       HS
   pragma target WDT       Disabled
   pragma target PWRTE     Enabled
   pragma target MCLR      External
   pragma target CP        Disabled
   pragma target CPD       Disabled
   pragma target BROWNOUT  Enabled
   pragma target IESO      Disabled
   pragma target FCMEN     Disabled

 is equivalent with:

   pragma target fuses   0b11_0011_1110_0010

 PICs with 16-bits core (the 18F series) have such a large variety of
 configuration bits that explicit specification is probably the best way to
 make sure all config bits are set correctly for your program. As an example
 see the following list for a simple blink-a-LED program with an 18F242.

  pragma  target fuses 0  0b0000_0000       -- (n/a)
  pragma  target fuses 1  0b0010_0010       -- not switchable, HS osc, no PLL
  pragma  target fuses 2  0b0000_0001       -- BOR disabled, PWTR disabled
  pragma  target fuses 3  0b0000_0000       -- watchdog disabled
  pragma  target fuses 4  0b0000_0000       -- (n/a)
  pragma  target fuses 5  0b0000_0001       -- CCP2 on RC1
  pragma  target fuses 6  0b1000_0001       -- no bg debug, no LVP, STVREN
  pragma  target fuses 7  0b0000_0000       -- (n/a)
  pragma  target fuses 8  0b0000_1111       -- no code protection
  pragma  target fuses 9  0b1100_0000       -- no data protection
  pragma  target fuses 10 0b0000_1111       -- no code write protection
  pragma  target fuses 11 0b1110_0000       -- no other write protection
  pragma  target fuses 12 0b0000_1111       -- no table read protection
  pragma  target fuses 13 0b0100_0000       -- no boot block write protect

 Notes: - All pragma statements must be specified after the include
          statement of the device file.
        - When a PIC has multiple config words or bytes the index value
          of the word or byte should be specified before the value.
        - The device file contains a fuses specification for the compiler:
          how many words/bytes and their corresponding memory addresses.

 The meaning of config bits can be found in the DataSheet of the specific
 PICmicro, or in the Programming Specifications. For your convenience the
 MicroChip document numbers are mentioned in the heading of the device
 include files (when present in the MPlab .dev files!).


 Miscellaneous
 -------------

 These device include files are now part of the central JalV2 repository
 'Jallib' (http://jallib.googlecode.com). Other libraries of Jallib have
 been or are being converted to use the names as described in this document.
 You should consider to use only this combination of include files.
 Using these device include files in combination with other libraries may
 cause problems:

 - Bank switching functions are not needed with JalV2 and do not appear in
   the device includes. This may cause compile-time errors when using
   programs or libraries which still use these procedures. Please remove
   these bank switching functions from your programs or libraries!

 - The device specific include files are generated from the MPLAB .dev and
   .lkr files. This may cause confusion or even conflicts because the
   register and bit names are not always identical to those in the
   datasheets! Apart from that MPLAB is not errorfree, consequently include
   files generated from this source are not guaranteed errorfree too!

 - The naming convention of ports and subfields is different, you may have
   to convert other libraries.




