-- ----------------------------------------------------------------------------
-- Title: glcd_ks0108 - Library for KS0108 compatible graphic LCDs
-- Author: Serkan Ayyldz Copyright (c) 2006..2026, all rights reserved.
-- Adapted-by: Sebastien Lelong, Rob Hamerling, Rob Jansen
-- Compiler: 2.5r9
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources: LCD MODULE SPECIFICATION, BG12864A series Bolymin, Inc. 2005-05-21.
--
-- Description: Library for KS0108 compatible graphic lcds with 128x64 resolution
--              for example the GDM12864A.
--
-- Notes:- A 128x64 graphic LCD consists with 2 controllers (KS0108_LEFT and
--          KS0108_RIGHT), each take care of 64x64 bits.
--        - Addressing: upper left corner is coordinate (0,0)
--        - A byte of data represents a column of 8 pixels, so the vertical
--          64 pixels are represented by 8 bytes (a row of 8 bits is called
--          'page' in the datasheet).
--
--         The display is vertical oriented.When using a horizontal oriented 
--         character font, a character buffer is needed with the size of the 
--         used font, also see FONT_xxxx_BYTE_PER_CHAR in the font library you 
--         are using. The default size of this buffer is 64 bytes and can be 
--         reduced to save data space if a smaller font, or no font, is used.
--         For example the 12x16 horizontal font uses 32 bytes for one character 
--         and so we can set the character buffer to this size by:
--         -) const KS0180_CHAR_BUFFER_SIZE = 32 
--         If no buffer is used (e.g. for vertical oriented fonts), the buffer
--         size is set to the minimum value of 1.
--

const byte GLCD_X_PIXELS       = 128               -- display x-dimension
const byte GLCD_Y_PIXELS       = 64                -- display y-dimension
const byte GLCD_COLOR_BITS     = 1                 -- monochrome display

const bit  KS0108_LEFT         = 0                 -- select left part of display
const bit  KS0108_RIGHT        = 1                 -- select right part of display
const byte KS0108_CMD_ON       = 0x3F              -- command to enable the display
const byte KS0108_CMD_OFF      = 0x3E              -- command to disable the display
const byte KS0108_CMD_PAGE     = 0xB8              -- command to select page (y-coord / 8)
const byte KS0108_CMD_COLUMN   = 0x40              -- command to select column (x-coord)
const byte KS0108_CMD_TOP_RAM  = 0xC0              -- command to set startline

-- constant colors
const byte GLCD_BLACK          = 0x01              -- normal pen color
const byte GLCD_WHITE          = 0x00              -- alternate pen color

-- data/instruction selection of DI line
const bit GLCD_DI_DATA        = high              -- select data to display
const bit GLCD_DI_INST        = low               -- select command

var byte glcd_background_color = GLCD_WHITE        -- default background color
var byte glcd_pen_color        = GLCD_BLACK        -- default pen color


-- Define some glcd aliases for the available procedures. See glcd_common.
procedure glcd_write_pixel(byte in x, byte in y)  
procedure glcd_clear_screen()
procedure ks0108_draw_image(byte in image[],
                            byte in x, byte in y,
                            byte in width, byte in height)
alias glcd_draw_image is ks0108_draw_image  

-- The display does not support autowrap.
if defined(FONT_AUTO_WRAP) then
   if FONT_AUTO_WRAP == FALSE then
       _warn "FONT_AUTO_WRAP must be set to TRUE because this is\n\t
              the default behavior for this GLCD controller"
   end if
else
    const bit FONT_AUTO_WRAP = TRUE
end if

-- When using horizontal fonts we need a buffer to store one character.
if defined(GLCD_FONT_USAGE) then
   -- Define the buffer for writing characters using bigger fonts.
   if !defined(KS0108_CHAR_BUFFER_SIZE) then
      -- Reserve the minimum size of 1. Note that for a font of 16x32
      -- you need 64 bytes. 
      const KS0108_CHAR_BUFFER_SIZE = 1
   end if 
   var byte _ks0108_char_buffer[KS0108_CHAR_BUFFER_SIZE]

   procedure ks0108_write_char(byte in x, byte in y, byte in char)
   -- Define the glcd alias for this procedure.
   alias glcd_write_char is ks0108_write_char  
   -- Must include glcd_common in this case for glcd_write_char to work.
   include glcd_common  
end if


-- ----------------------------------------------------------------------------
-- Purpose: Remap bits of a byte.
-- Input:   Byte of which bits must be remapped.
-- Returns: Byte with rempapped bits of input byte.
-- Notes:   - Supports currently only reversing the bits in a byte.
--            (may add support for other types of mapping later).
--          - Reverse is only done when const bit GLCD REVERSE_DATABITS = TRUE
-- ----------------------------------------------------------------------------
function remap_bits(byte in data) return byte is
   if defined(GLCD_REVERSE_DATABITS) then
      if (GLCD_REVERSE_DATABITS == TRUE) then
         var bit data0 at data:0
         var bit data1 at data:1
         var bit data2 at data:2
         var bit data3 at data:3
         var bit data4 at data:4
         var bit data5 at data:5
         var bit data6 at data:6
         var bit data7 at data:7
         var byte x = 0b_0000_0000
         var bit x0 at x:0
         var bit x1 at x:1
         var bit x2 at x:2
         var bit x3 at x:3
         var bit x4 at x:4
         var bit x5 at x:5
         var bit x6 at x:6
         var bit x7 at x:7
         if data0 == 1 then x7 = 1 end if
         if data1 == 1 then x6 = 1 end if
         if data2 == 1 then x5 = 1 end if
         if data3 == 1 then x4 = 1 end if
         if data4 == 1 then x3 = 1 end if
         if data5 == 1 then x2 = 1 end if
         if data6 == 1 then x1 = 1 end if
         if data7 == 1 then x0 = 1 end if
         return x
      end if
   end if   
   return data
  
end function


-- ----------------------------------------------------------------------------
-- Purpose:   Low level write a byte to the specified chip
-- Arguments: - side: which chip to write the data to: 0 = left, 1 = right)
--            - data: the byte of data to write)
-- Notes:     The 'data' byte may be display data or a command.
--            When it is data to be displayed its coordinates must
--            have been been set on beforehand (column,page).
--            GLCD_E is set low for 1/4 cycle upon call and kept low
--            for 1/4 cycle before returning such that successive calls
--            to read or write have GLCD_E low for at least 1/2 cycle
--            between calls.
-- ----------------------------------------------------------------------------
procedure  ks0108_write_(bit in side, byte in data) is

   GLCD_E = low                                    -- start cycle in low state
   _usec_delay(1)                                  -- Twl/2
   if side == KS0108_LEFT then                     -- select left half
      GLCD_CS2 = low
      GLCD_CS1 = high
   else                                            -- select right half
      GLCD_CS1 = low
      GLCD_CS2 = high
   end if
   GLCD_RW = low                                   -- clear for writing
   _usec_delay(1)                                  -- Twl/2 (Tasu)
   GLCD_DATAPRT = remap_bits(data)                 -- data on the port
   GLCD_DATAPRT_DIR = all_output                   -- set port to output
   GLCD_E = high                                   -- set to high state
   _usec_delay(2)                                  -- Twh (Tdsu)
   GLCD_E = low                                    -- data to display
   _usec_delay(1)                                  -- Tah
   GLCD_CS1 = low                                  -- deselect both halves
   GLCD_CS2 = low
   GLCD_E = high                                 

end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Low level read of a byte from the specified chip.
-- Arguments: side: which chip to read, 0 = left, 1 = right)
-- Returns:   A byte of data read from the chip (row of 8 vertical pixels).
--            The coordinates (column,page) must have been been set on
--            beforehand.
-- Notes:     GLCD_E is set low for 1/4 cycle upon call and kept low
--            for 1/4 cycle before returning such that successive calls
--            to read or write have GLCD_E low for at least 1/2 cycle
--            between calls.
-- ----------------------------------------------------------------------------
function ks0108_read_(bit in side) return byte  is

   var byte data                                   -- for the data from the display

   GLCD_E = low                                    -- start cycle in low state
   _usec_delay(1)                                  -- Twl/2
   if side == KS0108_LEFT then                     -- select left half
      GLCD_CS2 = low
      GLCD_CS1 = high
   else                                            -- select right half
      GLCD_CS1 = low
      GLCD_CS2 = high
   end if
   GLCD_DATAPRT_DIR = all_input                    -- Set port to input, before RW low
   GLCD_RW = high                                  -- set for reading
   _usec_delay(1)                                  -- Twl/2 (Tasu)
   GLCD_E = high                                   -- make E high, data is set-up
   _usec_delay(3)                                  -- Twh (Td), data delay time
   data = remap_bits(GLCD_DATAPRT)                 -- latch/read data
   GLCD_E = low                                    -- stop cycle
   GLCD_CS1 = low                                  -- deselect both halves
   GLCD_CS2 = low
   GLCD_E = high                                 

   return data                                     -- return the data
end function


-- ----------------------------------------------------------------------------
-- Purpose:   Turn the display on
-- Arguments: none
-- Notes:     both sides are activated
-- ----------------------------------------------------------------------------
procedure ks0108_on_() is
   ks0108_write_(KS0108_LEFT,  KS0108_CMD_ON)
   ks0108_write_(KS0108_RIGHT, KS0108_CMD_ON)
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Turn the display off
-- Arguments: none
-- Notes:     both sides are de-activated
-- ----------------------------------------------------------------------------
procedure ks0108_off_() is
   ks0108_write_(KS0108_LEFT,  KS0108_CMD_OFF)
   ks0108_write_(KS0108_RIGHT, KS0108_CMD_OFF)
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Set the page number
-- Arguments: - side
--            - page number (y-coordinate) 0..7
-- ----------------------------------------------------------------------------
procedure ks0108_page_(bit in side, byte in page) is
   pragma inline
   ks0108_write_(side, KS0108_CMD_PAGE | (page & 0x07))
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Set the column number
-- Arguments: - cide
--            - column number (x-coordinate) 0..63
-- ----------------------------------------------------------------------------
procedure ks0108_column_(bit in side, byte in column) is
   pragma inline
   ks0108_write_(side, KS0108_CMD_COLUMN | (column & 0x3F))
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Specify subsequent reads and writes are instructions
-- Arguments: none
-- ----------------------------------------------------------------------------
procedure ks0108_inst_() is
   pragma inline
   GLCD_DI = GLCD_DI_INST                          -- select instruction / command
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Specify subsequent reads and writes are data
-- Arguments: none
-- ----------------------------------------------------------------------------
procedure  ks0108_data_() is
   pragma inline
   GLCD_DI = GLCD_DI_DATA                          -- select data
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Goto the given pixel coordinates.
-- Arguments: - x, 0..127
--            - y, 0..63 
-- ----------------------------------------------------------------------------
procedure ks0108_goto_pixel(byte in x, byte in y) is
   var bit side = KS0108_LEFT                      -- default: select left half

   if defined(GLCD_FONT_USAGE) then 
      -- For font usage, set x and y from glcd_common in pixels for x and y.
      glcd_char_x_pos = x
      glcd_char_y_pos = y
   end if 

   if x >= (GLCD_X_PIXELS / 2) then                -- check for right half
      x = x - (GLCD_X_PIXELS / 2)                  -- correct offset
      side = KS0108_RIGHT                          -- select right half
   end if

   ks0108_inst_()                                  -- set for instruction
   ks0108_column_(side,x)                          -- set the horizontal address
   ks0108_page_(side, y / 8)                       -- set the page address
   ks0108_data_()                                  -- assume data is written

end procedure


-- ----------------------------------------------------------------------------
-- Purpose:    Write a single pixel to the display
-- Arguments:  - x-coordinate of the pixel
--             - y-coordinate of the pixel
-- ----------------------------------------------------------------------------
procedure glcd_write_pixel(byte in x, byte in y) is

   var byte data
   var bit  side = KS0108_LEFT                     -- default: select left half

   if x >= (GLCD_X_PIXELS / 2) then                -- check for right half
      x = x - (GLCD_X_PIXELS / 2)                  -- correct offset
      side = KS0108_RIGHT                          -- select right half
   end if

   ks0108_inst_()                                  -- set for instruction
   ks0108_column_(side, x)                         -- set the horizontal address
   ks0108_page_(side, y / 8)                       -- set the page address
   ks0108_data_()                                  -- set for data
   data = ks0108_read_(side)                       -- latch (no data!)
   data = ks0108_read_(side)                       -- read data

   if glcd_pen_color == GLCD_BLACK then  
      data = data |   (1 << (y % 8))               -- set pixel
   else
      data = data & ! (1 << (y % 8))               -- clear pixel
   end if
   ks0108_inst_()                                  -- set for instruction
   ks0108_column_(side,x)                          -- set the horizontal address
   ks0108_page_(side, y / 8)                       -- set the page address
   ks0108_data_()                                  -- set for data
   ks0108_write_(side, data)                       -- write the pixel data
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Write byte (column of 8 pixels) to display
-- Arguments: - x-coordinate of the pixel
--            - y-coordinate of the pixel (not necessarily on page boundary)
--            - pattern of 8 vertically aligned pixels
-- Notes:     When data on page boundary (y-coordinate multiple of 8): single write
--            When the data is crossing page boundary: two read-modify-write
--            operations have to be performed, which is considerably slower.
-- ----------------------------------------------------------------------------
procedure  ks0108_write_byte_(byte in x, byte in y, byte in data) is
   var bit side = KS0108_LEFT                      -- Select left display half
   if x >= (GLCD_X_PIXELS / 2) then                -- check if second display half
      x = x - (GLCD_X_PIXELS / 2)                  -- adapt x-coordinate
      side = KS0108_RIGHT                          -- select right display half
   end if
   ks0108_inst_()                                  -- set for instruction
   ks0108_column_(side,x)                          -- set the horizontal address
   ks0108_page_(side, y / 8)                       -- page address (rounded down)
   ks0108_data_()                                  -- set for data
   if ((y % 8) == 0) then                          -- y is on on page boundary
      ks0108_write_(side, data)                    -- write the pixel pattern
   else                                            -- NOT on page boundary
      var byte d1                                  -- intermediate pattern
      d1 = ks0108_read_(side)                      -- latch (no data!)
      d1 = ks0108_read_(side)                      -- read data
      d1 = d1 & (0xFF >> (8 - (y % 8)))            -- keep low order bits
      d1 = d1 | (data << (y % 8))                  -- replace high order bits with data
      ks0108_inst_()                               -- set for instruction
      ks0108_column_(side, x)                      -- set horizontal address
      ks0108_page_(side, y / 8)                    -- set page
      ks0108_data_()                               -- set for data
      ks0108_write_(side, d1)                      -- write the pattern

      ks0108_inst_()                               -- Set for instruction
      ks0108_column_(side,x)                       -- Set the horizontal address
      ks0108_page_(side, y / 8 + 1)                -- Page address rounded up
      ks0108_data_()                               -- Set for data
      d1 = ks0108_read_(side)                      -- latch (no data)
      d1 = ks0108_read_(side)                      -- read data
      d1 = d1 & (0xFF << (y % 8))                  -- keep high order bits
      d1 = d1 | (data >> (8 - (y % 8)))            -- replace high order bits with data (aligned)
      ks0108_inst_()                               -- set for instruction
      ks0108_column_(side, x)                      -- set horizontal address
      ks0108_page_(side, y / 8 + 1)                -- set page
      ks0108_data_()                               -- set for data
      ks0108_write_(side, d1)                      -- write the pattern
   end if
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:    read byte (column of pixels) from display
-- Arguments:  x = pixel column
--             y = pixel row (not necessarily on page boundary)
-- Returns:    byte, row of pixels on current location
-- ----------------------------------------------------------------------------
function ks0108_read_byte_(byte in x, byte in y) return byte is
   var byte d1,d2
   var bit  side = KS0108_LEFT                     -- Select left half
   if x >= (GLCD_X_PIXELS / 2) then                -- Check right half
      x = x - (GLCD_X_PIXELS / 2)
      side = KS0108_RIGHT
   end if
   ks0108_inst_()                                  -- Set for instruction
   ks0108_column_(side,x)                          -- Set the horizontal address
   ks0108_page_(side, y / 8)                       -- Page address rounded down
   ks0108_data_()                                  -- Set for data
   d1 = ks0108_read_(side)                         -- latch (no data)
   d1 = ks0108_read_(side)                         -- read data
   if ((y % 8) == 0) then                          -- when y is on page page: ready!
     return d1                                     -- return pixel pattern
   end if
                                                   -- crossing page boundary:
   d1 = d1 >> (y % 8)                              -- keep only relevant pixels
   ks0108_inst_()                                  -- Set for instruction
   ks0108_column_(side,x)                          -- Set the horizontal address
   ks0108_page_(side, y / 8 + 1)                   -- Page address rounded up
   ks0108_data_()                                  -- Set for data
   d2 = ks0108_read_(side)                         -- latch (no data)
   d2 = ks0108_read_(side)                         -- read data
   d2 = d2 << (8 - (y % 8))                        -- keep only relevant pixels
   return (d2 | d1)                                -- return combined pattern

end function


-- ----------------------------------------------------------------------------
-- Purpose:    Fill the whole GLCD with a pixel pattern (horizontal lines!)
-- Arguments:  bit pattern (8 pixel column, usually 0x00 or 0xFF)
-- Notes:      Uses auto-increment of x-coordinate for fast write of rows
-- ----------------------------------------------------------------------------
procedure glcd_fill(byte in data) is
   var byte i                                      -- loop counter
   for GLCD_Y_PIXELS / 8 using i loop              -- all pages
      ks0108_inst_()                               -- set for instruction
      ks0108_page_(KS0108_LEFT, i)                 -- set page address
      ks0108_page_(KS0108_RIGHT, i)
      ks0108_column_(KS0108_LEFT, 0)               -- set horizontal address to 0
      ks0108_column_(KS0108_RIGHT, 0)
      ks0108_data_()                               -- set for data
      for GLCD_X_PIXELS loop                       -- all columns (auto-increment)
         ks0108_write_(KS0108_LEFT, data)          -- left half
         ks0108_write_(KS0108_RIGHT, data)         -- right half
      end loop
   end loop
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:    Clear the screen
-- Arguments:  none
-- Notes:      Resets the display with the RST line
--             Uses current glcd_background_color setting as fill character
-- ----------------------------------------------------------------------------
procedure glcd_clear_screen() is
   GLCD_RST = low                                  -- hardware reset
   _usec_delay(2)                                  -- Trs
   GLCD_RST = high                                 -- hardware enable
   if (glcd_background_color == GLCD_WHITE) then   -- current background is white
      glcd_fill(0b0000_0000)                       -- row of 'white' pixels
   else
      glcd_fill(0b1111_1111)                       -- row of 'black' pixels
   end if
   ks0108_inst_()                                  -- Set for instruction
   ks0108_page_(KS0108_LEFT,0)                     -- Set the left page address to 0
   ks0108_page_(KS0108_RIGHT,0)                    --  "   "  right  "     "
   ks0108_column_(KS0108_LEFT,0)                   -- Set the left column address to 0
   ks0108_column_(KS0108_RIGHT,0)                  --  "   "  right   "      "
   ks0108_on_()                                    -- turn the display on
end procedure


-- ----------------------------------------------------------------------------
-- Purpose:   Initialize the graphic LCD.
-- Arguments: none
-- Notes:     to be called before using any other GLCD function.
-- ----------------------------------------------------------------------------
procedure glcd_init() is

   GLCD_DATAPRT = 0b0000_0000                      -- all zero
   GLCD_DATAPRT_DIR = all_output                   -- output

   GLCD_DI   = high                                -- set for data
   GLCD_RW   = low                                 -- set read mode
   GLCD_E    = high                                -- quisce
   GLCD_CS1  = low                                 -- deselect both halves
   GLCD_CS2  = low                                 --
   GLCD_RST  = high                                -- enable

   GLCD_RW_DIRECTION  = output
   GLCD_DI_DIRECTION  = output
   GLCD_E_DIRECTION   = output
   GLCD_CS1_DIRECTION = output
   GLCD_CS2_DIRECTION = output
   GLCD_RST_DIRECTION = output

   glcd_clear_screen()                             -- reset and clear the display

end procedure


if defined(GLCD_FONT_USAGE) then                   -- when using a font library

-- ----------------------------------------------------------------------------
-- Purpose:   Same as ks0108_write_char_(), but uses external font.
-- Arguments: - x-coordinate (in pixels) of left most pixel columm (range 0..127)
--            - y-coordinate (in pixels) of upper most pixel-row (range 0..63)
--            - character (binary value in range 32..122)
-- Notes:     When y-coordinate is a multiple of 8 (0,8,16,etc.): single write,
--            otherwise two read-modify-write cycles needed: slower!
-- ----------------------------------------------------------------------------
   procedure ks0108_write_char(byte in x, byte in y, byte in char) is

      var word index
      var byte offset, y_offset, buffer_offset
      var byte ch, mask, bit_count 

      -- Select the right character from the font table.
      offset = char - 32 -- Fix for ascii value.
      index = word(glcd_font_current_byte_per_char_) * word(offset) 
 
      -- The ks0108 uses vertical writing of pixels. 
      if (glcd_font_current_bit_direction_ == FONT_TOP_LEFT_HORIZONTAL) then
         -- First perform a range check to prevent buffer overflow.
         if (glcd_font_current_byte_per_char_ <= KS0108_CHAR_BUFFER_SIZE) then
            -- Fill the buffer with the character pixel data.
             for glcd_font_current_byte_per_char_ using offset loop
               _ks0108_char_buffer[offset] = glcd_font_lookup(index)
               index = index + 1
            end loop 
            -- Horizontal orientation means we have to rotate the character
            -- ninety degrees to the left and keep top left horizontal. 
            mask = 0 
            for glcd_font_current_width_ using offset loop
               -- Preset mask again when used. 
               if (mask == 0) then
                  mask = 0b1000_0000 -- Start with left most significant bit.
               end if 
               -- Set the starting position buffer pointer.
               buffer_offset = offset / 8
               bit_count = 0
               y_offset = 0
               ch = 0
               for glcd_font_current_height_ loop
                  ch = ch >> 1
                  if (_ks0108_char_buffer[buffer_offset] & mask) != 0 then
                     ch = ch | 0b1000_0000
                  end if 
                  bit_count = bit_count + 1
                  -- If 8 bits are done, write the byte and go to next bit.
                  if (bit_count == 8) then
                     -- Invert if needed. 
                     if (glcd_background_color == GLCD_BLACK) then
                        ch = ch ^ 0xFF
                     end if
                     ks0108_write_byte_(x + offset, y + y_offset, ch) 
                     ch = 0
                     bit_count = 0
                     y_offset = y_offset + 8
                  end if 
                  -- Next byte from buffer for next column. 
                  buffer_offset = buffer_offset + ((glcd_font_current_width_ - 1) / 8) + 1
               end loop
               -- If the height is not a full byte, complete the last part.
               if ((glcd_font_current_height_ % 8) != 0) then
                  ch = ch >> (8 - bit_count)
                  if (glcd_background_color == GLCD_BLACK) then
                     ch = ch ^ 0xFF
                  end if
                  ks0108_write_byte_(x + offset, y + y_offset, ch) 
               end if 
               -- Next bit.
               mask = mask >> 1
            end loop
            -- We need to restore the x- and y-coordinate for the next write.
            glcd_char_x_pos = x 
            glcd_char_y_pos = y
         end if 

      elsif glcd_font_current_bit_direction_ == FONT_BOTTOM_LEFT_VERTICAL then

         for glcd_font_current_width_ loop               -- whole character
            if (x >= GLCD_X_PIXELS) then                 -- check for maximum x value
               exit loop                                 -- clip text beyond display
            end if
            ch = glcd_font_lookup(index)                  -- obtain bit pattern
            if glcd_pen_color == GLCD_WHITE then         -- white pen
               ch = !ch                                  -- invert bit pattern
            end if
            ks0108_write_byte_(x, y, ch)                 -- write vertical pixel pattern
            index = index + 1                            -- next byte in font table
            x = x + 1                                    -- position of next pixel row
         end loop

      end if 


   end procedure


end if     -- (using a font library)

-- -----------------------------------------------------------------------------
-- Description: Draw an bitmap image from a byte array.
-- - Draws in vertical mode, 1 bit per pixel. 
-- Parameters: 
-- - image[] byte array with image
-- - x in range 0..127
-- - y in range 0..63
-- - width of image in number of pixels
-- - height of image in number of pixels
-- Notes:
-- - This procedure only fills the cache with the image. To send the contents of 
-- - the cache to the screen call sh1106_update_display()
-- -----------------------------------------------------------------------------
procedure ks0108_draw_image(byte in image[],
                            byte in x, byte in y,
                            byte in width, byte in height) is

   var word image_index
   var byte x_coord, y_coord, pixel_mask, data, pen_color

   -- We have to write the image in the selected pen color.
   pen_color = glcd_pen_color
   for height using y_coord loop
      pixel_mask = y_coord % 8
      for width using x_coord loop
         -- Calculate location of the data in the image array.
         image_index = word(x_coord) + (word(y_coord/8) * word(width))
         data = image[image_index]
         -- Always write a pixel but clearing the pixel depends on
         -- the chosen pen color.
         if (data & (1<<pixel_mask)) == 0 then
            -- Write in the inverted pen color (clear pixel).
            if (pen_color == GLCD_BLACK) then
               glcd_pen_color = GLCD_WHITE
            elsif (pen_color == GLCD_WHITE) then
               glcd_pen_color = GLCD_BLACK
            end if 
         end if
         -- Always write the pixel (nice for animations).
         glcd_write_pixel(x + x_coord, y + y_coord)
         -- Restore pen color.
         glcd_pen_color = pen_color
     end loop
   end loop
end procedure


