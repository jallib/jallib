-- Title: USB Mass Storage Device
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4o
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Library for USB MSD (Mass Storage Device) with SD card,
--              hard disk, or jallib supported storage device.
--
-- Sources:
-- http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
-- http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
-- http://direction.scene-double.com/2008/07/08/usb-msd-bootloader-for-pic-microcontrollers.aspx
--
-- Notes:
--

include usb_defs -- USB Definitions

-- variables
var dword _usb_msd_sector_step
var dword usb_msd_address
var byte _usb_msd_address[4] at usb_msd_address
var word _usb_msd_step64 = 0
var byte _usb_msd_step_byte = 0

-- msd status
const USB_MSD_STATE_WAIT      = 0   -- waiting for a CBW from host
const USB_MSD_STATE_DATA_IN   = 1   -- data in state (time for device to send data to host)
const USB_MSD_STATE_DATA_OUT  = 2   -- data out state (time for device to receive from host)
var byte usb_msd_state  = USB_MSD_STATE_WAIT

-- size of the storage device
var byte _usb_msd_num_of_blocks[4] at usb_msd_num_of_blocks
var byte _usb_msd_block_size[4] at usb_msd_block_size

-- UOWN bit
-- When SAE owns, we cannot use the endpoint. SAE is the usb module or  output interface.
-- When CPU owns, we can use the endpoint to write or send data.
-- We must give ownership back to SAE when we're done with it.
var volatile bit usb_msd_sae_owns_bit_in at usb_bd1in_stat : USB_BDSTATUS_UOWN	
var volatile bit usb_msd_sae_owns_bit_out at usb_bd1out_stat : USB_BDSTATUS_UOWN	
 	
-- prototypes. can't live without them :)
procedure usb_msd_process_data()
procedure usb_handle_isr()
procedure usb_send_csw()

-- CBW variables
const dword USB_MSD_CBW = 0x43425355      -- signature that helps identify data packet as a CBW
var dword usb_msd_cbw_signature = 0       -- variable to receive a CBW signature before checking
var byte _usb_msd_cbw_signature[4] at usb_msd_cbw_signature
var dword usb_msd_cbw_tag = 0             -- relat a SBW with a CSW at end of packet
var byte _usb_msd_cbw_tag[4] at usb_msd_cbw_tag
var dword usb_msd_cbw_data_transfer_length = 0 -- # of bytes of data that the host expects to transfer on the Bulk-In or Bulk-Out endpoint 1
var byte _usb_msd_cbw_data_transfer_length[4] at usb_msd_cbw_data_transfer_length
var volatile byte usb_msd_cbw_flags = 0   -- must be volatile otherwise compiler throws it away
var volatile byte usb_msd_cbw_cbw_lun = 0 -- must be volatile otherwise compiler throws it away
var volatile byte usb_msd_cbw_length = 0  -- must be volatile otherwise compiler throws it away
var byte*16 usb_msd_cbw_command = 0       -- command and parameters for a received CBW
var byte _usb_msd_cbw_command[16] at usb_msd_cbw_command

var bit usb_host_direction at usb_msd_cbw_flags : 7 -- direction the host wishes to transefer
const USB_HOST_DIRECTION_RECEIVE = TRUE
const USB_HOST_DIRECTION_SEND = FALSE

-- CSW variables
const USB_MSD_CSW = 0x53425355      -- signature that helps identify data packet as a CSW
var dword usb_msd_csw_signature = 0 -- relate CSW with a SBW at the end of packet
var byte _usb_msd_csw_signature[4] at usb_msd_csw_signature
var dword usb_msd_csw_tag = 0
var byte _usb_msd_csw_tag[4] at usb_msd_cbw_tag
var dword usb_msd_data_residue = 0
var byte _usb_msd_data_residue[4] at usb_msd_data_residue
var byte usb_msd_csw_status = 0          -- status of the command excecuted

-- status values for usb_msd_csw_status
const USB_MSD_CSW_STATUS_FAIL = 0x01     -- comand failed)
const USB_MSD_CSW_STATUS_SUCCESS = 0x00  -- command success

-- MSD commands we may get from host
const byte USB_MSD_INQUIRY                       = 0x12
const byte USB_MSD_READ_FORMAT_CAPACITY          = 0x23			
const byte USB_MSD_READ_CAPACITY                 = 0x25
const byte USB_MSD_READ_10                       = 0x28
const byte USB_MSD_WRITE_10                      = 0x2a
const byte USB_MSD_REQUEST_SENSE                 = 0x03
const byte USB_MSD_MODE_SENSE                    = 0x1a
const byte USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL  = 0x1e
const byte USB_MSD_TEST_UNIT_READY               = 0x00
const byte USB_MSD_VERIFY                        = 0x2f
const byte USB_MSD_STOP_START                    = 0x1b

-- Request Sense variables
var byte usb_msd_sense_response_valid
var bit*7 usb_msd_sense_response_code at usb_msd_sense_response_valid : 0 -- bits 0..6
var bit usb_msd_sense_valid at usb_msd_sense_response_code : 7 -- bit 7
--
var byte usb_msd_sense_obsolete
--
var byte usb_msd_sense_filemark_eom_ili_reserved_key
var bit usb_msd_sense_filemark  at usb_msd_sense_filemark_eom_ili_reserved_key : 7
var bit usb_msd_sense_eom       at usb_msd_sense_filemark_eom_ili_reserved_key : 6
var bit usb_msd_sense_ili       at usb_msd_sense_filemark_eom_ili_reserved_key : 5
var bit usb_msd_sense_reserved  at usb_msd_sense_filemark_eom_ili_reserved_key : 4
var bit*4 usb_msd_sense_key     at usb_msd_sense_filemark_eom_ili_reserved_key : 0
--
var dword usb_msd_sense_information
var byte _usb_msd_sense_information[4] at usb_msd_sense_information
--
var byte usb_msd_sense_add_sense_len
--
var dword usb_msd_sense_command_spacific
var byte _usb_msd_sense_command_spacific[4] at usb_msd_sense_command_spacific
--
var byte usb_msd_sense_asc
var byte usb_msd_sense_ascq
var byte usb_msd_sense_fruc
var byte usb_msd_sense_key_specific[3]
var bit usb_msd_sense_key_specific_sksv at usb_msd_sense_key_specific[0] : 7

-- sense codes
const byte USB_MSD_SENSE_NOT_READY                        = 0x02
const byte USB_MSD_SENSE_MEDIUM_ERROR                     = 0x03
const byte USB_MSD_SENSE_ILLEGAL_REQUEST                  = 0x05
const byte USB_MSD_SENSE_UNIT_ATTENTION                   = 0x06
const byte USB_MSD_SENSE_ASC_LOGICAL_BLOCK_OUT_OF_RANGE   = 0x21
const byte USB_MSD_SENSE_ASCQ_LOGICAL_BLOCK_OUT_OF_RANGE  = 0x00
const byte USB_MSD_SENSE_ASC_MEDIUM_NOT_PRESENT           = 0x3A
const byte USB_MSD_SENSE_ASCQ_MEDIUM_NOT_PRESENT          = 0x00
const byte USB_MSD_SENSE_ASC_DEVICE_WRITE_FAULT           = 0x03
const byte USB_MSD_SENSE_ASCQ_DEVICE_WRITE_FAULT          = 0x00
const byte USB_MSD_SENSE_ASC_READ_ERROR                   = 0x11
const byte USB_MSD_SENSE_ASCQ_READ_ERROR                  = 0x00
const byte USB_MSD_SENSE_ASC_WRITE_PROTECTED              = 0x27
const byte USB_MSD_SENSE_ASCQ_WRITE_PROTECTED             = 0x00
const byte USB_MSD_SENSE_ASC_INVALID_COMMAND_OPCODE       = 0x20
const byte USB_MSD_SENSE_ASCQ_INVALID_COMMAND_OPCODE      = 0x00
;const byte ASC_LOGICAL_UNIT_NOT_SUPPORTED = 0x25
;const byte ASCQ_LOGICAL_UNIT_NOT_SUPPORTED = 0x00
;const byte ASC_LOGICAL_UNIT_DOES_NOT_RESPOND = 0x05
;const byte ASCQ_LOGICAL_UNIT_DOES_NOT_RESPOND = 0x00
;const byte ASC_MEDIUM_NOT_PRESENT = 0x3a
;const byte ASCQ_MEDIUM_NOT_PRESENT = 0x00
;const byte ASC_LOGICAL_UNIT_NOT_READY_CAUSE_NOT_REPORTABLE = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_CAUSE_NOT_REPORTABLE = 0x00
;const byte ASC_LOGICAL_UNIT_IN_PROCESS = 0x04
;const byte ASCQ_LOGICAL_UNIT_IN_PROCESS = 0x01
;const byte ASC_LOGICAL_UNIT_NOT_READY_INIT_REQD = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_INIT_REQD = 0x02
;const byte ASC_LOGICAL_UNIT_NOT_READY_INTERVENTION_REQD = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_INTERVENTION_REQD = 0x03
;const byte ASC_LOGICAL_UNIT_NOT_READY_FORMATTING = 0x04
;const byte ASCQ_LOGICAL_UNIT_NOT_READY_FORMATTING = 0x04
;const byte ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE = 0x21
;const byte ASCQ_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE = 0x00
;const byte ASC_WRITE_PROTECTED = 0x27

-------------------------------------------------------------------------
-- Setup USB endpoints, endpoint 0 and 1 are required for a MSD class
-------------------------------------------------------------------------
const bit USB_EP0 = ENABLED
const byte USB_EP0_OUT_SIZE = 64
const word USB_EP0_OUT_ADDR = (USB_BASE_ADDRESS + 0x0010)
const byte USB_EP0_IN_SIZE  = 64
const word USB_EP0_IN_ADDR  = (USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )

const bit USB_EP1 = ENABLED
const byte USB_EP1_OUT_SIZE = 64
const word USB_EP1_OUT_ADDR = (USB_EP0_IN_ADDR + USB_EP0_IN_SIZE)
const byte USB_EP1_IN_SIZE  = 64
const word USB_EP1_IN_ADDR  = (0x0500)

const bit USB_EP2 = DISABLED
const bit USB_EP3 = DISABLED

var volatile byte msd_tx_test_buffer[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR	
var volatile byte msd_tx_buffer[USB_EP1_IN_SIZE]; at USB_EP1_IN_ADDR
;alias msd_tx_buffer is msd_tx_test_buffer

var volatile byte usb_ep1in_buf[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR
var volatile byte usb_ep1out_buf[USB_EP1_OUT_SIZE] at USB_EP1_OUT_ADDR
;var byte msd_tx_buffer[ USB_MSD_OUT_SIZE ]

-- fix some memory space so varibles don't get overwritten. needs a perminant fix
var byte usb_msd_temp at 0x400 + 255
var volatile byte reserve_array[0x10] at 0x400 + 256
usb_msd_temp = reserve_array[0]

-- ---------------------------------------------------------------------
-- Default USB_DEVICE_DESCRIPTOR
-- -----------------------------------------------------------------------
const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] =
{
0x12, -- Size of this descriptor in bytes
0x01, -- Descriptor Type - DEVICE
0x00,
0x02, -- USB Specification Release Number - BCD 2.00
0x00, -- Class is specified in the interface level
0x00, -- Subclass is specified at interface level
0x00, -- Protocol isspecified at interface level
0x40, -- Maximum packet size for endpoint zero - 64
0xD8,
0x04, -- Vendor ID - Assigned by the USB-IF - Microchip Technology
0x09,
0x01, -- Product ID - assigned by vendor
0x00,
0x01, -- Device release number in BCD - assigned by vendor 1.00
0x01, -- Index of string descriptor describing the manufacturer
0x02, -- Index of string descriptor describing this product
0x03, -- Index of string descriptor describing the device.s serial number
0x01  -- Number of possible configurations
}

-- -----------------------------------------------------------------------
-- Default USB_CONFIGURATION_DESCRIPTOR
-- -----------------------------------------------------------------------
const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x07 + 0x07
const byte USB_CONFIGURATION_DESCRIPTOR[USB_CONFIGURATION_DESCRIPTOR_SIZE] =
{
--  Configuration Descriptor
0x09, -- Descriptor size in bytes
0x02, -- Descriptor type - CONFIGURATION
0x20,
0x00, -- Total length of data returned for this configuration
0x01, -- Number of interfaces supported by this configuration
0x01, -- Value to use as an argument to the SetConfiguration() request to select this configuration
0x00, -- Index of string descriptor describing this configuration. 0 = none
0xC0, -- Configuration characteristics. Self-powered with no remote wakeup
0x32, -- Maximum power consumption - 100mA

-- Bulk-Only Data Interface Descriptor
0x09, -- Descriptor size in bytes
0x04, -- Descriptor type - INTERFACE
0x00, -- Number of interface
0x00, -- Value used to select alternate setting for the interface identified in the prior field
0x02, -- Number of endpoints used by this interface (excluding endpoint zero)
0x08, -- Class code - Mass Storage
0x06, -- Subclass code - SCSI Transparent Command Set
0x50, -- Protocol - BULK-ONLY TRANSPORT
0x00, -- Index to string descriptor describing this interface - none

-- Endpoint Descriptor (ENDPOINT 1 IN)
0x07, -- Descriptor size in bytes
0x05, -- Descriptor type - ENDPOINT
0x81, -- The address of this endpoint on the USB device (bit 3..0 = endpoint number 1) (bit 7 = 1 = in)
0x02, -- Transfer type - Bulk
0x40,
0x00, -- Maximum packet size - 64
0x00, -- Does not apply to Bulk endpoints

-- Endpoint Descriptor (ENDPOINT 1 OUT)
0x07, -- Descriptor size in bytes
0x05, -- Descriptor type - ENDPOINT
0x01, -- The address of this endpoint on the USB device (bit 3..0 = endpoint number 1) (bit 7 = 0 = out)
0x02, -- Transfer type - Bulk
0x40,
0x00, -- Maximum packet size - 64
0x00  -- Does not apply to Bulk endpoints
}


-- STRING 0
const byte USB_STRING0[] =
{
0x04,            -- Descriptor size in bytes
USB_DT_STRING,   -- Descriptor type - STRING
0x09,            -- wLANGID[0] (low byte)
0x04             -- wLANGID[0] (high byte)
}

-- String descriptor describing the manufacturer
const byte USB_STRING1_SIZE = 0x34
const byte USB_STRING1[USB_STRING1_SIZE] =
{
USB_STRING1_SIZE, -- Descriptor size in bytes
USB_DT_STRING,    -- Descriptor type - STRING
"M", 0x00,
"i", 0x00,
"c", 0x00,
"r", 0x00,
"o", 0x00,
"c", 0x00,
"h", 0x00,
"i", 0x00,
"p", 0x00,
" ", 0x00,
"T", 0x00,
"e", 0x00,
"c", 0x00,
"h", 0x00,
"n", 0x00,
"o", 0x00,
"l", 0x00,
"o", 0x00,
"g", 0x00,
"y", 0x00,
" ", 0x00,
"I", 0x00,
"n", 0x00,
"c", 0x00,
".", 0x00
}

-- String descriptor describing this product
const byte USB_STRING2_SIZE = 0x34
const byte USB_STRING2[USB_STRING2_SIZE] =
{
USB_STRING2_SIZE, -- Descriptor size in bytes
USB_DT_STRING,    -- bDescriptorType - STRING
"J", 0x00,
"a", 0x00,
"l", 0x00,
"l", 0x00,
"i", 0x00,
"b", 0x00,
" ", 0x00,
"M", 0x00,
"a", 0x00,
"s", 0x00,
"s", 0x00,
" ", 0x00,
"S", 0x00,
"t", 0x00,
"o", 0x00,
"r", 0x00,
"a", 0x00,
"g", 0x00,
"e", 0x00,
" ", 0x00,
"D", 0x00,
"r", 0x00,
"i", 0x00,
"v", 0x00,
"e", 0x00
}

-- String descriptor describing the device serial number
const byte USB_STRING3_SIZE = 0x1A
const byte USB_STRING3[USB_STRING3_SIZE] =
{
USB_STRING3_SIZE,            -- Descriptor size in bytes
USB_DT_STRING,   -- Descriptor type - STRING
"0", 0x00,
"2", 0x00,
"3", 0x00,
"4", 0x00,
"5", 0x00,
"6", 0x00,
"7", 0x00,
"8", 0x00,
"9", 0x00,
"A", 0x00,
"B", 0x00,
"C", 0x00
}

include usb_drv_core

-- DELAY must be checked -----------------------------------------------------------------------
procedure msd_wait_own_tx() is
   pragma inline
   var byte delay = 0
   while usb_msd_sae_owns_bit_in loop -- while host owns
      debug_char(0,"*")

      _usec_delay(10)    -- not sure why this is needed, I would prefer to remove it.

      -- exit on timeout
      delay = delay + 1
      if delay == 255 then
         exit loop
      end if

   end loop
end procedure

procedure msd_wait_own_rx() is
   pragma inline
   var byte delay = 0
   while usb_msd_sae_owns_bit_out loop -- while host owns
      debug_char(0,"/")

      -- exit on timeout
      delay = delay + 1
      if delay == 255 then
         exit loop
      end if

   end loop
end procedure


-- -----------------------------------------------------------------------
-- reset sense data. used for request sense command to
-- report our status
-- -----------------------------------------------------------------------
procedure usb_msd_reset_sense_data() is
   usb_msd_sense_response_valid       = 0x70
;   usb_msd_sense_response_code        = 0x70
;   usb_msd_sense_valid                = 0

   usb_msd_sense_obsolete             = 0

   usb_msd_sense_filemark_eom_ili_reserved_key = 0
   ;usb_msd_sense_key                  = 0
   ;usb_msd_sense_reserved             = 0
   ;usb_msd_sense_ili                  = 0
   ;usb_msd_sense_eom                  = 0
   ;usb_msd_sense_filemark             = 0

   usb_msd_sense_information          = 0
   usb_msd_sense_add_sense_len        = 0x0A
   usb_msd_sense_command_spacific     = 0
   usb_msd_sense_asc                  = 0
   usb_msd_sense_ascq                 = 0
   usb_msd_sense_fruc                 = 0  -- field replaceable unit code
   usb_msd_sense_key_specific[0] = 0 -- LSB
   usb_msd_sense_key_specific[1] = 0
   usb_msd_sense_key_specific[2] = 0
   ;usb_msd_sense_key_specific_sksv = 0 -- located at usb_msd_sense_key_specific[0] : 7 (already set)
end procedure

-- -----------------------------------------------------------------------
-- init procedure
-- -----------------------------------------------------------------------
procedure usb_msd_init() is
   INTCON_GIE = FALSE -- no interrupts.

   usb_msd_reset_sense_data() -- reset sense data on startup
end procedure

-- -----------------------------------------------------------------------
-- Reset Callback. Must add the following lines to USB_DRV reset procedure
--   if defined (usb_reset_callback) then
--	     usb_reset_callback()
--   end if
--
-- with good code, you should not receive any resets from USB. You
-- will get a reset if you are slow to respond to a command
-- -----------------------------------------------------------------------
procedure usb_reset_callback() is
   -- release EP OUT uown to SIE to allow more data to arrive.
   usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

   -- no data left to send
   usb_msd_data_residue = 0

   -- wait for a command
   usb_msd_state = USB_MSD_STATE_WAIT

   const byte reset[] = "!!!RESET!!!"
   debug_string(0,reset)
   debug_crlf(0)
end procedure	

-- -----------------------------------------------------------------------
-- Check if the CBW received is valid.
-- -----------------------------------------------------------------------
function msd_cbw_is_valid() return bit is
   pragma inline
   var byte step

   -- check if we indeed got a CBW from the host
   _usb_msd_cbw_signature[0] = POSTINC1
   _usb_msd_cbw_signature[1] = POSTINC1
   _usb_msd_cbw_signature[2] = POSTINC1
   _usb_msd_cbw_signature[3] = POSTINC1

   if usb_msd_cbw_signature == USB_MSD_CBW then
;   if (_usb_msd_cbw_signature[0] == POSTINC1) & (_usb_msd_cbw_signature[1] == POSTINC1) &
;      (_usb_msd_cbw_signature[2] == POSTINC1) & (_usb_msd_cbw_signature[3] == POSTINC1) then

      debug_char(0,"B")

      debug_crlf(1)
      const byte cbw_str[] = "CBW RECEIVED FROM HOST!"
      debug_string(1,cbw_str)
      debug_crlf(1)

      const byte cbw_str1[] = "usb_msd_cbw_signature: "
      debug_string(1,cbw_str1)
      debug_dword_hex(1, usb_msd_cbw_signature)
      debug_crlf(1)

      _usb_msd_cbw_tag[0] = POSTINC1
      _usb_msd_cbw_tag[1] = POSTINC1
      _usb_msd_cbw_tag[2] = POSTINC1
      _usb_msd_cbw_tag[3] = POSTINC1

      const byte cbw_str2[] = "usb_msd_cbw_tag: "
      debug_string(1,cbw_str2)
      debug_dword_hex(1, usb_msd_cbw_tag)
      debug_crlf(1)

   	_usb_msd_cbw_data_transfer_length[0] = POSTINC1
   	_usb_msd_cbw_data_transfer_length[1] = POSTINC1
   	_usb_msd_cbw_data_transfer_length[2] = POSTINC1
   	_usb_msd_cbw_data_transfer_length[3] = POSTINC1

      usb_msd_cbw_flags = POSTINC1

      const byte cbw_str4[] = "usb_msd_cbw_flags: "
      debug_string(1,cbw_str4)
      debug_dword_dec(1, usb_msd_cbw_flags)
      debug_crlf(1)

      if usb_host_direction == USB_HOST_DIRECTION_RECEIVE then
         const byte host_expects_to_receive1[] = "Host Waiting To Receive: "
         debug_string(1,host_expects_to_receive1)
      else
         const byte host_expects_to_receive2[] = "Host Waiting To Send: "
         debug_string(1,host_expects_to_receive2)
      end if
      debug_dword_dec(1, usb_msd_cbw_data_transfer_length)
      const byte bytes_string[] = " Bytes"
      debug_string(1,bytes_string)
      debug_crlf(1)

      usb_msd_cbw_cbw_lun = POSTINC1

      const byte cbw_str5[] = "usb_msd_cbw_cbw_lun: "
      debug_string(1,cbw_str5)
      debug_dword_dec(1, usb_msd_cbw_cbw_lun)
      debug_crlf(1)

      usb_msd_cbw_length = POSTINC1

      const byte cbw_str6[] = "usb_msd_cbw_length: "
      debug_string(1,cbw_str6)
      debug_dword_dec(1, usb_msd_cbw_length)
      debug_crlf(1)

      -- get the command
      const byte cbw_str8[] = "CBWCB (command block): "
      debug_string(1,cbw_str8)

      for 16 using step loop
         _usb_msd_cbw_command[step] = POSTINC1
         debug_byte_hex(1, _usb_msd_cbw_command[step])
         debug_char(1," ")
      end loop
      debug_crlf(1)

      return 1
   else
      return 0

      print_crlf(serial_data)
      const byte str1[] = "***BAD CBW***"
      print_string(serial_data, str1)

   end if
end function

-- -----------------------------------------------------------------------
-- Do whatever needs to be done with a command received.
-- -----------------------------------------------------------------------
procedure usb_msd_command_received() is
   debug_char(0,"C")

   var byte step

   if _usb_msd_cbw_command[0] == USB_MSD_INQUIRY then
      debug_char(0,"I")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_INQUIRY"
      debug_string(2,command)
      debug_crlf(2)

      const byte usb_msd_inq[36] = {
   	0x00,	-- Peripheral Device Type
   	0x80, -- set removable media bit
   	0x04,	-- ISO version SPC-2
   	0x02,	-- Response Data Format SPC-2
   	0x1F,	-- Additional Length
   	0x00,	-- reserved
   	0x00,	-- bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
   		-- but as in case of other device, we are just using 00
   	0x00,	-- 00 obsolete, 0x80 for basic task queueing
   	"J","a","l","l","i","b"," "," ", 	-- Vendor Identification
   	"M","a","s","s"," ","S","t","o","r","a","g","e"," "," "," "," ", -- Product Identification
   	"0","0","0","1"} -- Product Revision

      -- set the data to send
      for count(usb_msd_inq) using step loop
         msd_tx_buffer[step] = usb_msd_inq[step]
      end loop

      usb_msd_data_residue = count(usb_msd_inq) -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- command success
      usb_msd_state = USB_MSD_STATE_DATA_IN           -- send data to host

   elsif _usb_msd_cbw_command[0] == USB_MSD_READ_FORMAT_CAPACITY then
      debug_char(0,"P")

      -- send capacities device can be formatted in.

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_FORMAT_CAPACITY"
      debug_string(2,command)
      debug_crlf(2)

      -- constants
      const byte UNFORMATTED_MEDIA     = 0b01
      const byte FORMATTED_MEDIA       = 0b10
      const byte NO_CARTRIDGE_IN_DRIVE = 0b11

      -- Capacity List Header
      msd_tx_buffer[0] = 0x00
      msd_tx_buffer[1] = 0x00
      msd_tx_buffer[2] = 0x00
      msd_tx_buffer[3] = 0x08	-- (8 bytes) x (1 descriptor)   	
      -- Current/Maximum Capacity Descriptor
      msd_tx_buffer[4] = _usb_msd_num_of_blocks[3];0x01   -- 5000 blocks (2.56MB to ensure FAT16)
      msd_tx_buffer[5] = _usb_msd_num_of_blocks[2] ;0x00
      msd_tx_buffer[6] = _usb_msd_num_of_blocks[1] ;0x13
      msd_tx_buffer[7] = _usb_msd_num_of_blocks[0] ;0x88
      msd_tx_buffer[8] = FORMATTED_MEDIA
      msd_tx_buffer[9] = _usb_msd_block_size[2];0x00	  -- 512 bytes per block (from media's CSD register)
      msd_tx_buffer[10] = _usb_msd_block_size[1];0x02
      msd_tx_buffer[11] = _usb_msd_block_size[0];0x00

      usb_msd_data_residue = 12                       -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- command success
      usb_msd_state = USB_MSD_STATE_DATA_IN           -- waiting to send data to host


   elsif _usb_msd_cbw_command[0] == USB_MSD_READ_CAPACITY then
      debug_char(0,"P")

      -- send the size of the device (number of sectors)
      -- and also the sector size. (0x200 = 512)

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_CAPACITY"
      debug_string(2,command)
      debug_crlf(2)

      -- prepare the data response
      msd_tx_buffer[0] = _usb_msd_num_of_blocks[3];0x01 -- number of blocks	-- 5000 blocks
      msd_tx_buffer[1] = _usb_msd_num_of_blocks[2];0x00 -- number of blocks
      msd_tx_buffer[2] = _usb_msd_num_of_blocks[1];0x13 -- number of blocks
      msd_tx_buffer[3] = _usb_msd_num_of_blocks[0];0x88 -- number of blocks
      msd_tx_buffer[4] = _usb_msd_block_size[3];0x00 -- block size			-- 512 bytes per block
      msd_tx_buffer[5] = _usb_msd_block_size[2];0x00 -- block size
      msd_tx_buffer[6] = _usb_msd_block_size[1];0x02 -- block size
      msd_tx_buffer[7] = _usb_msd_block_size[0];0x00 -- block size

      usb_msd_data_residue = 8 -- amount of data left to send
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif _usb_msd_cbw_command[0] == USB_MSD_READ_10 then
      debug_char(0,"R")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_10"
      debug_string(2,command)
      debug_crlf(2)

      var dword address
      var byte _address[4] at address
      _address[0] = _usb_msd_cbw_command[5]
      _address[1] = _usb_msd_cbw_command[4]
      _address[2] = _usb_msd_cbw_command[3]
      _address[3] = _usb_msd_cbw_command[2]

      var dword sector_step = 0

      for usb_msd_cbw_data_transfer_length / 512 loop
         storage_raw_read_sector_address(address + sector_step)

         sector_step = sector_step + 1

         usb_msd_data_residue = 512

         while usb_msd_data_residue != 0 loop

            _usb_msd_step64 = 0
            for 8 loop

               --  read data from drive buffer in 64 byte chunks and place it
               --  into the usb tx buffer.   		
               var byte step2
               for 64 using step2 loop
                  ;msd_tx_buffer[step2] = 0xAA -- for testing

                  msd_tx_buffer[step2] = storage_sector_buffer[_usb_msd_step64 + word(step2)]
                  ;-- possible compiler bug with:
                  ;msd_tx_buffer[step2] = storage_sector_buffer[_usb_msd_step64 + step2]

               end loop


               _usb_msd_step64 = _usb_msd_step64 + 64

               -- success if all data was read from the data device ok.
               usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS

               usb_msd_process_data()
            end loop
         end loop
      end loop

      usb_msd_data_residue = 0 -- done sending all data
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

      debug_char(0,"#")	

;         -- no point  in having (USB_MSD_SECTOR_READS == FALSE)
;         -- unless i enable this for writes
;
;         --  decode CBWCB to get LBA address and size to read from storage medium
;         --  then reads data in 512 byte chunks to be sent in 64 byte
;         --  chunks to host.
;
;         if USB_MSD_SECTOR_READS == TRUE then
;         elsif USB_MSD_SECTOR_READS == FALSE then -- Sector Reads
;            debug_crlf(2)
;            var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_READ_10"
;            debug_string(2,command)
;            debug_crlf(2)
;
;            usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host
;
;            var dword address
;            var byte _address[4] at address
;            _address[0] = _usb_msd_cbw_command[5]
;            _address[1] = _usb_msd_cbw_command[4]
;            _address[2] = _usb_msd_cbw_command[3]
;            _address[3] = _usb_msd_cbw_command[2]
;
;            var word step = 0
;            var dword sector_step = 0
;
;            for usb_msd_cbw_data_transfer_length / 512 loop
;               storage_start_read(address + sector_step)
;               sector_step = sector_step + 1
;
;               usb_msd_data_residue = 512
;
;               while usb_msd_data_residue != 0 loop
;
;                  for 8 loop
;                     debug_crlf(0)
;                     debug_string(0,command)
;
;                    --  read data from drive buffer in 64 byte chunks and place it
;                     --  into the usb tx buffer.   		
;                     var byte step2
;                     for 64 using step2 loop
;                        ;msd_tx_buffer[step2] = 0xAA
;                        msd_tx_buffer[step2] = storage_raw_data_byte
;                     end loop
;
;                     -- success if all data was read from the data device ok.
;                     usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
;
;                     usb_msd_process_data()
;
;                  end loop
;
;               end loop
;               usb_msd_data_residue = 0 -- done sending all data
;               storage_stop_read() -- stop reading if already reading
;            end loop
;      end if

   elsif _usb_msd_cbw_command[0] == USB_MSD_WRITE_10 then		
      -- decode CBWCB to get LBA address and size to write to sd card
      -- then reads in 64 byte chunks from host to be written to the sd
      -- card in 512 byte chunks via out callback.

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_WRITE_10"
      debug_string(2,command)
      debug_crlf(2)

      debug_char(0,"X")

      _usb_msd_address[0] = _usb_msd_cbw_command[5]
      _usb_msd_address[1] = _usb_msd_cbw_command[4]
      _usb_msd_address[2] = _usb_msd_cbw_command[3]
      _usb_msd_address[3] = _usb_msd_cbw_command[2]

      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_cbw_data_transfer_length)
      debug_char(0,")")


      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_address)
      debug_char(0,")")


      debug_char(0,"(")
      debug_dword_dec(0, usb_msd_data_residue)
      debug_char(0,")")


      ;if (usb_msd_address == 0) then -- don't write to boot sector (when testing writes) -----------------------------------------------------------------------
      ;   usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      ;   usb_msd_data_residue = 0 -- done getting all data
      ;   usb_msd_state = USB_MSD_STATE_DATA_IN
      ;else
         _usb_msd_sector_step = 0
         _usb_msd_step64 = 0
         -- release EP OUT uown to SIE to allow data to arrive.
         usb_prime_epx_out(1,USB_EP1_OUT_SIZE)
      ;end if

      -- see out callback for what next write steps.

      debug_char(0,"W")
      debug_char(0,"R")

   elsif _usb_msd_cbw_command[0] == USB_MSD_REQUEST_SENSE then	
      debug_char(0,"S")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_REQUEST_SENSE"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_sense_valid = 0
      msd_tx_buffer[0] = usb_msd_sense_response_valid
      msd_tx_buffer[1] = usb_msd_sense_obsolete

      ;usb_msd_sense_filemark =
      ;usb_msd_sense_eom =
      ;usb_msd_sense_ili =
      ;usb_msd_sense_reserved =
      ;usb_msd_sense_key =
      msd_tx_buffer[2] = usb_msd_sense_filemark_eom_ili_reserved_key

      msd_tx_buffer[3] = _usb_msd_sense_information[0]
      msd_tx_buffer[4] = _usb_msd_sense_information[1]
      msd_tx_buffer[5] = _usb_msd_sense_information[2]
      msd_tx_buffer[6] = _usb_msd_sense_information[3]

      msd_tx_buffer[7] = usb_msd_sense_add_sense_len

      msd_tx_buffer[8] = _usb_msd_sense_command_spacific[0]
      msd_tx_buffer[9] = _usb_msd_sense_command_spacific[1]
      msd_tx_buffer[10] = _usb_msd_sense_command_spacific[2]
      msd_tx_buffer[11] = _usb_msd_sense_command_spacific[3]

      msd_tx_buffer[12] = usb_msd_sense_asc
      msd_tx_buffer[13] = usb_msd_sense_ascq
      msd_tx_buffer[14] = usb_msd_sense_fruc
      msd_tx_buffer[15] = usb_msd_sense_key_specific[0]
      msd_tx_buffer[16] = usb_msd_sense_key_specific[1]
      msd_tx_buffer[17] = usb_msd_sense_key_specific[2]

      usb_msd_data_residue = 18	-- size of this response
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif _usb_msd_cbw_command[0] == USB_MSD_MODE_SENSE then	
      debug_char(0,"M")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_MODE_SENSE"
      debug_string(2,command)
      debug_crlf(2)
	
   	msd_tx_buffer[0] = 0x03
   	msd_tx_buffer[1] = 0x00
   	msd_tx_buffer[2] = 0x00
   	msd_tx_buffer[3] = 0x00

      usb_msd_data_residue = 4	
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS -- waiting to send data to host
      usb_msd_state = USB_MSD_STATE_DATA_IN
    	
   elsif _usb_msd_cbw_command[0] == USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL then
      debug_char(0,"A")

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_PREVENT_ALLOW_MEDIUM_REMOVAL"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      usb_msd_sense_key = USB_MSD_SENSE_NOT_READY
      usb_msd_data_residue = 0
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif _usb_msd_cbw_command[0] == USB_MSD_TEST_UNIT_READY then
      debug_char(0,"U")
      -- only send back csw with sucess or failure depending
      -- on state of the storage device

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_TEST_UNIT_READY"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_reset_sense_data()

      const byte MEDIA_READY = TRUE

      if MEDIA_READY == TRUE then
         usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      else
         ;gblSenseData_SenseKey = S_UNIT_ATTENTION;
         ;gblSenseData_ASC = ASC_MEDIUM_NOT_PRESENT;
         ;gblSenseData_ASCQ = ASCQ_MEDIUM_NOT_PRESENT;

         usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      end if

      usb_msd_data_residue = 0	           -- no data to send, only csw
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host

   elsif _usb_msd_cbw_command[0] == USB_MSD_VERIFY then
      debug_char(0,"V")
      -- just reply success with csw, for media ok

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_VERIFY"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_data_residue = 0	           -- no data to send, only csw
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN -- waiting to send data to host
      	 		
   elsif _usb_msd_cbw_command[0] == USB_MSD_STOP_START then
      debug_char(0,"S")
      -- just reply success with csw

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - USB_MSD_STOP_START"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_data_residue = 0	            -- no data to send, only csw
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      usb_msd_state = USB_MSD_STATE_DATA_IN  -- waiting to send data to host
   else
      debug_char(0,"D")
      -- Hey! I don't know that command!

      debug_crlf(2)
      var byte command[] = "MSD COMMAND RECEIVED - DON'T KNOW THIS COMMAND!"
      debug_string(2,command)
      debug_crlf(2)

      usb_msd_reset_sense_data()
      usb_msd_sense_key = USB_MSD_SENSE_ILLEGAL_REQUEST
      usb_msd_sense_asc = USB_MSD_SENSE_ASC_INVALID_COMMAND_OPCODE
      usb_msd_sense_ascq = USB_MSD_SENSE_ASCQ_INVALID_COMMAND_OPCODE
      usb_msd_csw_status = USB_MSD_CSW_STATUS_FAIL
      usb_msd_data_residue = 0x00	
      usb_msd_state = USB_MSD_STATE_DATA_IN	
   end if

end procedure


-- -----------------------------------------------------------------------
-- Handeles data going out from PIC and into the host.
-- -----------------------------------------------------------------------
procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline

   -- report that data is going into the host
   -- and which endpoint
   if debug_lvl_1 == TRUE then
      debug_crlf(1)
      const byte str[] = "--- EP data in: "
      debug_string(1,str)
      debug_byte_dec(1,byte_count)
      const byte str2[] = " bytes, on endpoint "
      debug_string(1,str2)
      debug_byte_dec(1, end_point )
      debug_crlf(1)
      const byte str3[] = " MSD STATE: "
      debug_string(1,str3)
      debug_byte_dec(1,usb_msd_state)
      debug_crlf(1)
   end if

   if debug_lvl_2 == TRUE then
      -- send data to the serial port for debugging
      -- not really needed since USB libs also have this debugging.
      var byte step
      for byte_count using step loop
         debug_byte_hex(1,msd_tx_buffer[step])
         debug_char(1," ")
      end loop
   end if

   debug_crlf(2) -- crlf
end procedure

-- -----------------------------------------------------------------------
-- Handeles data going out of host to the PIC.
-- -----------------------------------------------------------------------
procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline

   debug_char(0,"Z")

   -- We received data on endpoint 1.
   if (end_point == 1) then

      -- report that data is comming from the host
      -- and which endpoint
      if debug_lvl_1 == TRUE then
         print_crlf(serial_data)
         const byte str[] = "--- EP data out: "
         print_string(serial_data,str)
         print_byte_dec(serial_data,byte_count)
         const byte str2[] = " bytes, on endpoint "
         print_string(serial_data,str2)
         print_byte_dec(serial_data, end_point )

         const byte str3[] = " MSD STATE: "
         print_string(serial_data,str3)
         print_byte_dec(serial_data, usb_msd_state)
      end if

      -- set buffer pointer to next data address
      var byte src_ptr[2] AT buffer_addr
      FSR1L = src_ptr[0]
      FSR1H = src_ptr[1]

      if (usb_msd_state == USB_MSD_STATE_DATA_OUT) then
         debug_char(0,"O")

         -- write data to sector buffer
         for 64 using _usb_msd_step_byte loop
            storage_sector_buffer[_usb_msd_step64 + word(_usb_msd_step_byte)] = POSTINC1
         end loop

         _usb_msd_step64 = _usb_msd_step64 + 64

         -- allow host to send more if it wants to while we write to the
         -- storage device
         usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

         if _usb_msd_step64 == 512 then

            -- write sector buffer to storage device
            storage_raw_write_sector_address(usb_msd_address + _usb_msd_sector_step)

            _usb_msd_sector_step = _usb_msd_sector_step + 1
            usb_msd_cbw_data_transfer_length = usb_msd_cbw_data_transfer_length - 512
            _usb_msd_step64 = 0

            -- we're done!
            -- note: if the host has not sent all the data we expected,
            -- a reset will occur and we will be out of here anyways.
            if usb_msd_cbw_data_transfer_length == 0 then
               -- time to send CSW
               usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
               usb_msd_state = USB_MSD_STATE_DATA_IN
               usb_msd_data_residue = 0
               debug_char(0,"N")
            end if
         end if

      elsif  (usb_msd_state == USB_MSD_STATE_WAIT) then

         -- check if CBW is good.
         -- CBW hold a command and command parameters that comes from the host.
         if msd_cbw_is_valid() then -- check if CBW is ok

            -- check if host wants to send or receive data.
            if usb_host_direction == USB_HOST_DIRECTION_SEND then -- host is waiting to send data
               -- prepare to get data from host
               usb_msd_state = USB_MSD_STATE_DATA_OUT
            elsif usb_host_direction == USB_HOST_DIRECTION_RECEIVE then -- host is waiting to get data
               -- prepare to send data to host
               usb_msd_state = USB_MSD_STATE_DATA_IN
            end if

            const byte str3[] = " STATE: "
            debug_string(1,str3)
            debug_byte_dec(1, usb_msd_state)

            -- Do what we gotta do with the command received.
            usb_msd_command_received()

         else
            debug_char(0,"!")
            usb_prime_epx_out(1,USB_EP1_OUT_SIZE)
         end if

      end if

   else
      usb_prime_epx_out(0,USB_EP1_OUT_SIZE) -- do we need this?
   end if
end procedure

include usb_drv

-- -----------------------------------------------------------------------
-- send data to the host
-- -----------------------------------------------------------------------
procedure msd_send_data(byte in size, bit in do_copy, bit in wait_own) is
   pragma inline

   debug_char(0,"*")

	FSR1L = byte(USB_EP1_IN_ADDR)
	FSR1H = byte(USB_EP1_IN_ADDR >> 8)

   -- note: I don't like blocking loops!
   -- does usb_send_data do this?
   if wait_own == TRUE then
      msd_wait_own_tx()
   end if

   debug_char(0,"*")


   if do_copy == TRUE then
      -- send the array of data (msd_tx_buffer). It will be sent next time
      -- usb_handle_isr() -> usb_ep_data_in_callback are called.

      ;-- copy the array to the bulk endpoiint (endpoint 1)
      ;var byte index
   	;for size using index loop
   ;		msd_tx_test_buffer[index] = msd_tx_buffer[index]
   ;	end loop
   	
      -- copy the array to the bulk endpoiint (endpoint 1)
      var byte index
   	for size using index loop
   		POSTINC1 = msd_tx_buffer[index]
   	end loop
   end if

   -- send the data
	usb_bd1in_addr = USB_EP1_IN_ADDR
	
	usb_bd1in_cnt = size
	var volatile bit dts_bit at usb_bd1in_stat : USB_BDSTATUS_DTS

	if (dts_bit) then
		usb_bd1in_stat = 0b_1000_1000
	else
		usb_bd1in_stat = 0b_1100_1000
	end if

end procedure

-- -----------------------------------------------------------------------
-- send command status wrapper.
-- basically sends the status of a command that
-- was completed by the PIC.
-- -----------------------------------------------------------------------
procedure usb_send_csw() is

   ;msd_wait_own_tx()

   -- send csw (31 bytes)
   msd_tx_buffer[0] = 0x55
   msd_tx_buffer[1] = 0x53
   msd_tx_buffer[2] = 0x42
   msd_tx_buffer[3] = 0x53
   msd_tx_buffer[4] = _usb_msd_cbw_signature[0]
   msd_tx_buffer[5] = _usb_msd_cbw_signature[1]
   msd_tx_buffer[6] = _usb_msd_cbw_signature[2]
   msd_tx_buffer[7] = _usb_msd_cbw_signature[3]
   msd_tx_buffer[8] = _usb_msd_cbw_tag[0]
   msd_tx_buffer[9] = _usb_msd_cbw_tag[1]
   msd_tx_buffer[10] = _usb_msd_cbw_tag[2]
   msd_tx_buffer[11] = _usb_msd_cbw_tag[3]
   msd_tx_buffer[12] = usb_msd_csw_status

   -- send the CBW.
   msd_send_data(13,1,1)
   ;usb_send_data(1, msd_tx_buffer, 13 , low)

   -- the command is completed, wait for the next command.
   usb_msd_state = USB_MSD_STATE_WAIT
	
   ;usb_handle_isr()

   -- release EP OUT uown to SIE to allow more data to arrive.
   usb_prime_epx_out(1,USB_EP1_OUT_SIZE)

   debug_char(0,"W")
end procedure

-- -----------------------------------------------------------------------
-- set the amount of data to be sent to the host through msd_send_data
-- and update the amount of data left to be sent.
-- -----------------------------------------------------------------------
procedure usb_msd_process_data() is
   debug_char(0,"E")

   -- if there is more the 64 bytes to be sent (the size of the in endpoint)
   if (usb_msd_data_residue >= 64) & (usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS) then

      debug_crlf(2)
      var byte command[] = "SENDING 64 BYTES OF DATA, "
      debug_string(2,command)
      debug_dword_dec(2,usb_msd_data_residue - 64)
      var byte bytes_left[] = " BYTES LEFT!"
      debug_string(2,bytes_left)

      -- subtract 64 bytes from what is left to send.
      usb_msd_data_residue = usb_msd_data_residue - 64
      -- send 64 bytes of data
      msd_send_data(64,1,1)

   elsif usb_msd_data_residue != 0 then -- if there is less then 64 bytes to send, or if there was an error
      if usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS then
         -- wait till data has been sent

            debug_crlf(2)
            var byte command[] = "SENDING "
            debug_string(2,command)
            debug_byte_dec(1,byte(usb_msd_data_residue))
            var byte command2[] = " BYTES OF DATA!!"
            debug_string(2,command2)
            debug_crlf(2)

            -- send data that was expected by host
            ;usb_send_data(1, msd_tx_buffer, byte(usb_msd_data_residue), low )

            msd_send_data(byte(usb_msd_data_residue),1,1)
            usb_msd_data_residue = 0
      elsif usb_msd_csw_status == USB_MSD_CSW_STATUS_FAIL then
         -- if there was an error (usually during reading or writing data)
         -- at the moment, there should be no USB_MSD_CSW_STATUS_FAIL,
         -- unless we get a unsupported command.

         debug_crlf(2)
         var byte command[] = "STATUS FAIL!!"
         debug_string(2,command)
         debug_crlf(2)

         -- if the host is expecting more data
         if (usb_msd_data_residue >= 64) then   		
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for 64 using step loop
               msd_tx_buffer[step] = 0
            end loop

            -- send data
            msd_send_data(64,1,1)
            usb_msd_data_residue = usb_msd_data_residue - 64
            usb_msd_data_residue = 0
         else                                   		                  ------------------- may be more then 64 bytes to send???
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for usb_msd_data_residue using step loop
               msd_tx_buffer[step] = 0
            end loop

            -- send data
            msd_send_data(byte(usb_msd_data_residue),1,1)
            usb_msd_data_residue = 0
         end if
      end if
   end if

   -- see if there is anything else waiting
   usb_handle_isr()	
end procedure

-- -----------------------------------------------------------------------
-- Poll USB MSD for tasks
-- -----------------------------------------------------------------------
procedure usb_msd_tasks() is
   -- Servicing Hardware
   -- use polling method

   usb_handle_isr()

   -- If we have data to send to the host
   if (usb_msd_state == USB_MSD_STATE_DATA_IN) then

      -- if there is no more data to send
      ;if usb_msd_cbw_data_transfer_length == 0 then
      if usb_msd_data_residue == 0 then
         debug_crlf(2)
         debug_crlf(2)
         var byte command[] = "Sending CSW!"
         debug_string(2,command)

         -- finnished sending the data, now send the status
         usb_send_csw()

      else
         -- if there is data to send
         -- set the amount of data to be sent to the host through msd_send_data
         -- and update the amount of data left to be sent.
         usb_msd_process_data()
      end if

   elsif !usb_msd_sae_owns_bit_in & (usb_msd_state == USB_MSD_STATE_WAIT) then
      -- do nothing, we are just waiting for data
      -- it will be received through next call of usb_handle_isr()
   elsif usb_msd_state == USB_MSD_STATE_DATA_OUT then
      -- not supported yet, so lets just go to wait state??
      -- the previous command received was probobly not supported anyways,
      -- so we should never be in this state.
;usb_msd_state = USB_MSD_STATE_WAIT
   end if
end procedure

-- setup the USB device
usb_setup()

-- enable USB device
usb_enable_module()

-- -----------------------------------------------------------------------
-- check if MSD is configured
-- -----------------------------------------------------------------------
alias msd_is_configured is usb_is_configured

-- -----------------------------------------------------------------------
-- Wait till msd is configured
-- -----------------------------------------------------------------------
procedure usb_msd_wait_configured() is
   while !msd_is_configured loop
      -- poll the usb ISR function on a regular base, in order to
      -- serve the USB requests
      usb_msd_tasks()
      -- check if USB device has been configured by the HOST
      if usb_is_configured()  then
         exit loop
      end if
   end loop
end procedure


