-- Title: USB constant definitions
-- Author: Albert Faber, Copyright (c) 2008..2009, all rights reserved.
-- Adapted-by: Rob Jansen, Copyright (c) 2018..2018, all rights reserved.
-- Compiler: 2.4q6
-- Revision: $Revision$
-- 
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: Constants for configurting the USB interface
-- --
-- 
-- Sources: http://www.usb.org for USB specifications
-- 
-- Notes: 
--
-- ------------------------------------------------------
-- ------------------------------------------------------
--
--

-- Set the base address of the USB dual port memory location
-- this address actually corresponds to the location of BDT
-- (Buffer Descriptor Table). USB RAM is divided into two main
-- areas: BDT and USB data. In some PIC, USB RAM starts with BDT
-- and then is followed by USB data. But for some others (like 18FX7J53)
-- part of USB data can be located *before* BDT. For now, USB implementation
-- assumes USB RAM is structured as BDT then USB data (contiguous).
-- Strictly speaking and consequently (and as a matter of semantic), 
-- USB_BASE_ADDRESS corresponds to BDT, but as USB_BASE_ADDRESS is used in many
-- libs and samples (and user code), and since current implementation isn't able
-- to use USB data *before* BDT, we're aliasing BDT to this variable.

-- RJ: Some notes about addresses, the memory map and the buffers used
-- -------------------------------------------------------------------
-- The USB_BDT_ADDRESS can differ per PIC. Also the memory bank(s) defined for
-- use for USB are not continuous for all PICs. For example the PIC18F14K50
-- has 256 bytes of continuous USB memory from 0x200 - 0x2ff but the PIC16F1455
-- has 512 bytes of USB memory starting at linear address 0x2000 but since we can
-- only used banked addressing starting at 0x020, buffers sizes are limited to
-- 80 bytes for these PICs.
-- In the USB driver the following USB buffers with sizes are used:
-- *) usb_bd_array[80]. This buffer holds all buffer descriptions. This driver
--    only uses 8 (4 in and 4 out) buffer descriptions of 4 bytes so only 32
--    bytes are actually used.
-- *) usb_sdp_buffer[8]. Some general purpose USB buffer.
-- *) usb_epxout_buf[8] and usb_epxin_buf[8] where x = 0..3. These are the
--    end point buffers. The number of buffers used depend on the type of USB
--    device. The maximum currently in use are 4 (0..3) endpoint buffers so in
--    total 64 bytes.
-- *) usb_delivery_buffer[80]. This buffer should be capable of holding a complete
--    device descriptor which is at most of 67 bytes
-- For the PIC16F1454/55/59 we use the banks with the following addresses:
-- *) usb_bd_array        starting at USB_BASE_ADDRESS + 0x0000  (first bank)
-- *) usb_sdp_buffer      starting at USB_BASE_ADDRESS + 0x0020  (first bank)
-- *) usb_epxoutbuf       starting at USB_BASE_ADDRESS + 0x0080  (second bank)
-- *) usb_delivery_buffer starting at USB_BASE_ADDRESS + 0x0100  (third bank)
-- For the PIC18F14K50 we do not use use banks but the following addresses:
-- *) usb_bd_array        starting at USB_BASE_ADDRESS + 0x0000
-- *) usb_sdp_buffer      starting at USB_BASE_ADDRESS + 0x00f8
-- *) usb_epxoutbuf       starting at USB_BASE_ADDRESS + 0x0020
-- *) usb_delivery_buffer starting at USB_BASE_ADDRESS + 0x0078
-- Since arrays are declared at a certain address we must make sure that all
-- used memory locations are reserved so that the compiler knows they are used.
-- Because of this a dummy buffer usb_bd_endpt[80] is also declared which
-- reserves the required space for the usb_epxoutbuf and usb_epxinbuf.

if defined(USB_BDT_ADDRESS) == false then
   _error "This PIC has no declared USB_BDT_ADDRESS constant, is it really a USB capable PIC ? If so, please report !"
   -- need to define constant anyway to error is reported at proper compilation state
   -- TODO: looks like a bug in compiler ?
   const byte USB_BDT_ADDRESS = 0
end if

-- for PICs with PIE3/PIR3 and not PIE2/PIR2
if !defined(pie2_usbie) then
   alias pie2_usbie is pie3_usbie
   alias pir2_usbif is pir3_usbif
end if

-- Addresses are based on USB_BDT_ADDRESS, which may differ per PIC device.
-- Used in this driver are 0x0020 for PIC16F1454/55/59 and 0x0200 for PIC18F14K50
-- as defined in the device file of these PICs.
alias USB_BASE_ADDRESS is USB_BDT_ADDRESS


if (USB_BDT_ADDRESS  == 0x0020) then
  -- Buffer size is 80 bytes (see below) so we put it in its own bank starting
  -- at address 0x120 which equals the base adress of 0x020 + 0x100
  -- The other two banks at 0x0020 and 0x00A0 are already use (see below).
  const word USB_IN_DELIVERY_BUFFER_LOC = ( USB_BASE_ADDRESS + 0x0100 )
end if
if (USB_BDT_ADDRESS  == 0x0200) then
  -- Other USB_BDT_ADDRESS, for PIC18F14K50 this is 0x0200.
  -- Address must be above 0x70 due to end address of USB_EP3_IN_ADDR
  const word USB_IN_DELIVERY_BUFFER_LOC = ( USB_BASE_ADDRESS + 0x0078 )
end if

-- Although defined with a size of 8 bytes in the initial driver version
-- using only the POSTINC function, this usb_delivery_buffer must be much
-- larger since it is also used to transmit the device descriptor which is 67
-- bytes long. So it has been re-declared to 80 bytes in size.
var byte usb_delivery_buffer[ 80 ] at USB_IN_DELIVERY_BUFFER_LOC
var byte usb_delivery_bytes_max_send
var byte usb_delivery_bytes_sent
var byte usb_delivery_buffer_size
var byte usb_delivery_bytes_to_send

if defined(USB_DEBUG) == false  then
	const bit USB_DEBUG = false
end if

if defined(USB_DEBUG_HIGH) == false  then
	const bit USB_DEBUG_HIGH = false
end if

const byte USB_HIGHEST_EP = 3
const bit USB_SELF_POWERED = 1

--const word usb_sdp_loc = ( USB_BASE_ADDRESS + 0x0030 )
if (USB_BDT_ADDRESS  == 0x0020) then
  -- Address must start somewhere after end address of usb_bd3in which ends
  -- at base address + 0x001f.
  const word usb_sdp_loc = ( USB_BASE_ADDRESS + 0x0020 )
end if
if (USB_BDT_ADDRESS  == 0x0200) then
  -- Other USB_BDT_ADDRESS, for PIC18F14K50 this is 0x0200.
  -- Address must be above end address of USB_IN_DELIVERY_BUFFER_LOC which ends
  -- at 0x00C8. Here it placed just before the end of the usb_bd_array.
  const word usb_sdp_loc = ( USB_BASE_ADDRESS + 0x00F8 )
end if

var volatile byte usb_sdp[8] at usb_sdp_loc
var volatile byte usb_sdp_request_type at usb_sdp_loc
var volatile byte usb_sdp_request at usb_sdp_loc + 1
var volatile word usb_sdp_value at usb_sdp_loc + 2
var volatile word usb_sdp_index at usb_sdp_loc + 4
var volatile word usb_sdp_length at usb_sdp_loc + 6


-- USB_STATUS
const byte USB_STATUS_IDLE 			    = 0
const byte USB_STATUS_SET_ADDRESS 	= 1
	
-- USB STATE
const byte USB_STATE_POWERED	  = 0 -- USB device is powered up, ready to start negotiating
const byte USB_STATE_DEFAULT 	  = 1	-- USB device is now negotiating
const byte USB_STATE_ADDRESS 	  = 2	-- USB device now has an address
const byte USB_STATE_CONFIGURED	= 3 -- USB device is completely configured and ready to rock and roll 
 
-- USB COMMAND MODES
const byte USB_CM_IDLE 							          = 0 -- No control transfer taking place
const byte USB_CM_CTRL_WRITE_DATA_STAGE 		  = 1 -- Device receiving data during the data stage
const byte USB_CM_CTRL_WRITE_DATA_STAGE_CLASS	= 2 -- Device receiving data during the data stage destined for the class 
const byte USB_CM_CTRL_READ_DATA_STAGE 		  	= 3 -- Device sending data during the data stage
const byte USB_CM_CTRL_READ_DATA_STAGE_CLASS 	= 4 -- Device class is sending data during the data stage
const byte USB_CM_CTRL_READ_AWAITING_STATUS 	= 5 -- Device is awaiting reception of status after sending data
const byte USB_CM_CTRL_WRITE_SENDING_STATUS 	= 6 -- Device is sending status after receiving data 


-- USB REQUESTS
const byte USB_REQUEST_GET_STATUS 			= 0x00
const byte USB_REQUEST_CLEAR_FEATURE 		= 0x01
const byte USB_REQUEST_SET_FEATURE			= 0x03
const byte USB_REQUEST_SET_ADDRESS			= 0x05
const byte USB_REQUEST_GET_DESCRIPTOR		= 0x06
const byte USB_REQUEST_SET_DESCRIPTOR		= 0x07
const byte USB_REQUEST_GET_CONFIGURATION 	= 0x08
const byte USB_REQUEST_SET_CONFIGURATION 	= 0x09
const byte USB_REQUEST_GET_INTERFACE 		= 0x0a
const byte USB_REQUEST_SET_INTERFACE 		= 0x0b
const byte USB_REQUEST_REQ_SYNCH_FRAME 		= 0x0c


-- Bits of BDn.stat when UOWN = 0
const byte USB_BDSTATUS_UOWN	  = 7	-- 0 if uC owns buffer
const byte USB_BDSTATUS_DTS		  = 6	-- 1 data 1 packet, 0 data 0 packet
const byte USB_BDSTATUS_KEN		  = 5	-- 1 USB will keep buffer indefinately, 0 USB will hand back buffer
const byte USB_BDSTATUS_INCDIS 	= 4	-- 1 Address increment disabled (for SPP), 0 address increment enabled
const byte USB_BDSTATUS_DTSEN	  = 3	-- 1 data toggle sync on, 0 data toggle sync off
const byte USB_BDSTATUS_BSTALL	= 2	-- 1 buffer stall enabled, 0 buffer stall disabled
const byte USB_BDSTATUS_BC9		  = 1	-- bit 9 of buffer count
const byte USB_BDSTATUS_BC8		  = 0	-- bit 8 of buffer count


const USB_DATA_STAGE_DIR_BIT = 7
const USB_REQUEST_TYPE1_BIT	= 6 -- 00= USB standard request
const USB_REQUEST_TYPE0_BIT = 5 -- 01= Request for a specific class
-- const byte USB_REQUEST_TYPE_MASK = 0b_0110_000
-- 10= Vendor specific
--						
-- Bits 4-0 define recipient bits
-- 0b00000= Device
-- 0b00001= Specific interface
-- 0b00010= Endpoint
-- 0b00011= Other element (whatever that means)

-- Token
const byte USB_PID_OUT   = 0b00000001
const byte USB_PID_IN    = 0b00001001
const byte USB_PID_SOF   = 0b00000101
const byte USB_PID_SETUP = 0b00001101

-- Data
const byte USB_PID_DATA0 = 0b00000011
const byte USB_PID_DATA1 = 0b00001011
const byte USB_PID_DATA2 = 0b00000111
const byte USB_PID_MDATA = 0b00001111

-- Handshake
const byte USB_PID_ACK		= 0b00000010
const byte USB_PID_NAK		= 0b00001010
const byte USB_PID_STALL	= 0b00001110
const byte USB_PID_NYET		= 0b00000110

var byte usb_state = USB_STATE_POWERED
var byte usb_status
var byte usb_control_mode
var byte usb_address

-- Start address of the end points. Note: USB_BASE_ADDRESS must not be used
-- anymore to define the start address of the end points since the now defined
-- used USB_EPO_ADDRESS may differ per PIC!
-- For backwards compatibility the use of USB_BASE_ADDRESS still works for
-- older sample programa since the start address for was not changed.
-- This constant is now used in usb_serial.jal.
if (USB_BDT_ADDRESS  == 0x0020) then
  const USB_EP0_ADDRESS = USB_BASE_ADDRESS + 0x0080
  -- Buffer reservation used by end points. This buffer overlays with the
  -- endpoint buffers on purpose (see e.g. usb_serial.jal).
  var volatile byte usb_bd_endpt[ 80 ] at ( USB_EP0_ADDRESS )
  -- Buffer reservarion used for the buffer descriptions. This buffer overlays
  -- with the 4 usb buffer descriptions on purpose (see below).
  var volatile byte usb_bd_array[ 80 ] at ( USB_BASE_ADDRESS + 0x0000 )
end if
if (USB_BDT_ADDRESS  == 0x0200) then
  const USB_EP0_ADDRESS = USB_BASE_ADDRESS + 0x0020
  -- Other USB_BDT_ADDRESS, for PIC18F14K50 this is 0x0200. This PIC has a
  -- memory space of 256 bytes so we reserve the full range at once.
  var volatile byte usb_bd_array[ 256 ] at ( USB_BASE_ADDRESS + 0x0000 )
end if

var volatile byte usb_bd0out[4]		at ( USB_BASE_ADDRESS + 0x0000 )
var volatile byte usb_bd0out_stat 	at usb_bd0out[0]
var volatile byte usb_bd0out_cnt   	at usb_bd0out[1]
var volatile word usb_bd0out_addr 	at usb_bd0out[2]
var volatile byte usb_bd0out_addrl 	at usb_bd0out[2]
var volatile byte usb_bd0out_addrh 	at usb_bd0out[3]

var volatile byte usb_bd0in[4]		at ( USB_BASE_ADDRESS + 0x0004 )
var volatile byte usb_bd0in_stat 	at usb_bd0in[0]
var volatile byte usb_bd0in_cnt   	at usb_bd0in[1]
var volatile word usb_bd0in_addr 	at usb_bd0in[2]
var volatile byte usb_bd0in_addrl 	at usb_bd0in[2]
var volatile byte usb_bd0in_addrh 	at usb_bd0in[3]

var volatile byte usb_bd1out[4]		at ( USB_BASE_ADDRESS + 0x0008 )
var volatile byte usb_bd1out_stat 	at usb_bd1out[0]
var volatile byte usb_bd1out_cnt   	at usb_bd1out[1]
var volatile word usb_bd1out_addr 	at usb_bd1out[2]
var volatile byte usb_bd1out_addrl 	at usb_bd1out[2]
var volatile byte usb_bd1out_addrh 	at usb_bd1out[3]

var volatile byte usb_bd1in[4]		at ( USB_BASE_ADDRESS + 0x000C )
var volatile byte usb_bd1in_stat 	at usb_bd1in[0]
var volatile byte usb_bd1in_cnt   	at usb_bd1in[1]
var volatile word usb_bd1in_addr 	at usb_bd1in[2]
var volatile byte usb_bd1in_addrl 	at usb_bd1in[2]
var volatile byte usb_bd1in_addrh 	at usb_bd1in[3]

var volatile byte usb_bd2out[4]		at ( USB_BASE_ADDRESS + 0x0010 )
var volatile byte usb_bd2out_stat 	at usb_bd2out[0]
var volatile byte usb_bd2out_cnt   	at usb_bd2out[1]
var volatile word usb_bd2out_addr 	at usb_bd2out[2]
var volatile byte usb_bd2out_addrl 	at usb_bd2out[2]
var volatile byte usb_bd2out_addrh 	at usb_bd2out[3]

var volatile byte usb_bd2in[4]		at ( USB_BASE_ADDRESS + 0x0014 )
var volatile byte usb_bd2in_stat 	at usb_bd2in[0]
var volatile byte usb_bd2in_cnt   	at usb_bd2in[1]
var volatile word usb_bd2in_addr 	at usb_bd2in[2]
var volatile byte usb_bd2in_addrl 	at usb_bd2in[2]
var volatile byte usb_bd2in_addrh 	at usb_bd2in[3]

var volatile byte usb_bd3out[4]		at ( USB_BASE_ADDRESS + 0x0018 )
var volatile byte usb_bd3out_stat 	at usb_bd3out[0]
var volatile byte usb_bd3out_cnt   	at usb_bd3out[1]
var volatile word usb_bd3out_addr 	at usb_bd3out[2]
var volatile byte usb_bd3out_addrl 	at usb_bd3out[2]
var volatile byte usb_bd3out_addrh 	at usb_bd3out[3]

var volatile byte usb_bd3in[4]		at ( USB_BASE_ADDRESS + 0x001C )
var volatile byte usb_bd3in_stat 	at usb_bd3in[0]
var volatile byte usb_bd3in_cnt   	at usb_bd3in[1]
var volatile word usb_bd3in_addr 	at usb_bd3in[2]
var volatile byte usb_bd3in_addrl 	at usb_bd3in[2]
var volatile byte usb_bd3in_addrh 	at usb_bd3in[3]

var volatile bit EP1STALL   at  UEP1:0
var volatile bit EP1INEN   	at  UEP1:1
var volatile bit EP1OUTEN   at  UEP1:2
var volatile bit EP1CONDIS	at  UEP1:3
var volatile bit EP1HSHK	at  UEP1:4

var volatile bit EP2STALL   at  UEP2:0
var volatile bit EP2INEN   	at  UEP2:1
var volatile bit EP2OUTEN   at  UEP2:2
var volatile bit EP2CONDIS	at  UEP2:3
var volatile bit EP2HSHK	at  UEP2:4

var volatile bit EP3STALL   at  UEP3:0
var volatile bit EP3INEN   	at  UEP3:1
var volatile bit EP3OUTEN   at  UEP3:2
var volatile bit EP3CONDIS	at  UEP3:3
var volatile bit EP3HSHK	at  UEP3:4



----------------------------------------------------
const USB_DEVICE_DESCRIPTOR_SIZE = 18
const byte USB_DT_DEVICE = 0x01
const byte USB_DT_CONFIGURATION = 0x02
const byte USB_DT_STRING = 0x03
const byte USB_DT_INTERFACE = 0x04
const byte USB_DT_ENDPOINT = 0x05
const byte USB_DT_DEVICE_QUALIFIER = 0x06
const byte USB_DT_OTHER_SPEED_CONFIG = 0x07
const byte USB_DT_INTERFACE_POWER = 0x08
const byte USB_DT_OTG = 0x09
const byte USB_DT_DEBUG = 0x0a
const byte USB_DT_INTERFACE_ASSOC = 0x0b
const byte USB_DT_HID = 0x21
const byte USB_DT_HID_REPORT = 0x22

const byte USB_DT_CS_INTERFACE = 0x24


 
const byte USB_EP_CTRL 		= 0x06 -- Cfg Control pipe for this ep
const byte USB_EP_OUT 		= 0x0C -- Cfg OUT only pipe for this ep
const byte USB_EP_IN       	= 0x0A -- Cfg IN only pipe for this ep
const byte USB_EP_OUT_IN   	= 0x0E -- Cfg both OUT & IN pipes for this ep
const byte USB_HSHK_EN     	= 0x10 -- Enable handshake packet
 
 
-- Device Class Code
const byte USB_CDC_DEVICE = 0x02

-- Communication Interface Class Code
const byte USB_COMM_INTF = 0x02
 
-- Vendor specific interface code
const byte USB_VENDOR_INTF = 0xFF
 
-- Communication Interface Class SubClass Codes
const byte USB_ABSTRACT_CONTROL_MODEL = 0x02

-- Communication Interface Class Control Protocol Codes
const byte USB_V25TER = 0x01    -- Common AT commands ("Hayes(TM)")

const  byte USB_BD_STAT_IDX  = 0x00
const  byte USB_BD_CNT_IDX   = 0x01
const  byte USB_BD_ADDRH_IDX = 0x02
const  byte USB_BD_ADDRL_IDX = 0x03


const byte USB_HID_INTF = 0x03
const byte USB_BOOT_INTF_SUBCLASS = 0x01


-- HID Interface Class Protocol Codes
const byte USB_HID_PROTOCOL_NONE 		= 0x00
const byte USB_HID_PROTOCOL_KEYBOARD 	= 0x01
const byte USB_HID_PROTOCOL_MOUSE 		= 0x02

-- Endpoint Transfer Type
const byte USB_EPT_CTRL       = 0x00            -- Control Transfer
const byte USB_EPT_ISO        = 0x01            -- Isochronous Transfer
const byte USB_EPT_BULK       = 0x02            -- Bulk Transfer
const byte USB_EPT_INT        = 0x03            -- Interrupt Transfer


const byte USB_PULLUP_ENABLE = 0x10
const byte USB_PULLUP_DISABLED = 0x00

const byte USB_INTERNAL_TRANSCEIVER = 0x00
const byte USB_EXTERNAL_TRANSCEIVER = 0x08

const byte USB_FULL_SPEED = 0x04
const byte USB_LOW_SPEED  = 0x00

const byte USB_PING_PONG__NO_PING_PONG = 0x00		-- 0b00
const byte USB_PING_PONG__EP0_OUT_ONLY = 0x01		-- 0b01
const byte USB_PING_PONG__FULL_PING_PONG = 0x02		-- 0b10
const byte USB_PING_PONG__ALL_BUT_EP0 = 0x03		-- 0b11

-- Alias interrupt flag. The user can check this to see if USB is connected.
alias USB_EVENT_OCCURRED is PIR2_USBIF

