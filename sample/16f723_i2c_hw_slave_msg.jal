-- Title: Test program for i2c hardware slave, message interface implementation
-- Author: Joep Suijs, Sebastien Lelong, Copyright (c) 2008-2011, all rights reserved.
-- Adapted-by: 
-- Compiler: >=2.4m
-- Revision: $Revision$
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this sample shows how to implements an i2c hardware slave,
-- using the message interface lib. Basically, this i2c slave waits for
-- a full message to arrive and then calls a user routine to process the message and
-- (optional) prepare a response.
-- --
-- Conventions:
-- S = create (re)start state
-- P = create stop state
-- E4W = master writes 0x4E
-- R   = master reads and ACKs
-- N   = master reads and NACKs
-- --
-- s5Cw80ws5Dwrnp - reads application code and version (0x31 0x01)
-- s5Cw90w00wp    - LED off
-- s5Cw90wFFwp    - LED on 
-- --
--
-- This file has been generated by jallib.py from:
--    * board: board_16f723_af.jal
--    * test : test_i2c_hw_slave_msg.jal
--

;@jallib section chipdef

-- device include
include 16f723

-- Internal osc, running at 16 MHz
pragma target clock 16_000_000


-- fuses
pragma target OSC INTOSC_NOCLKOUT
pragma target WDT DISABLED
pragma target PWRTE DISABLED
pragma target MCLR INTERNAL
pragma target CP DISABLED
pragma target BROWNOUT DISABLED
pragma target VOLTAGE V19
pragma target WDTCS STANDARD
pragma target PLLEN F16MHZ
pragma target DEBUG DISABLED
pragma target VCAPEN pin_A0
;@jallib section led
-- LED IO definition
alias led             is pin_a7
alias led_direction   is pin_a7_direction
alias led2            is pin_a6
alias led2_direction  is pin_a6_direction

led_direction = output

-- setup serial (see echo.jal for more details);@jallib section serial
const serial_hw_baudrate = 115_200

include serial_hardware
serial_hw_init()

include print

const byte str1[] = "Test i2c hardware slave - msg interface.\r\n"   -- define a string
print_string(serial_hw_data, str1)                 -- output string
                             
-- ---------------
-- setup i2c slave 
-- ---------------
const byte I2C_BUFFER_SIZE = 40
include i2c_hw_slave_msg

-- this will be the slave address. It looks like:
--     0b_0101_1100
-- => 0b_0101_110   : 7-bits address
-- =>            0  : 8th bit is to specify read or write operation. 
--                    Value can be anything, it does not matter while init
const byte SLAVE_ADDRESS = 0x5C
i2c_hw_slave_init(SLAVE_ADDRESS) 



-- --------------------------------------------------------------------
-- i2c_process_message - User code for i2c slave
-- --------------------------------------------------------------------
-- This code is called from the ISR, every time the i2c slave module 
-- received a serie of bytes.
-- The ISR logic assures this procedure is called exactly once for 
-- each messagae.       
-- --------------------------------------------------------------------
procedure i2c_process_message(byte in byte_count) is
   if (i2c_buffer[0] == 0x80) then     
   
      if (byte_count == 1) then
         -- cmd 0x80 - request version
         i2c_buffer[0]   = 0x3C         -- application code
         i2c_buffer[1]   = 0x01         -- version
      end if
   
   elsif (i2c_buffer[0] == 0x90) then             
      
      if (byte_count == 2) then
         -- cmd 0x90 - turn LED off or on
         if (i2c_buffer[1] == 0) then
            LED = off
         else
            LED = on
         end if
      elsif (byte_count == 1) then
         -- cmd 0x90 without params: request for led status
         if (LED) then
            i2c_buffer[0] = 0xFF
         else
            i2c_buffer[0] = 0x00
         end if               
      end if
      
   end if

end procedure




-- blink a little to tell the world we're up
for 4 loop
   led = on
   _usec_delay(100000)
   led = off
   _usec_delay(100000)
end loop

-- just loop until interrupt is raised
forever loop        
   
end loop