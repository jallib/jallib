-- Title: FAT32 library for reading fat32 filesystem
-- Author: Matthew Schinkel, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4k
-- Revision: $Revision$
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this example reads files & folders from a fat32 formatted sd card
--              using the fat32 library.
--
-- Sources:
-- http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
-- http://www.pjrc.com/tech/8051/ide/fat32.html
-- http://en.wikipedia.org/wiki/File_Allocation_Table
--

-- include chip
include 18f4620                   -- target picmicro
-- this program assumes a 20 mhz resonator or crystal
-- is connected to pins osc1 and osc2.
pragma target osc INTOSC_NOCLKOUT              -- hs crystal or resonator
;pragma target osc hs              -- hs crystal or resonator
;pragma target clock 20_000_000    -- oscillator frequency
pragma target clock 32_000_000    -- oscillator frequency
--
pragma target wdt  disabled
pragma target lvp  disabled
pragma target MCLR external        -- reset externally
--;
;OSCCON_IRCF = 0b110   -- set int osc to 4mhz
OSCCON_IRCF = 0b111   -- set internal osc to 8mhz
OSCTUNE_PLLEN = true  -- multiply internal osc by 4
;--
enable_digital_io()                -- make all pins digital I/O
--
_usec_delay(100_000) -- wait for power to settle


include delay

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available


include print

include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
alias spi_master is spi_master_hw
alias spi_master_exchange is spi_master_hw_exchange


-- setup 23k256 for external memory
-- setup chip select pin
ALIAS sram_23k256_chip_select             is pin_a1
ALIAS sram_23k256_chip_select_direction   is pin_a1_direction
-- initial settings
sram_23k256_chip_select_direction = output    -- chip select/slave select pin
sram_23k256_chip_select = high                -- start chip slect high (chip disabled)
-- initalize 23k256 in byte mode
alias sram_23k256_force_spi_mode is spi_master_hw_set_mode_00 -- always set spi mode to 0,0
include sram_23k256 -- setup Microchip 23k256 sram
sram_23k256_init(SRAM_23K256_SEQUENTIAL_MODE, SRAM_23K256_HOLD_DISABLE)  -- init 23k256 in sequential mode


-- setup hard disk library
const bit PATA_HD_READ_EXTRA_SPEED = FALSE -- uses additonal code space to add a speed boost to sector_read procedures
CONST BYTE PATA_HD_USE_CS0_CS1_PINS = FALSE -- set true if you will use Alternate Status, Digital Output or Drive Address registers
const bit PATA_HD_NO_INVERTER = TRUE -- if true, an external inverter chip is not needed on /iowr, /iord, /cs0, /cs1 pins
-- pin assignments
alias     pata_hd_data_low              is portb   -- data port (low bits)
alias     pata_hd_data_low_direction    is portb_direction
alias     pata_hd_data_high             is portd   -- data port (high bits)
alias     pata_hd_data_high_direction   is portd_direction
alias     pata_hd_a0                    is pin_a3
alias     pata_hd_a0_direction          is pin_a3_direction
alias     pata_hd_a1                    is pin_a1
alias     pata_hd_a1_direction          is pin_a1_direction
alias     pata_hd_a2                    is pin_a0
alias     pata_hd_a2_direction          is pin_a0_direction
alias     pata_hd_iowr                  is pin_e0
alias     pata_hd_iowr_direction        is pin_e0_direction
alias     pata_hd_iord                  is pin_a4
alias     pata_hd_iord_direction        is pin_a4_direction
;alias     pata_hd_cs1                   is pin_a3
;alias     pata_hd_cs1_direction         is pin_a3_direction
;alias     pata_hd_cs0                   is pin_a4
;alias     pata_hd_cs0_direction         is pin_a4_direction

pata_hd_a0_direction = output    -- register select pin
pata_hd_a1_direction = output    -- register select pin
pata_hd_a2_direction = output    -- register select pin
pata_hd_iowr_direction = output  -- used for write pulse
pata_hd_iord_direction = output  -- used for read pulse
;pata_hd_cs1_direction = output   -- register select pin
;pata_hd_cs0_direction = output   -- register select pin

include pata_hard_disk           -- include the parallel ata ide hard disk library
pata_hd_init()                   -- initialize startup settings

-- setup fat32 --
-- include the required files
;include pic_data_eeprom
-- change these vaues to save memory
const bit FAT32_WRITE_LONG_FILE_NAMES = FALSE -- support writing of long file names
const word FAT32_FILES_MAX = 20            -- the max number of files allowed in a directory
const byte FAT32_FILE_NAME_SIZE = 80        -- choose max file_name size. if a file_name is longer the this, beginning chars will be cut. short file_names are 12 bytes.
const FAT32_DIR_FRAGMENTS_TO_ALLOW = 5     -- uses 6 bytes memory per fragment allowed (0 not allowed)
--                                          -- windows defrag does not defragment directories.
const FAT32_FILE_FRAGMENTS_TO_ALLOW = 5    -- uses 8 bytes memory per fragment allowed (0 not allowed)
--
-- experts may change the following values
;const byte FAT32_ENTRIES_MAX = 1           -- highest file entry address can be 256
const byte FAT32_ENTRIES_MAX = 2            -- highest file entry address can be 65535
--
-- choose a memory source for the file list
const bit FAT32_USE_INTERNAL_MEMORY = TRUE -- Use internal memory for file location list
IF FAT32_USE_INTERNAL_MEMORY == TRUE THEN
   -- Setup a large array for storing sector data, This is where file_name locations are stored
   const dword LARGE_ARRAY_2_SIZE = FAT32_FILES_MAX               -- choose number of array variables
   const dword LARGE_ARRAY_2_VARIABLE_SIZE = FAT32_ENTRIES_MAX    -- choose bytes size of variables
   include large_array_2                    -- include the array library
   ALIAS fat32_entry_location is large_array_2
elsif FAT32_USE_INTERNAL_MEMORY == FALSE THEN
   -- put your own code here if you wish to allow massive amounts of files per directory

   -- example usage of 23k256 for external memory

   -- alias the 23k256 device word array
   ;alias entry_location is sram_23k256_byte  -- highest file entry address can be 256
   alias fat32_entry_location is sram_23k256_word   -- highest file entry address can be 65535
END IF
--
include fat32   -- include fat32 library -- include fat32

-- CHOOSE FILE ATTRIBUTES TO FILTER OUT
fat32_filter_is_read_only  = FALSE
fat32_filter_is_hidden     = FALSE
fat32_filter_is_system     = FALSE
fat32_filter_is_volume_id  = FALSE
fat32_filter_is_directory  = FALSE
fat32_filter_is_archive    = FALSE

-- procedure for sending 80 "-----------------" via serial port
procedure separator() is
   serial_data = 13
   serial_data = 10
   const byte str3[] = "--------------------------------------------------------------------------------"
   print_string(serial_data, str3)
   print_crlf(serial_data)
end procedure

-- start of main program
separator()-- send "----"

fat32_init(1) -- initialize fat32, go to 1st primary partition's root dir "\"

------------------------------------------------------------
-- list a directory, send it via serial port
------------------------------------------------------------
fat32_print_directory(serial_data, FAT32_PRINT_ALL) -- see the procedure, sends dir listing via serial port

separator() -- send "-----" and go to next example

---------------------------------------------------------------------------------------------------------------
-- example read filename, send it via serial port
------------------------------------------------------------

-- we are still in the root dir of the 1st partition

;fat32_read_file_info(3) -- read 3rd file's name, location, size, attributes into memory

-- now send the filename via the serial port
;fat32_print_filename(serial_data)

------------------------------------------------------------
-- example user interaction,
-- send file/dir number via serial port to go into it
--
-- if volume id selected, list the current dir (root dir)
-- if directory selected go into it and list it
-- if file selected go into file and read it
------------------------------------------------------------

var byte data
var dword step1
var word step2

var byte file_number2 = 0
forever loop
   separator() -- send "-----" then loop and wait for user input

   -- this is not needed serial_sw.
   -- serial_data_available doesn't exist on serial sw.
   if defined(serial_data_available) then
      while !serial_data_available loop
      end loop
   end if

   file_number2 = serial_data

   -- choose a file for reading or dir for opening
   if fat32_cd(file_number2) then             -- if change directory is successful
      fat32_print_directory(serial_data, FAT32_PRINT_ALL) -- sends dir listing via serial port (with file numbers)
   elsif fat32_file_open(file_number2) then   -- if go into file is successful
   
      -- calculate number of sectors in file
      var dword sectors_available
      if (fat32_file_size) == (fat32_file_size / 512) * 512 then
         sectors_available = (fat32_file_size / 512)
      else
         sectors_available = (fat32_file_size / 512) + 1
      end if
   
;      -- EXAMPLE 1 READ (slowest and user friendly)
;      -- Read any byte number in the file, in any order you wish.
;      for fat32_file_size using step1 loop
;          data = fat32_read_file_byte_address(step1)
;          serial_data = data
;      end loop
;
      -- EXAMPLE 2 READ (slow, not so user friendly)
      -- You must start reading from the beginning of the file, and
      -- read sectors in order.
;      fat32_start_file_read ()
;      for fat32_file_size loop
;          data = fat32_read_file_byte()
;          serial_data = data
;      end loop
;      fat32_stop_file_read()

;      -- EXAMPLE 3 WRITE (fast and user friendly)
;      -- Read from any sector number in the file, in any order you wish.
;      for sectors_available using step1 loop
;
;         -- set the data to be written
;         for 512 using step2 loop
;            fat32_sector_buffer[step2] = "E"
;         end loop
;
;         -- write one sector to the disk
;         fat32_write_file_sector_number(step1)
;      end loop
      --
      --
      -- EXAMPLE 3 READ (fast and user friendly)
      -- Read from any sector number in the file, in any order you wish.
      for sectors_available using step1 loop
         -- read one sector from the disk
         fat32_read_file_sector_number(step1)
         -- send the sector via serial port
         for 512 using step2 loop
            serial_data = fat32_sector_buffer[step2]
         end loop
      end loop

;      -- EXAMPLE 4 WRITE (fastest, not so user friendly)
;      -- Read sectors from a file. You must start reading from
;      -- the beginning of the file, and read sectors in order.
;      fat32_start_file_write ()  -- go in the file, get ready to read
;      for ((fat32_file_size / 512) + 1) using step1 loop
;         -- set the data to be written
;         for 512 using step2 loop
;            fat32_sector_buffer[step2] = "D"
;         end loop
;         -- write one sector to the disk
;         fat32_write_file_sector()
;         -- send the sector via serial port
;      end loop
;      fat32_stop_file_write() -- end of file, set media idle
;      --
;      --
;      -- EXAMPLE 4 READ (fastest, not so user friendly)
;      -- Read sectors from a file. You must start reading from
;      -- the beginning of the file, and read sectors in order.
;      fat32_start_file_read ()  -- go in the file, get ready to read
;      for ((fat32_file_size / 512) + 1) using step1 loop
;         -- read one sector from the disk
;         fat32_read_file_sector()
;         -- send the sector via serial port
;         for 512 using step2 loop
;            serial_data = fat32_sector_buffer[step2]
;         end loop
;      end loop

      fat32_file_close()
   end if
end loop