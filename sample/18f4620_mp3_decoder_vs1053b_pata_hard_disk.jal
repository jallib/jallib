-- Title: MP3 decoder vs1053b sample
-- Author: Matthew Schinkel, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4n
-- Revision: $Revision$
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: example usage of the vs1053 mp3 decoder. plays .mp3 files from
--              a fat32 formatted sd card or hard disk. Full control of play
--              speed, volume, right/left speaker, bass, treble, mute.
--              Also plays Ogg Vorbis/AAC/WMA/MIDI
--
-- Notes:
-- vs1053 uses SPI mode 0,0
-- must use 12.288mhz crystal for vs1053b
--
-- Sources:
-- VLSI Solutions Datasheet - www.vlsi.fi/fileadmin/datasheets/vlsi/vs1053.pdf
--

-- include chip
include 18f4620                   -- target picmicro
-- this program assumes a 20 mhz resonator or crystal
-- is connected to pins osc1 and osc2.
pragma target osc INTOSC_NOCLKOUT              -- hs crystal or resonator
;pragma target osc hs              -- hs crystal or resonator
;pragma target clock 20_000_000    -- oscillator frequency
pragma target clock 32_000_000    -- oscillator frequency
--
pragma target wdt  disabled
pragma target lvp  disabled
pragma target MCLR external        -- reset externally
--;
;OSCCON_IRCF = 0b110   -- set int osc to 4mhz
OSCCON_IRCF = 0b111   -- set internal osc to 8mhz
OSCTUNE_PLLEN = true  -- multiply internal osc by 4
;--
enable_digital_io()                -- make all pins digital I/O
--
_usec_delay(100_000) -- wait for power to settle


include delay

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available


include print

include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
alias spi_master is spi_master_hw
alias spi_master_exchange is spi_master_hw_exchange


-- setup 23k256 for external memory
-- setup chip select pin
ALIAS sram_23k256_chip_select             is pin_a1
ALIAS sram_23k256_chip_select_direction   is pin_a1_direction
-- initial settings
sram_23k256_chip_select_direction = output    -- chip select/slave select pin
sram_23k256_chip_select = high                -- start chip slect high (chip disabled)
-- initalize 23k256 in byte mode
alias sram_23k256_force_spi_mode is spi_master_hw_set_mode_00 -- always set spi mode to 0,0
include sram_23k256 -- setup Microchip 23k256 sram
sram_23k256_init(SRAM_23K256_SEQUENTIAL_MODE, SRAM_23K256_HOLD_DISABLE)  -- init 23k256 in sequential mode


-- setup hard disk library
const bit PATA_HD_READ_EXTRA_SPEED = FALSE -- uses additonal code space to add a speed boost to sector_read procedures
CONST BYTE PATA_HD_USE_CS0_CS1_PINS = FALSE -- set true if you will use Alternate Status, Digital Output or Drive Address registers
const bit PATA_HD_NO_INVERTER = TRUE -- if true, an external inverter chip is not needed on /iowr, /iord, /cs0, /cs1 pins
-- pin assignments
alias     pata_hd_data_low              is portb   -- data port (low bits)
alias     pata_hd_data_low_direction    is portb_direction
alias     pata_hd_data_high             is portd   -- data port (high bits)
alias     pata_hd_data_high_direction   is portd_direction
alias     pata_hd_a0                    is pin_a3
alias     pata_hd_a0_direction          is pin_a3_direction
alias     pata_hd_a1                    is pin_a1
alias     pata_hd_a1_direction          is pin_a1_direction
alias     pata_hd_a2                    is pin_a0
alias     pata_hd_a2_direction          is pin_a0_direction
alias     pata_hd_iowr                  is pin_e0
alias     pata_hd_iowr_direction        is pin_e0_direction
alias     pata_hd_iord                  is pin_a4
alias     pata_hd_iord_direction        is pin_a4_direction
;alias     pata_hd_cs1                   is pin_a3
;alias     pata_hd_cs1_direction         is pin_a3_direction
;alias     pata_hd_cs0                   is pin_a4
;alias     pata_hd_cs0_direction         is pin_a4_direction

pata_hd_a0_direction = output    -- register select pin
pata_hd_a1_direction = output    -- register select pin
pata_hd_a2_direction = output    -- register select pin
pata_hd_iowr_direction = output  -- used for write pulse
pata_hd_iord_direction = output  -- used for read pulse
;pata_hd_cs1_direction = output   -- register select pin
;pata_hd_cs0_direction = output   -- register select pin

include pata_hard_disk           -- include the parallel ata ide hard disk library
pata_hd_init()                   -- initialize startup settings

-- setup fat32 --
-- include the required files
;include pic_data_eeprom
-- change these vaues to save memory
const bit FAT32_WRITE_LONG_FILE_NAMES = FALSE -- support writing of long file names
const word FAT32_FILES_MAX = 20            -- the max number of files allowed in a directory
const byte FAT32_FILE_NAME_SIZE = 80        -- choose max file_name size. if a file_name is longer the this, beginning chars will be cut. short file_names are 12 bytes.
const FAT32_DIR_FRAGMENTS_TO_ALLOW = 5     -- uses 6 bytes memory per fragment allowed (0 not allowed)
--                                          -- windows defrag does not defragment directories.
const FAT32_FILE_FRAGMENTS_TO_ALLOW = 5    -- uses 8 bytes memory per fragment allowed (0 not allowed)
--
-- experts may change the following values
;const byte FAT32_ENTRIES_MAX = 1           -- highest file entry address can be 256
const byte FAT32_ENTRIES_MAX = 2            -- highest file entry address can be 65535
--
-- choose a memory source for the file list
const bit FAT32_USE_INTERNAL_MEMORY = TRUE -- Use internal memory for file location list
IF FAT32_USE_INTERNAL_MEMORY == TRUE THEN
   -- Setup a large array for storing sector data, This is where file_name locations are stored
   const dword LARGE_ARRAY_2_SIZE = FAT32_FILES_MAX               -- choose number of array variables
   const dword LARGE_ARRAY_2_VARIABLE_SIZE = FAT32_ENTRIES_MAX    -- choose bytes size of variables
   include large_array_2                    -- include the array library
   ALIAS fat32_entry_location is large_array_2
elsif FAT32_USE_INTERNAL_MEMORY == FALSE THEN
   -- put your own code here if you wish to allow massive amounts of files per directory

   -- example usage of 23k256 for external memory

   -- alias the 23k256 device word array
   ;alias entry_location is sram_23k256_byte  -- highest file entry address can be 256
   alias fat32_entry_location is sram_23k256_word   -- highest file entry address can be 65535
END IF
--
include fat32   -- include fat32 library -- include fat32

-- CHOOSE FILE ATTRIBUTES TO FILTER OUT
fat32_filter_is_read_only  = FALSE
fat32_filter_is_hidden     = FALSE
fat32_filter_is_system     = FALSE
fat32_filter_is_volume_id  = FALSE
fat32_filter_is_directory  = FALSE
fat32_filter_is_archive    = FALSE


-- setup vs1053(b)
const byte str3[] = "INITIALIZING VS1053B"
print_string(serial_hw_data, str3)
--
alias vs_command_chip_select              is pin_e1                     -- command chip select pin
alias vs_command_chip_select_direction    is pin_e1_direction
alias vs_data_chip_select                 is pin_e2                     -- data chip select pin
alias vs_data_chip_select_direction       is pin_e2_direction
alias vs_dreq                             is pin_c0                     -- data request pin
alias vs_dreq_direction                   is pin_c0
--
vs_command_chip_select_direction = output
vs_data_chip_select_direction = output
vs_dreq_direction = input
--
vs_command_chip_select = high -- disable command chip select
vs_data_chip_select = high -- disable data chip select
--
-- select weather or not to switch SPI modes before every read/write
-- needed if using more then one component on the SPI bus.
-- enabled when vs_force_spi_mode is defined.
alias vs_force_spi_mode is spi_master_hw_set_mode_00 -- always set spi mode to 0,0
--
-- 5x pll (interal clock runs at 12.288mhz * 5 = 61.44)
-- note: higher SPI speeds require high PLL
const byte VS_PLL = 5 -- choose 1, 3_5 (3.5), or 5
const byte VS_SPI_COMMAND_SPEED = SPI_RATE_FOSC_64 -- choose speed to send commands
--
include mp3_decoder_vs1053b
vs_init()

-- procedure for sending 80 "-----------------" via serial port
procedure seperator() is
   serial_hw_data = 13
   serial_hw_data = 10
   const byte str3[] = "--------------------------------------------------------------------------------"
   print_string(serial_hw_data, str3)
   print_crlf(serial_hw_data)
end procedure

-- start of main program
vs_volume = 240 -- set startup volume

-- example of using an output pin
var bit my_pin_name is vs_pin_gpio0
var bit my_pin_name_direction is vs_pin_gpio0_direction
my_pin_name_direction = output
my_pin_name = high

-- some vars
var sword db_level  -- will hold volume db (decibel) level

seperator()-- send "----"

fat32_init(1) -- initialize fat32, go to 1st primary partition's root dir "\"

------------------------------------------------------------
-- list a directory, send it via serial port
------------------------------------------------------------
fat32_print_directory(serial_hw_data, FAT32_PRINT_ALL) -- see the procedure, sends dir listing via serial port

------------------------------------------------------------
-- example user interaction,
-- if volume id selected, list the current dir (root dir)
-- if directory selected go into it and list it
-- if file selected go into a mp3 file and play it
------------------------------------------------------------

var byte file_number = 0
var dword count8 = 0

forever loop
   seperator() -- send "-----"

   -- wait for user to send serial data (file selection)
   while !serial_hw_data_available loop
   end loop

   file_number = serial_hw_data

   if !(file_number > fat32_dir_file_count) then -- if the file number exists
      -- display the file_name chosen
      print_word_dec(serial_hw_data,file_number)
      const byte string1[] = {0x2E,0x20,0x20} -- ".  "
      print_string(serial_hw_data,string1)
      fat32_read_file_info(file_number) -- read file's name, location, size, attributes into memory
      fat32_print_file_info(serial_hw_data,FAT32_PRINT_ALL)
      seperator() -- send "-----"
   end if

   -- do something with the chosen file number
   if fat32_cd(file_number) then            -- if change directory is successful
      fat32_print_directory(serial_hw_data, FAT32_PRINT_ALL)                      -- sends dir listing via serial port

   elsif fat32_file_open(file_number) then  -- if file open is successful
      var dword sector_step = 0
      count8 = 0

      vs_play() -- allow vs1053b to play music

      -- continue till no data is left.
      for (fat32_file_size / 512) + 1 loop
         fat32_read_file_sector_number(sector_step)
         sector_step = sector_step + 1

         -- do something with the data
         if (fat32_file_extension[0] == "m" & fat32_file_extension[1] == "p" & fat32_file_extension[2] == "3") |
            (fat32_file_extension[0] == "m" & fat32_file_extension[1] == "P" & fat32_file_extension[2] == "3") |
            (fat32_file_extension[0] == "M" & fat32_file_extension[1] == "p" & fat32_file_extension[2] == "3") |
            (fat32_file_extension[0] == "M" & fat32_file_extension[1] == "P" & fat32_file_extension[2] == "3") then

            -- now send it to vs1053b

            -- set to spi mode 00
            SSPCON1_CKP = 0
            SSPSTAT_CKE = 1
            -- enable vs1053b
            vs_data_chip_select = low

            var word count1                        -- sector data count
            count1 = 0
            for 16 loop                             -- loop till end of sector read

               -- wait till data gets requested
               while vs_dreq == low loop
               end loop

               -- vs1053b can take up to 32 bytes when vs_dreq is low
               for 32 loop
                  spi_master_hw = fat32_sector_buffer[count1]
                  count1 = count1 + 1
               end loop
            end loop
         else
            var word count1 = 0
            for 512 loop
               serial_hw_data = fat32_sector_buffer[count1]
               count1 = count1 + 1
            end loop
         end if

         -- get users input via serial port to control music (volume, play speed, stop, etc.)
         if serial_hw_data_available == TRUE then
            var byte serial_data = serial_hw_data
            if serial_data == 0 then                    -- stop
               fat32_set_idle()          -- set data device to idle state
               vs_stop()                 -- stop the audio
               vs_data_chip_select = low -- disable mp3 decoder
               exit loop
            elsif serial_data == 50 then                -- volume down
               if vs_volume != 0 then
                  vs_volume = vs_volume - 1
               end if
               print_byte_dec(serial_hw_data, vs_volume)
               -- invert to negitive word value for volume in db (decibels)
               db_level = sword(255 - vs_volume)
               db_level = !(db_level * 5) + 1
               -- send volume to serial port
               format_sword_dec(serial_hw_data, db_level,6,1)
               serial_hw_data = "d"
               serial_hw_data = "b"
            elsif serial_data == 51 then                -- volume up
               if vs_volume != 255 then
                  vs_volume = vs_volume + 1
               end if
               print_byte_dec(serial_hw_data, vs_volume)
               -- invert to negitive word value for volume in db (decibels)
               db_level = sword(255 - vs_volume)
               db_level = !(db_level * 5) + 1
               -- send volume to serial port
               format_sword_dec(serial_hw_data, db_level,6,1)
               serial_hw_data = "d"
               serial_hw_data = "b"
            elsif serial_data == 52 then                -- volume down right only
               if vs_volume_right != -127 then
                  vs_volume_right = vs_volume_right - 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_right)
            elsif serial_data == 53 then                -- volume up right only
               if vs_volume_right != 127 then
                  vs_volume_right = vs_volume_right + 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_right)
            elsif serial_data == 54 then                -- volume down left only
               if vs_volume_left != -127 then
                  vs_volume_left = vs_volume_left - 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_left)
            elsif serial_data == 55 then                -- volume up left only
               if vs_volume_left != 127 then
                  vs_volume_left = vs_volume_left + 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_left)
            elsif serial_data == 56 then                -- move volume right to left
               if vs_volume_left != 127 then
                  vs_volume_left = vs_volume_left + 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_left)
               serial_hw_data = " "
               if vs_volume_right != -127 then
                  vs_volume_right = vs_volume_right - 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_right)
            elsif serial_data == 57 then                -- move volume left to right
               if vs_volume_left != -127 then
                  vs_volume_left = vs_volume_left - 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_left)
               serial_hw_data = " "
               if vs_volume_right != 127 then
                  vs_volume_right = vs_volume_right + 1
               end if
               print_sbyte_dec(serial_hw_data, vs_volume_right)
            elsif serial_data == 58 then                -- slower play speed
               if !(vs_play_speed == 1) then
                  vs_play_speed = vs_play_speed - 1
               end if
               print_word_dec(serial_hw_data, vs_play_speed)
               print_crlf(serial_hw_data)
            elsif serial_data == 59 then                -- faster play speed (fast-forward)
               if !(vs_play_speed == 10) then
                  vs_play_speed = vs_play_speed + 1
               end if
               print_word_dec(serial_hw_data, vs_play_speed)
               print_crlf(serial_hw_data)
            elsif serial_data == 60 then                -- get file info, so far
               vs_file_info()                           -- only file type " MP3", "MIDI", etc.
               print_string(serial_hw_data,vs_current_file_type) -- send filetype
               serial_hw_data = " "
               print_dword_dec (serial_hw_data,vs_bitrate)       -- send bitrate
               serial_hw_data = " "
               print_dword_dec (serial_hw_data,vs_average_bitrate) -- send avgerage bitrate
               serial_hw_data = " "
               print_dword_dec (serial_hw_data,vs_samplerate)  -- send samplerate
               print_crlf(serial_hw_data)
            elsif serial_data == 61 then                -- MUTE
               vs_mute = TRUE
               print_byte_dec(serial_hw_data, 1)
            elsif serial_data == 62 then                -- NO MUTE
               vs_mute = FALSE
               print_byte_dec(serial_hw_data, vs_mute)
            elsif serial_data == 63 then                -- bass down
               if vs_bass != 0 then
                  vs_bass = vs_bass - 1
               end if
               print_word_dec(serial_hw_data, vs_bass)
            elsif serial_data == 64 then                -- bass up
               if vs_bass != 15 then
                  vs_bass = vs_bass + 1
               end if
               print_word_dec(serial_hw_data, vs_bass)
            elsif serial_data == 65 then                -- treble down
               if vs_treble != -8 then
                  vs_treble = vs_treble - 1
               end if
               print_sword_dec(serial_hw_data, vs_treble)
            elsif serial_data == 66 then                -- treble up
               if vs_treble != 7 then
                  vs_treble = vs_treble + 1
               end if
               print_sword_dec(serial_hw_data, vs_treble)
            end if

            -- send return char
            serial_hw_data = 13
            serial_hw_data = 10
         end if
         vs_data_chip_select = high -- disable vs1053b
         count8 = count8 + 1

      end loop
      -- close the file
      fat32_file_close()
      seperator()
      fat32_print_directory(serial_hw_data, FAT32_PRINT_ALL) -- see the procedure, sends dir listing via serial port
   end if
end loop
