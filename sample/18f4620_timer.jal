-- Title: Basic usage of timer library
-- Author: Matthew Schinkel, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q5
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: This example shows basic usage of timer library for a
--              standard way to use timers. This sample outputs a 1khz
--              square wave, while blinking a led.
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
--
-- notes:
--

include 18f4620                      -- target PICmicro
--
-- This program assumes that a 20 MHz resonator or crystal
-- is connected to pins OSC1 and OSC2.
pragma target clock 20_000_000      -- oscillator frequency
--
pragma target OSC      HS                        -- crystal or resonator
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- extended instruction set
pragma target DEBUG    DISABLED                  -- debugging
pragma target BROWNOUT DISABLED                  -- brownout reset
pragma target FCMEN    DISABLED                  -- clock monitoring
pragma target IESO     DISABLED                  -- int/ext osc. switch
pragma target LVP      DISABLED                  -- low voltage programming
pragma target MCLR     EXTERNAL                  -- reset
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
OSCTUNE_PLLEN = TRUE                -- PLL
--
enable_digital_io()                 -- make all pins digital I/O

-- timer out def
alias wave_out             is pin_a1
alias wave_out_direction   is pin_a1_direction
--
wave_out_direction = output

-- led def
alias led             is pin_a0
alias led_direction   is pin_a0_direction
--
led_direction = output

-- Setup timer Lib
const byte TIMER0_PS_RATIO = 1              -- set prescaller ratio
const byte TIMER0_BITS = 16                 -- Use 8 or 16 bits
const byte TIMER0_ENABLE_INTERRUPT = TRUE   -- Interrupts off/on
include timer0
timer_init()                                -- configures and starts timer
-- Other config:
timer0_cs = 0                               -- 0 = internal, 1 = external

-- Alias the timer to allow this sample to use timer0
alias timer          is timer0              -- the timer/counter
alias TIMER_PS_RATIO is TIMER0_PS_RATIO     -- prescaller ratio
alias TIMER_BITS     is TIMER0_BITS         -- timer bits
alias timer_cs       is timer0_cs           -- timer clock select
alias timer_if       is timer0_if           -- timer interrupt occurred bit

--------------------------------------------------------------------------
-- returns timer interval required for a desired frequency
-- return value of 0 indicates the desired frequency can't be calculated.
-- freq_hz     - your desired frequency
-- freq_adjust - adjust by number of timer steps (may want to use OSCCAL reg.)
--------------------------------------------------------------------------
function calc_freq(dword in freq_hz, sword in freq_adjust) return word is
   var dword timer_interval

   -- Timer rollover value - 65535 for 16 bit timer, 255 for 8 bit.
   var bit*TIMER_BITS timer_rollover = 0
   timer_rollover = timer_rollover - 1

   var dword value1 = (1000000000/freq_hz)/2                    ;5000
   var dword value2 = (1000/(target_clock/1000000))*4           ;100

   if (value2 > value1) then
      return 0
   else
      if timer_rollover > (value1 / value2) then ;Check if the timer can wait this long
         timer_interval = timer_rollover - (value1 / value2)

         if (value1 / value2) < 50 then ;Allow enough time for the IRS to complete
            return 0
         else
            return word(timer_interval + freq_adjust)
         end if
      else
          return 0
      end if
   end if
end function

-- Set this to desired interval. timer3 will count up.
-- Interupt will occur when timer_interval rolls
-- over from 65535 to 0
;var word timer_interval = 65535 - 2500 -- 63035 = 1khz square wave at 20mhz,
var word timer_interval = calc_freq(1000,0) -- same result as previous line at 20mhz
--
-- output will change every 0.5ms, full wave in 1ms.
-- interrupt occurs every 0.5ms
-- this value can be calculated:
-- 65535    - ( (1/1khz/2) / ( (1/20_000_000)*4 ) ) = 63035
-- timermax - ( (1/HZ/2) / ( (1/OSC FREQ  )*4 ) ) = timer_interval

-- Turn off timer if timer can't be set to the correct freq.
-- Try 16 bit timer.
-- If it's not working with your settings, you may need prescaler
if timer_interval == 0 then
   ;timer_on = 0  -- uncomment
end if

-----------
procedure timer_isr() is
   pragma interrupt          -- interupt procedure

   if !timer_if then       -- check if this is a timer interupt
      return                 -- exit interupt if it is not
   end if

   timer_if = off          -- clear overflow to start timer

   wave_out = !wave_out      -- change wave_out pin to oposite value
   timer = timer_interval -- set the interval
end procedure

-- main program here
forever loop
   _usec_delay (250_000)
   led = on
   _usec_delay (250_000)
   led = off
end loop

