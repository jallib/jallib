<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml-strict.dtd">
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=UTF-8">
   <meta name="author" content="Rob Hamerling">
   <meta name="description" content="Jallib Device File Users Guide">
   <meta name="copyright" content="Copyright &copy; Rob Hamerling 2008..2013. All rights reserved">
   <meta name="project" content="This file is part of jallib  http://jallib.googlecode.com">
   <meta name="license" content="Released under the BSD license"
                              "http://www.opensource.org/licenses/bsd-license.php">
   <meta name="compiler" content="2.4p">
   <meta name="revision" content="$Rev$">
   <title>Jallib Device Files Users Guide</title>
   <link rel="stylesheet" href="jallib.css" type="text/css">
</head>
<body lang="en-US" dir="LTR">


<h1>Jallib Device Files Users Guide</h1>
<p><center>
   Copyright &copy; Rob Hamerling 2008..2013. All rights reserved.
</center>


<h2>Table of contents</h2>
<ol>
<li><a href="#intro">Introduction</a>
<li><a href="#overall">The Overall Picture</a>
   <ul>
   <li><a href="#device_files">Device files</a>
   <li><a href="#chipdef_jallib">Common include file Chipdef_Jallib</a>
   <li><a href="#function_includes">Function include files</a>
   </ul>
<li><a href="#user">User Information</a>
   <ul>
   <li><a href="#sample_program">Sample Program</a>
   <li><a href="#ports_and_pins">Naming conventions for ports and pins</a>
      <ul>
      <li><a href="#portregs">PORTx and pins, TRISx and pin directions</a>
      <li><a href="#gpioregs">GPIO and TRISIO</a>
      <li><a href="#nibbles">Nibbles</a>
      <li><a href="#aliases">Alias names</a>
      <li><a href="#nmmregs">Non memory mapped registers (NMMR)</a>
      <li><a href="#input_only_pins">Input-only pins</a>
      </ul>
   <li><a href="#peripherals">Names for function modules and peripherals</a>
      <ul>
      <li><a href="#CCPregs">CCP</a>
      <li><a href="#ANSELregs">ANSEL</a>
      <li><a href="#ADCregs">ADC</a>
      <li><a href="#EEPROM">Data EEPROM</a>
      <li><a href="#EUSARTregs">[E]USART</a>
      <li><a href="#MSSPregs">MSSP (I2C,SPI)</a>
      <li><a href="#TIMERregs">Timers</a>
      <li><a href="#RTCCregs">RTCC</a>
      <li><a href="#status_shadow">Shadow STATUS</a>
      <li><a href="#miscregs">Miscellaneous</a>
      </ul>
   <li><a href="#shadowing">About Port Shadowing</a>
   <li><a href="#osccal">Calibration of Internal Oscillator</a>
   <li><a href="#usbprov">Provisions for USB</a>
   <li><a href="#ppsgroup">Peripheral Pin Selection</a>
   <li><a href="#fuses">Naming convention for configuration bit fields (fuses)</a>
   <li><a href="#compiler">Data Memory and Compiler Requirements</a>
      <ul>
      <li><a href="#memdata">Data memory</a>
      <li><a href="#membanks">Memory banks</a>
      <li><a href="#highmem">INTOSC calibration</a>
      <li><a href="#memusb">Data memory of PICs with USB module</a>
      <li><a href="#memshare">Shared memory</a>
      <li><a href="#analog">Analog modules</a>
      </ul>
   <li><a href="#compat">Compatibility and Miscellaneous Remarks</a>
   </ul>
<li><a href="#gen">Generating device files</a>
   <ul>
   <li><a href="#genproc">The process</a>
   <li><a href="#gennewds">To do with new datasheets</a>
   <li><a href="#genmplab">To do with a new release of MPLAB</a>
   </ul>
</ol>

<hr>


<h1><a name="intro">1. Introduction</a></h1>

<p>This document serves two purposes:
<ul>
<li>Inform the user how to use the JalV2 device files,
probably being more important for library developers than for application
developers.
<li>Provide information for maintenance and further development of the
device files.
</ul>

<p>The Jallib device files are generated by means of a Rexx script 'dev2jal'.
Its name is an abbreviation of 'MPLAB .dev to .jal' because it uses the .dev
files of the MPLAB-IDE to create the Jallib device files.
<b>Rexx</b> is an interpreted language, see for example
<a href="http://www.rexxinfo.org/">RexxInfo</a> and
<a href="http://en.wikipedia.org/wiki/REXX">Rexx Wiki</a>.

<p>The advantages of automated generation of device files are pretty
obvious, such as:
<ul>
<li>creation of device files for all PICmicros available in MPLAB
<li>automatic new device files for new chips
<li>consistent layout
<li>consistent naming convention
<li>no manual maintenance of device files
(and no errors due to typos with manual editing)
</ul>

<p>The advantages of a consistent naming convention are also obvious:
<ul>
<li>Easy migration of a program from one target PICmicro to another.
<li>Same for libraries using this naming convention.
</ul>


<hr>


<h1><a name="overall">2. The Overall Picture</a></h1>

<p>With the design of the device files I had in mind a structure as shown
below.
<pre>
                   +----------+   +------------------+
                   | device   |   |     general      |
                   | specific |---|     include      |
                   | include  |   |chipdef_jallib.jal|
                   +----------+   +------------------+
                        |
         +--------------+--------------+-------------+-----------
         |              |              |             |
   +----------+   +----------+   +----------+   +----------+
   | function |   | function |   | function |   | function |
   | include  |   | include  |   | include  |   | include  |   etc
   | 'delay'  |   |  'jal'   |   |'adc.....'|   |'pwm....' |
   +----------+   +----------+   +----------+   +----------+
</pre>

<p>The device files are now part of the central JalV2 library
repository <a href="http://jallib.googlecode.com/">Jallib</a> at
<b>GoogleCode</b>, which uses the same structure.


<h2><a name="device_files">Device Files</a></h2>

<p>The device files are the base for other include files and contain:
<ul>
<li>An include statement for the common include file 'chipdef_jallib'
<li>CPU type specification (12-, 14-, extended 14-, or 16-bits core).
<li>Program memory size specification.
<li>Data memory (EEPROM) location and size specification.
<li>Configuration memory (fuses) and ID memory location and size specification.
<li>A set of fuse settings.
<li>Declaration of symbolic names for configuration bits (fuses).
<li>Declaration of Special Function Register (SFR) address and mirror adresses,
alias names and bit fields.
<li>Specification of General Purpose Register (GPR, RAM) location range and
sharing.
<li>Declaration of procedures and functions for shadowing of I/O ports.
<li>Procedures to switch all pins to digital I/O.
</ul>

<p>Including a device file doesn't change anything to the PIC.
For example pins which are input after power-on or reset remain input,
etc.
Required changes are the responsibility of the application program or
function libraries.
<br>For user convenience every device file contains a procedure to
disable all analog modules of the PIC and to change all pins which are
by default analog to digital I/O: enable_digital_io().
This procedure calls on its turn procedures to disable ADC modules,
Comparator modules and a procedure to set analog pins to digital,
all when applicable to the specific PIC.

<p>The device file contains a set of 'default' configuration bits, see
<a href refid="cfg_defaults">Default Configuration Bits Setting</a>
for more information!


<h2><a name="chipdef_jallib">Common Include File 'chipdef_jallib.jal'</a></h2>

<p>The file 'chipdef_jallib.jal' which comes with these device files
replaces the file 'chipdef.jal' which comes with the compiler distribution.
It is included by every device file and contains:
<ul>
<li>Constants required by the compiler.
<li>Commonly used constants by the device files and other libraries.
</ul>

<p>With the statement 'pragma target chip = .....' in every device file the
compiler assigns a unique value to the constant 'target_chip'.
The program may reference this variable with a symbolic name.
This symbolic name consists of 'PIC_' followed by the type of the PIC,
which makes it possible to use the same source file to generate a hex file
for different types of PICs, as the following example shows:

<pre>
   if (target_chip == PIC_16F88) then          -- (not for 16f87)

     ....                                      -- 16F88 unique code

   end if
</pre>

<p>This program is designed for a 16F88, but may be used for another PIC,
like 16f87 (or any other).
But for any other PIC than a 16F88 the block of statements
between 'if' and 'end if' will be skipped by the compiler.
Of course the 'if' may be followed by one or more 'elsif' blocks or
an 'else' block to select PIC-specific code.

<p>The list of targets in chipdef_jallib.jal makes sure that every possible
target name and the corresponding value of target_chip is known to the
compiler.

<p>Note: The original chipdef.jal file of the compiler package specifies
a different value for 'target_chip' and only a limited number of PICs.
Therefore the Jallib version is included by the Jallib device files.


<h2><a name="function_includes">Function Include Files</a></h2>

<p>Function specific include files offer facilities to ease the use of
PIC peripherals (such as USART, ADC), external devices (such as LCDs,
sensors), or extensions to the Jal language such as for data
formatting, mathematical functions, etc.

<p>Function specific include files should be included explicitly as
required by the application program, this is not done by the device files.

<p>In most cases the function include files require some statements to
couple function specific registers and pins with the device.
Read the comments in the library sources and the library documentation
for instructions.
Most libraries contain comments with user instructions in the header of
include files and just ahead of the procedures and functions in these files.


<hr>

<h1><a name="user">3. User Information</a></h1>

<p>We'll start with a very elementary sample program (blink-a-led) to show
how device files make programming in JAL a piece of cake,
followed by a description of other features of the device files which are
aimed at writing device independent libraries.


<h2><a name="sample_program">Sample program</a></h2>

<p>The device files define static device (PICmicro) specific matter.
This allows writing elementary programs, such as for a blinking led, which
are almost device independent.
Differences are mostly in the fuse settings.

<p>The device files are also the base for extensions, such as
libraries for more complicated functions like displaying text on an LCD
display or handling analog devices.

<p>Below a simple blink-a-led program (led on pin 1 of port A) for a
PIC16F886 using a 20 MHz resonator.
In addition to the device-specific information obtained from the include
file '16f886.jal' some run-time information is needed, like the speed and
type of the oscillator and some other 'environmental' variables.
No extra function libraries are required.

<pre>
-- ------ blink-a-led on pin_A1 of a PIC16F886 --------

   include 16f886                        -- target is a PIC16F886
                                         -- Notes: - The extension .jal is
                                         --          added by the compiler!
                                         --        - No other includes needed.

   pragma target clock  20_000_000       -- oscillator frequency (in Hz)
                                         -- required for delays

   pragma target OSC    HS               -- high speed external oscillator
   pragma target WDT    Disabled         -- watchdog off
   pragma target MCLR   External         -- external chip reset
   pragma target LVP    Disabled         -- no low voltage programming

   enable_digital_io()                   -- set all pins to digital I/O

   alias  led           is pin_A1        -- declare alias for pin_A1
   alias  led_direction is pin_A1_direction   -- and for its direction

   led_direction = output                -- make led-pin output
   forever loop                          -- endless loop
      led = on                           -- light
      _usec_delay(250000)                -- spin 1/4 seconds
      led = off                          -- dark
      _usec_delay(250000)                -- spin 1/4 seconds
   end loop

</pre>
When loaded in a 16F886 with 20 MHz resonator or crystal a led connected
(with series resistor!) to pin 3 (RA1) should blink twice a second.


<h2><a name="ports_and_pins">Naming conventions for Ports and Pins</a></h2>

<p>Unfortunately MPLAB of Microchip is not particularly consistent in
its choice of names!
The datasheets and the various informational files in MPLAB do not
infrequently use different names for the same entity!
As a rule the device files use the names as used by the datasheets.
However the device files have been generated from the MPLAB information
files, not from the datasheets!
So it is possible that some names may not be conform to the datasheet.
When you find such a deviation not mentioned in this document, please
report to the Jallib team, and most likely the next release will contain
the corrected name.

<p>For all registers of the PIC a name is declared and where appropriate
also the individual bits or groups of bits are declared.
<br>Subfields of registers have the name of the register as prefix, like
<pre>
   var volatile bit  INTCON_GIE  at INTCON : 7
</pre>
Some aliases are declared for easy migration or conversion of
existing JalV2 libraries and programs to the Jallib environment.

<p>There are exceptions to the rules above.
<br>The aim of 'normalization' (using a consistent naming) is:
<ol>
<li>to be able to use all libraries for all types of PICmicros
<li>to ease the migration of programs amd libraries to other types of PICs.
</ol>


<h3><a name="portregs">PORTx and pins, TRISx and pin directions</a></h3>
<p>For all ports and port pins a device independent alias is declared and a
similar direction declaration, as the following examples show:
<pre>
   var  volatile  byte  PORTA            at  &lt;addr&gt;
   var  volatile  byte  TRISA            at  &lt;addr&gt;
   alias                PORTA_direction  is TRISA
   var  volatile  bit   pin_A0           at  PORTA : 0
   alias                pin_A0_direction at TRISA : 0
</pre>
etc. (for all other existing pins and ports).


<h3><a name="gpioregs">GPIO and TRISIO (with the smaller chips)</a></h3>
<p>Although the smaller PICs have no 'official' PORTA and TRISA registers,
the device files contain aliases for these.
So even with the smaller PICs you can use the names PORTA, pin_A0,
pin_A0_direction, etc.
<pre>
   var  volatile  byte  GPIO             at { &lt;addr&gt; }
   alias                PORTA            is GPIO

   var  volatile  byte  TRISIO           at { &lt;addr&gt; }
   alias                TRISA            is TRISIO
   alias                PORTA_direction  is TRISIO

   var  volatile  bit   GPIO_GP0         at GPIO : 0
   var  volatile  bit   pin_A0           at GPIO : 0

   var  volatile  bit   TRISIO_TRISIO0   at TRISIO : 0
   alias                pin_A0_direction is TRISIO_TRISIO0
</pre>
etc. (for all other existing pins)

<p>Pins which can be input-only may have no corresponding _direction
variable, for example pin_E3_direcxtion of the 18F4550 is not declared.


<h3><a name="nibbles">Nibbles</a></h3>
<p>Because the upper and lower 4 bits ('nibble') of a port are
frequently used as a unit - for example as data lines for LCDs -
these are declared as (pseudo) variables.
<pre>
   PORTx_low               - bits 0..3    (low order bits)
   PORTx_high              - bits 4..7    (high order bits)
   PORTx_low_direction
   PORTx_high_direction
</pre>
This allows nibbles to be used as a regular variables.

<br>The value for both PORTx_low and PORTx_high is passed
in the lower nibble (bits 3..0) of a constant or variable,
both with reading from and writing to the nibble.
For example:
<pre>
    PORTA_high   = 0b0000_0101       -- lower nibble remains unchanged
    var byte nib = PORTA_high        --
</pre>

<p>Nibbles can also be used to set pin directions by 4 at a time:
<pre>
   PORTA_low_direction = ALL_OUTPUT  -- direction of upper nibble
                                     -- remains unchanged
</pre>
Several function libraries in the Jallib collection use this facility.

<p>Note: Nibbles are always declared even when the register doesn't have the
nibble fully populated, or even not populated at all!


<h3><a name="aliases">Alias names</a></h3>
<p>When a pin is multiplexed (has a different function depending on
control registers or configuration bit settings), aliases are declared
to make the pin accessible by a more functional name.
For example: of the 16F88 pin_B6 is usable as analog input for the ADC
module as channel 5 and therefore pin_B6 has been given an alias name
pin_AN5.
You can find the 'AN5' name with the pin layout pictures and tables in the
datasheet.
<br>Of course also for the pin_B6_direction an alias is declared and
called similarly pin_AN5_direction!
<br>Libraries (for this example the ADC library) will use the alias
names in stead of the physical pin names.
Another PIC may have pin_AN5 associated with a different physical pin,
but by using the alias name the ADC library becomes indenpent of the
physical pin configuration
which makes the library to a large extent device independent.

<p>If you want to use another name for a port, nibble or individual pin
you can also specify an alias in your program.
For example when you have a red led connected to pin 0 of PortA, you could
specify:
<pre>
   alias  led_red  is  pin_A0
</pre>
and use 'led_red = ON' or 'led_red = OFF' assignments in your program.
<p>Pin aliases in the device files are declared in this
way and therefore also make use of the port shadowing provided by
the device files.
<br<i>This way of aliasing - using the keyword 'alias' - is only
available since JalV2 compiler version 2.4n.</i>

<p>You should <b>avoid direct pin and I/O port manipulation</b>, because
it will be overruled by the automatic shadowing mechanism
(see the chapter about <A href="#ch_shadowing">About Port Shadowing</a>).
For example do <b>not</b> specify:
<pre>
   var bit led_red at portA : 0
</pre>
With this specification a 'led_red = on' will have the desired result, but
it will not update the shadow register.
Any next operation which uses the shadowing mechanism will override the
previous direct control operation.

<p>Some pin alias names are not acceptable for the JalV2 compiler, in
which case a special name is used.
For example PICs with USB support have a D+ and D- pin.
These are declared (for the 18F4550) as:
<pre>
   alias  pin_D_POS     is  pin_C5
   alias  pin_D_NEG     is  pin_C4
</pre>

<p>Some function pins can be on one or another pin of a PIC,
controlled by a register or a configuration bit setting.
In these cases the name has to be suffixed to prevent duplicate names.
For example the 16F737 can have the CCP2 bit on pin_B3 or pin_C1,
controlled by a configuration bit (fuse_def CCP2MUX).
<pre>
   alias  pin_CCP2_RB3  is  pin_B3
   alias  pin_CCP2_RC1  is  pin_C1
</pre>
The program or library has to detect the actual use of the CCP2 pin.

<p>Some high end 18Fs have an even more complex multiplexing mode.
With the 18F8310 for example the multiplexing depends also on the
processor mode.
One position of CCP2 is pin_C1, the alternate pin is pin_E7
(in Microcontroller mode) or pin_B3 (in Microprocessor,
Extended Microcontroller and Microcontroller with Boot Block modes).
This variant is not always available in the device files!


<h3><a name="nmmregs">Non-memory-mapped registers</a></h3>
<p>In addition to or in stead of normal (memory mapped) Special Function
Registers (SFRs) some PICs have Non Memory Mapped Registers (NMMRs).
It requires a special action or the setting of a flag or a bit pattern
in another register to read or write these registers.
For example:
<ul>
<li>The 12-bit core PICs like 10Fs, 12F5x have no memory mapped TRISx
registers.
In stead these PICs have a TRIS instruction to set the direction of ports
or pins.
This would make it impossible to use statements like:
  <b>'PORTA_direction = ALL_OUTPUT'</b>
<li>Some midrange PICs like 16f690, 16f887 have a register SSPMSK
which has the same memory address as the SSPADD register.
Which of both is accessed depends on the bit pattern in SSPCON_SSPM.
<li>Some PICs of the 18F series have several SFR pairs of which both
registers have the same address.
For example of the 18F65J50 ADCON0 and ANCON1 have both address FC2h.
The WDTCON_ADSHR bit determines which of a pair is accessed.
<li>Some 18Fs like the 18f44j11 have registers PMADDL/H with the same
address as PMOUTL/H.
Which of both is accessed depends on the mode of operation.
</ul>
For all these situation the device files contain pseudo variables to make it
possible to use the 'Non Memory Mapped Registers'
as if these were normal 'Special Function Registers',
for both read and write.
For example:
<ul>
<li>Even though a 16F509 has no addressable TRISA register,
you can still specify:
  <b>'pin_A5_direction = output'</b>
to make pin_A5 (alias of pin_GP5) an output pin.
<li>For PICs of which SSPMSK has the same address as SSPADD:
when accessing register SSPMSK the bits of SSPCON_SSPM will be temporary set
automatically to 0b1001 and restored afterwards.
<li>For PICs of which ANCON1 has the same address as ADCON0:
when register ANCON1 is accessed the WDTCON_ADSHR bit will be temporary set
automatically and reset afterwards.
<li>In case of PICs like the 18f44j11 the PMOUTL/H registers are declared as
normal SFRs, because either PMADDL/H or PMOUTL/H are used exclusively in
different modes of operation.
</ul>



<h3><a name="input_only_pins">Input-only pins</a></h3>
<p>The Jallib device files of the 18F-series and the extended midrange
families have their pins declared as 'expansion' of the LATx registers,
even when the pin is input-only and the corresponding bit in the LATx
register would not be active.
But when PORTx has just input-only pins the LATx register is not required
and may not be present (in the MPLAB .dev file).
And when LATx is absent the pins of PORTx cannot be declared as expansion of
the LATx register!
One such a situation is known and a solution is provided.

<p>Several PICs of the 18F-series and the extended midrange families
have their MCLR pin multiplexed with pin_E3.
This pin is useable as input-only pin when MCLR is set to 'internal'
via a configuration bit setting.
When pin_E3 is the only active pin of PORTE the LATE register is frequently
not present,
and therefore pin_E3 and its aliases are declared as expansion of the
PORTE register in stead of the LATE register
<i>even when the LATE register is present,
(which may be an error in the MPLAB .dev file)</i>.

<p>Note: For an input-only pin the corresponding bit in the TRISx
register may be inactive, or even the TRISx register may be absent.
In that case the Jallib device files will not contain a declaration of
the corresponding pin_direction.


<h2><a name="peripherals">Names of functions modules</a></h2>


<h3><a name="CCPregs">Names for registers and subfields of CCP modules</a></h3>
<p>There are CCP modules and Enhanced CCP modules.
The first is also called 'legacy' CPP modules in this document and elsewhere.
Most legacy CCP modules have registers names starting with CCP,
most registers of enhanced CCP modules start with ECCP.
The same is true for subfields of these registers.
However there are many deviations from these rules and contradictions
between MPLAB .dev files and the datasheets!

<p>Enhanced CCP modules can be used as legacy CCP modules,
in particular for PWM operations.
For this purpose a number aliases are added to the device files which
allow access of enhanced CCP registers and subfields with legacy names.
An example of this is the pwm_hardware library.
<p>The following aliases for enhanced CCP modules are declared:
<table>
<tr><th>field           <th>alias         <th>remarks          </tr>
<tr><td>ECCPxCON        <td>CCPxCON       <td>x in range 1..10 </tr>
<tr><td>ECCPxCON_EDCxB  <td>CCPxCON_DCxB  <td>bits*2           </tr>
<tr><td>ECCPxCON_ECCPxM <td>CCPxCON_CCPxM <td>bits*4           </tr>
<tr><td>ECCPRx          <td>CCPRx         <td>                 </tr>
<tr><td>ECCPRxH         <td>CCPRxH        <td>                 </tr>
<tr><td>ECCPRxL         <td>CCPRxL        <td>                 </tr>
</table>
<p>Extended midrange PICs (12/16F18/19xx) have only enhanced CCP modules
which have 'legacy' names.
Therefore no special naming is needed to use these as legacy CCP modules.
<p>For PICs with both an CCP1CON and a ECCP1CON register
(18f448,4480,458,4580,4585,4680,4682,4685)
to allow the enhanced CCP module to be used as second legacy CCP module
the following aliases are declared:
<table>
<tr><th>field           <th>alias         <th>remarks          </tr>
<tr><td>ECCP1CON        <td>CCP2CON       <td>                 </tr>
<tr><td>ECCP1CON_EDC1B  <td>CCP2CON_DC2B  <td>                 </tr>
<tr><td>ECCP1CON_ECCP1M <td>CCP2CON_CCP2M <td>                 </tr>
<tr><td>ECCPR1          <td>CCPR2         <td>                 </tr>
<tr><td>ECCPR1H         <td>CCPR2H        <td>                 </tr>
<tr><td>ECCPR1L         <td>CCPR2L        <td>                 </tr>
</table>
<br>Corresponding pins when called ECCP1 have an alias CCP1.

<p>Some PICs (16F91x,946, 18F2321,2480,2580,4321,4480,4580) have the
CCPxCON 2-bits subfield DCxB defined as 2 separate bits CCPxX and CCPxY,
other PICs (16F88x) have this field enumerated and defined as
DCxB1 and DCxB0.
For compatibility with most other PICs a 2 bits field CCPxCON_DCxB has
been added in the device files for these cases.


<h3><a name="ANSELregs">Names of ANSEL bits</a></h3>
<p>For the control of the ADC channel the ADC library has to set the
appropriate pin(s) to analog (input).
There are generally 3 methods used by the different PICs:
<ul>
<li>with the PCFG field of the ADCON1 register
<li>with the PCFG bits in ANCONx registers
<li>with bits of the ANSELx register(s)
</ul>
<p>The first two methods as covered by the ADC libraries,
this section is about the third method with ANSEL register(s).
There are a couple of issues with this method:
<ul>
<li>Pins with analog capability are not evenly and sequentially distributed
over the ports.
Sometimes channel numbers are not present and the numbering in the PORT
register is sometimes 'chaotic'.
<li>There is no direct relation between the number of the analog channel
(pin_ANx, x in the range 0..28) and the bit in the ANSEL register with which
the channel is controlled.
And the ANSEL registers are not uniformly named (e.g. the first register can
be ANSEL, ANSEL0, ANSELA, the second can be ANSELH, ANSEL1, ANSELB, etc.).
</ul>
<p>The first item is no problem when always referring to the logical pin
name pin_ANx (an alias of the physical pin name).
A solution for the second item has been found by declaring aliases for the
channel selection bits in ANSEL registers (name normalization).
In stead of enumerating the bits of all ANSELx registers individually, a
number of bit aliases 'JANSEL_ANSx' is declared, in which 'x' represents
the ADC channel and which point to the appropriate AN-pin.
<br>For example the declaration of the JANSEL bits of a 16F722 looks like:
<pre>
   var volatile byte   ANSELA            at  { 0x185 }
   var volatile bit    ANSELA_ANSA5      at  ANSELA : 5     -- pin_AN4 = pin_A5
   alias               JANSEL_ANS4       is  ANSELA_ANSA5
   var volatile bit    ANSELA_ANSA3      at  ANSELA : 3     -- pin_AN3 = pin_A3
   alias               JANSEL_ANS3       is  ANSELA_ANSA3
   var volatile bit    ANSELA_ANSA2      at  ANSELA : 2     -- pin_AN2 = pin_A2
   alias               JANSEL_ANS2       is  ANSELA_ANSA2
   var volatile bit    ANSELA_ANSA1      at  ANSELA : 1     -- pin_AN1 = pin_A1
   alias               JANSEL_ANS1       is  ANSELA_ANSA1
   var volatile bit    ANSELA_ANSA0      at  ANSELA : 0     -- pin_AN0 = pin_A0
   alias               JANSEL_ANS0       is  ANSELA_ANSA0
   -- -------------------------------------------------
   var volatile byte   ANSELB            at  { 0x186 }
   var volatile bit    ANSELB_ANSB5      at  ANSELB : 5     -- pin_AN13 = pin_B5
   alias               JANSEL_ANS13      is  ANSELB_ANSB5
   var volatile bit    ANSELB_ANSB4      at  ANSELB : 4     -- pin_AN11 = pin_B4
   alias               JANSEL_ANS11      is  ANSELB_ANSB4
   var volatile bit    ANSELB_ANSB3      at  ANSELB : 3     -- pin_AN9  = pin_B3
   alias               JANSEL_ANS9       is  ANSELB_ANSB3
   var volatile bit    ANSELB_ANSB2      at  ANSELB : 2     -- pin_AN8  = pin_B2
   alias               JANSEL_ANS8       is  ANSELB_ANSB2
   var volatile bit    ANSELB_ANSB1      at  ANSELB : 1     -- pin_AN10 = pin_B1
   alias               JANSEL_ANS10      is  ANSELB_ANSB1
   var volatile bit    ANSELB_ANSB0      at  ANSELB : 0     -- pin_AN12 = pin_B0
   alias               JANSEL_ANS12      is  ANSELB_ANSB0
</pre>
As you can see the JANSEL_ANSx numbering is not restricted to bits 0..7
of the first ANSEL register (whatever its name),
it is also used for channel numbers higher than 7 controlled by another
ANSEL register.
Note further that:
<ul>
<li>channels 0..3 are regularly sequenced on pin_A0..3
<li>channel 4 is on pin_A5 (pin_A4 is not an ADC pin)
<li>channels 5..7 are missing
<li>channels 8..13 are <b>ir</b>regularly sequenced on pin_B0..5
</ul>
<p>Other PICs, like for example the 18F43K22, have 28 ADC channels spread
over 5 ANSEL registers, also largely irregularly numbered.
For example pin_AN5..7 are controlled by ANSELE.
The declaration of JANSEL_ANS0..27 hides all these irregularities from the
ADC library.
<p>Another example, now for the 10F222:
<pre>
   var volatile byte   ADCON0           at  { 0x7 }
   var volatile bit    ADCON0_ANS1      at  ADCON0 : 7
   alias               JANSEL_ANS1      is  ADCON0_ANS1
   var volatile bit    ADCON0_ANS0      at  ADCON0 : 6
   alias               JANSEL_ANS0      is  ADCON0_ANS0
</pre>
In this case the channel selection bits are in register ADCON0
(the 10Fs have no ANSEL register), but the ADC library doesn't need
to know when it uses the JANSEL_ANSx alias.
<br><i>Note: in reality the channel selection of the 10F220/222 is
somewhat more complicated, but the ADC library takes care of that!</i>.


<h3><a name="ADCregs">Names of other ADC registers and subfields</a></h3>
<p>Names of registers and subfields of ADC modules have been normalized as follows:

<p>When the ADCONx_VCFG subfield is a multi-bit field it is declared
both as a multi-bit field ADCONx_VCFG and as enumerated bits
(ADCONx_VCFG0 and ADCONx_VCFG1).
Same for ADCONx_PVCFG and ADCONx_NVCFG.

<p>While most PICs with more than 8 ADC channels have a 4-bits or 5-bits
subfield ADCONx_CHS, some PICs have the channel selection bits scattered
over more than 1 subfield.
For example the 16F7x7s have a 3-bits CHS field plus a single CHS3 bit
to be able to support ADC channel 8 and up.
In this and similar cases a pseudo variable ADCONx_CHS has been declared
which takes care of the scattering of channel selection bits.
So an ADC library can always address the variable ADCONx_CHS as multibit
'binary' field, regardless if the bits are scattered over the register or not.

<p>A similar situation exists for the ADCS bits of ADCONx of some PICs.
For PICs which have their ADCS bits scattered over ADCON0 and ADCON1 a
pseudo-variable ADCON0_ADCS is added which takes care of setting the
proper bits.
In this way an ADC library can always address the variable ADCONx_ADCS as
single multibit field, regardless if the bits are scattered over registers
or not and regardless if it is a bit*2 or a bit*3 variable.

<p>The result of an Analog to Digital Conversion can be 8, 10 or 12 bits.
When a PIC supports only 8-bits ADC the result is always a byte: ADRES.
With higher resolutions 2 bytes are used: the high order bits are always
in ADRESH, the low order bits can be in ADRESL.
<br>Note: when both ADRESL and ADRES are present ADRES is a 16 bits variable.


<h3><a name="EEPROM">Names of EEPROM control registers</a></h3>
<p>Some elementary differences have to be taken into acount with respect to
reading and writing memory:
<ul>
<li>The unit of information of <b>data</b> memory (EEPROM) is always a byte
for all PICs, while for <b>program</b> memory it is a word: 12,14 or 16
bits, depending on the PIC type.
<li>The 18Fs have always byte-level access for both data and program memory.
The baseline and midrange have byte level access for data memory
access, but program memory is on word level.
</ul>


<h3><a name="EUSARTregs">Names of registers and subfields of [E]USART modules</a></h3>
<p>PICs can have zero, one or two USART modules, of which zero, one or both
can be 'extended' (EUSART) modules.
Compared to a 'legacy' USART an 'extended' USART has a BAUDCON
register and can use a 16 bits in stead of an 8-bits value for the
baudrate divisor,
allowing a more accurate baudrate setting, especially with high speeds.
<p>The names of USART related registers and -subfields are not particular
consistent in the MPLAB .dev files, so it is desired to normalize these.
And it would be convenient if serial libraries supporting a single serial
module could be used for the first USART of PICs with multiple USARTs.
These are the primary reasons for the following naming convention in the
Jallib device files:
<ul>
<li>for PICs with 1 USART:
  <ul>
  <li>no module number in the names
  </ul>
<li>for PICS with 2 USARTs:
  <ul>
  <li>first USART: Names without module number
  <li>second USART: Names with suffix '2'
  </ul>
</ul>
<p>The registers will be declared in the device files with their native name
as obtained from the MPLAB .dev files.
When the native name doesn't follow our convention an alias will be added.
<p>Application of these rules results in the following list of names:
<table>
<tr><th>only or first of 2 USARTs</th> <th>second of 2 USARTs       </th> </tr>
<tr><td>BAUDCON       </td>            <td>BAUDCON2                 </td> </tr>
<tr><td>IPR1_RCIP     </td>            <td>IPR3_RCIP2               </td> </tr>
<tr><td>IPR1_TXIP     </td>            <td>IPR3_TXIP2               </td> </tr>
<tr><td>PIE1_RCIE     </td>            <td>PIE3_RCIE2 or PIE4_PCIE2 </td> </tr>
<tr><td>PIE1_TXIE     </td>            <td>PIE3_TXIE2 or PIE4_TXIE2 </td> </tr>
<tr><td>PIR1_RCIF     </td>            <td>PIR3_RCIF2 or PIR4_RCIF2 </td> </tr>
<tr><td>PIR1_TXIF     </td>            <td>PIR3_TXIF2 or PIR4_TXIF2 </td> </tr>
<tr><td>RCREG         </td>            <td>RCREG2                   </td> </tr>
<tr><td>RCSTA         </td>            <td>RCSTA2                   </td> </tr>
<tr><td>SPBRGL (byte) </td>            <td>SPBRGL2 (byte)           </td> </tr>
<tr><td>SPBRGH (byte) </td>            <td>SPBRGH2 (byte)           </td> </tr>
<tr><td>TXREG         </td>            <td>TXREG2                   </td> </tr>
<tr><td>TXSTA         </td>            <td>TXSTA2                   </td> </tr>
</table>
<p>Notes:
<ul compact>
<li>BAUDCON and SPBGRH registers are only available with extended USARTs.
<li>Some PICs have a BAUDCTL register in stead of BAUDCON.
In that case the device files have an additional alias: BAUDCON,
and the bit fields of BAUDCTL have a BAUDCON alias too.
<li>There is no standard (yet) for PICs with more than 2 USARTs.
</ul>
<p>Serial libraries should follow these conventions.


<h3><a name="MSSPregs">Names of MSSP registers</a></h3>
<p>Like multiple USARTs, PICs can have multiple MSSP modules (for SPI, I2C).
For these modules a similar naming convention is used as for USART modules.
For the only or first module names without a module number will be used,
while for the second module the names will have a number '2'.
In this case the module number follows immediately the 'SSP' of the
name because there can be multiple OSCCON registers, which could cause
confusion.
<p>The registers will be declared in the device files with their native name
as obtained from the MPLAB .dev files.
when the native name doesn't follow our convention an alias will be added.
<p>Application of these rules results in the following list of names:
<table>
<tr><th>Only or first of 2 MSSP</th> <th>second of 2 MSSPs          </th> </tr>
<tr><td>IPR1_SSPIP   </td>           <td>IPR2_SSP2IP or IPR3_SSP2IP </td> </tr>
<tr><td>PIE1_SSPIE   </td>           <td>PIE2_SSP2IE or PIE3_SSP2IE </td> </tr>
<tr><td>PIR1_SSPIF   </td>           <td>PIR2_SSP2IF or PIR3_SSP2IF </td> </tr>
<tr><td>SSPADD       </td>           <td>SSP2ADD                    </td> </tr>
<tr><td>SSPBUF       </td>           <td>SSP2BUF                    </td> </tr>
<tr><td>SSPCON1      </td>           <td>SSP2CON1                   </td> </tr>
<tr><td>SSPCON2      </td>           <td>SSP2CON2                   </td> </tr>
<tr><td>SSPCON3      </td>           <td>SSP2CON3                   </td> </tr>
<tr><td>SSPMSK       </td>           <td>SSP2MSK                    </td> </tr>
<tr><td>SSPSTAT      </td>           <td>SSP2STAT                   </td> </tr>
</table>
<p>For the pins related to I2C and SPI the names have no suffix for the
first or only module and a '2' suffix for the second module.
<table>
<tr><th>Only or first of 2 MSSP</th> <th>second of 2 MSSPs        </th> </tr>
<tr><td>pin_SDA           </td> <td>pin_SDA2           </td> </tr>
<tr><td>pin_SDI           </td> <td>pin_SDI2           </td> </tr>
<tr><td>pin_SDO           </td> <td>pin_SDO2           </td> </tr>
<tr><td>pin_SCK           </td> <td>pin_SCK2           </td> </tr>
<tr><td>pin_SCL           </td> <td>pin_SCL2           </td> </tr>
<tr><td>pin_SDA_direction </td> <td>pin_SDA2_direction </td> </tr>
<tr><td>pin_SDI_direction </td> <td>pin_SDI2_direction </td> </tr>
<tr><td>pin_SDO_direction </td> <td>pin_SDO2_direction </td> </tr>
<tr><td>pin_SCK_direction </td> <td>pin_SCK2_direction </td> </tr>
<tr><td>pin_SCL_direction </td> <td>pin_SCL2_direction </td> </tr>
</table>


<h3><a name="TIMERregs">Names of Timer fields</a></h3>
<p>Some register subfields of timer control registers have inconsistent
names in the MPLAB .dev files.
<p>For these subfields the following naming convention has been chosen:
<ul>
<li>The interrupt bits of Timer 0 are declared as TMR0IE and TMR0IF
    for <b>all</b> PICs, even though some datasheets use the names
    T0IE and T0IF.
<li>Bit TxSYNC in TxCON registers is normalized to NTxSYNC for:
  <ul>
  <li>T1CON of baseline and midrange
  <li>T1CON, T3CON, T5CON and T7CON of 18F series.
  </ul>
<li>TxCON_TOUTPS is normalized to TxCON_TxOUTPS (x = timer number) for
    the 18Fs.
    Since the midrange PICs have only 1 timer with TOUTPS bit this name
    has been maintained for these PICs.
    Extended midrange PICs have T2CON, T4CON and T6CON and
    follow the same naming convention.
<li>A variable 'bit*4 PS' in T0CON is splitted in 'bit PSA' and 'bit*3 PS'
<li>Aliases are provided for Timer 0 related fields in OPTION_REG
    of baseline and midrange PICS to simulate the existence of a T0CON
    register - like there are T0CON, T1CON, T2CON, etc. registers
    with other PICs: T0CON_T0SE, T0CON_T0CS, T0CON_PSA and T0CON_T0PS.
<li>The extended midrange PICs have in OPTION_REG the bits TMR0CS1 and
    TMR0CS0 and a 2-bits prescaler TMR0PS.
    These have been given aliases bit*2 T0CON_T0CS and bit*2 T0CON_T0PS
    to be as much compatible as possible with the other midrange PICs.
</ul>


<h3><a name="RTCCregs">Names of RTCC registers</a></h3>
<p>For consistency with the ALRMCFG register and since the RTCPTR1 - and
RTCPTR0 bits of the RTCCFG register could be used as 2-bits binary field -
an additional field is declared:
<pre>
  var volatile  bit*2  RTCCFG_RTCPTR     at RTCCFG : 0
</pre>
Same for the RTSECSEL1 and RTSECSEL0 bits of PADCFG1:
<pre>
  var volatile  bit*2  PADCFG1_RTSECSEL  at PADCFG1 : 1
</pre>
For consistency the 2-bits ALRMCFG_ALRMPRT field has been enumerated:
<pre>
  var volatile  bit    ALRMCFG_ALRMPTR1  at ALRMCFG : 1
  var volatile  bit    ALRMCFG_ALRMPTR0  at ALRMCFG : 0
</pre>


<h3><a name="status_shadow">Subfields of STATUS_SHAD</a></h3>
<p>The shadow of the STATUS register (in the extended midrange PICs)
has its bits named like in the STATUS register:
<pre>
  STATUS_SHAD_Z
  STATUS_SHAD_DC
  STATUS_SHAD_C
</pre>


<h3><a name="miscregs">Miscellaneous remarks about names</a></h3>
<ul>
<li>The name PORTA (and a similar name for other ports) is used
    consistently, while previously PORT_A was a popular naming
    convention especially for PORT_A_low, PORT_A_high,
    PORT_A_direction, etc.
<li>For individual pins the convention 'pin_Ax' is used.
<li>Numerous minor naming inconsistences in the MPLAB .dev files
    are 'corrected'.
</ul>
When you hit compilation errors related to undefined names, scan the
device file of the specified target PIC to search for the Jallib name
of the registers and their subfields.


<h2><a name="shadowing">About Port Shadowing</a></h2>

<p>Port shadowing is a technique to prevent the Read-Modify-Write
('RMW') problem with I/O ports of PICmicro's.
This is a problem related to the hardware design.
Search the Internet for "PIC" and "read-modify-read" and you'll get many
hits to more or less interesting articles!
None of the explanations are repeated here.
And you don't absolutely need to understand the problem, since by using
the Jallib device files you won't face the problem when you follow some
simple rules and avoid a few pitfalls.

<p>With port shadowing for the baseline and midrange PICs
(10F, 12F, 16F) a byte variable is used as representative of the port
register, <b>for output</b> only.
This byte is frequently called 'shadow-register'.
When writing to a port or individual pin first the shadow register is
updated and then the whole byte is written to the port.

<p>The shadow registers are not declared as 'volatile', because the
shadowing procedures would occupy significantly more program memory.
The disadvantage of not declaring these as volatile is that the procedures
for shadowing are not re-entrant (not interrupt-proof).
This means that you should refrain from updating pins from both the mainline
and an interrupt routine.

<p>The 18F series and the newer extended midrange (XLP) PICs
have a special register for this purpose (LATx), and the device files use
these registers for output.

<p>In all cases reading is done from the port register itself!

<p>With the Jallib device files shadowing is automatic, as long
as you use the following names:
<pre>
   PORTx             -- all bits of port x
   PORTx_low         -- low order nibble of port x (bits 3..0)
   PORTx_high        -- high order nibble of port x (bits 7..4)
   pin_xy            -- single pin 'y' of port 'x'
   aliases of pin_xy
</pre>
(in which 'x' is a port-letter and 'y' a bit number).
<p>PORTx_low is read from or written to bits 3..0 of Portx,
PORTx_high is read from or written to bits 7..4 of Portx.

<p>At power on and reset all ports are in input mode.
It is recommended to initialise ports or individual pins
before switching these from input to output mode.


<h2><a name="osccal">Calibration of Internal Oscillator</a></h2>

<p>Some low end PICs have an uncalibrated internal oscillator,
but have been factory calibrated and contain the proper value for
OSCCAL in the highest word of code memory.
User programs can use it to calibrate the internal oscillator.
See also <a href="#highmem">INTOSC calibration</a>
<p>PIC programmers are supposed to preserve this high memory word.
When it has (accidentally) been erased or overwritten the factory provided
calibration value for OSCCAL is lost.
Not only that, due to the way this value is supposed to be loaded this
may lead to unpredictable behaviour of the PIC.


<h3>Baseline</h3>
<p>A number of baseline PICs
(10F2xx, several 12F5xx and 16F5xx)
have in their highest word of code memory a MOVLW instruction.
This instruction is executed automatically after a reset of the PIC and thus
the W register is loaded with the desired contents of OSCCAL
at power-on or after MCLR reset.
This may be ignored, but when your PIC application needs the frequency of
the internal oscillator to be accurate the OSCCAL register should be loaded
with the provided value.
For this a MOVWF OSCCAL instruction is required as first instruction
of the program, for example with:
<pre>
   asm  bank  movwf  0x5            -- store contents of W in OSCCAL
</pre>
Strictly speaking this needs not be the first instruction.
It may be preceded by other instructions as long as these do not modify the
W register!
<p>The compiler does not have an option to insert this instruction,
but the device files of these PICs do have the required instruction.
This has been introduced with revision 3185.
<p>The instructions (possibly including bank selection instructions)
are in the beginning of the device file to ensure that
no other instructions destroy the contents of the W register,
for example for the initialization of shadow registers.
Of course the user program should not have any instructions before the
include of the device file!


<h3>Midrange</h3>
<p>Some midrange PICs
(12F629/675, 16F630/676)
have in their highest word of code memory a RETLW instruction.
This allows the following method to be used to load OSCCAL with the proper
value.
<pre>
   asm  page  call   &lt;last-word-of-memory&gt;
   asm  bank  movwf  0x90     -- store contents of W in OSCCAL
</pre>
in which you have to specify for &lt;last-word-of-memory&gt; the address
of the highest word in program memory.
For example when your PIC has 1K words of program memory you should specify:
<pre>
   asm  page  call   0x3FF
</pre>
<p>These instructions may be inserted anywhere in your program.
It is not required to have these as very first instructions like with the
baseline PICs.
<p><b>This method is not without danger!</b>
When the high memory word is (accidentally) erased or overwritten
most likely it will not contain a RETLW instruction.
In that case the next instruction will be fetched, which is at address
0x0000 because of program counter wrap around.
Thus the PIC will probably enter an endless reset loop.
For this reason the device files of these PICs do not calibrate the internal
oscillator.
You could insert the asm instructions above in your program at your own risc!
<p>When you are not sure about the contents of the high word of code memory
or you want to play it safe, you can move a 'medium' value directly into
OSCCAL, for example with:
<pre>
   OSCCAL = 0x80
</pre>
See the datasheet for acceptable values: frequently the low order bits
must be zero.
<p>By varying the value in OSCCAL and measuring the effect you can
also fine tune the oscillator frequency to your needs.


<h2><a name="usbprov">Provisions for USB</a></h2>

<p>When the USB module of a PIC is activated, memory for data buffers is
needed.
For some PICs the address and size of data buffers is fixed, other PICs
offer more freedom.
The USB data buffers are specified in the Buffer Descriptor Table (BDT).
This BDT is at a fixed location in RAM but not the same for all PICs.
To help the USB library with finding the actual location of the BDT for a
specific PIC a constant <b>USB_BDT_ADDRESS</b> is defined indicating the
address of the Buffer Descriptor Table.


<h2><a name="ppsgroup">Peripheral Pin Selection</a></h2>

<p>A number of 18F PICs have a feature called Peripheral Pin Selection.
For the input and/or output of some modules a pin can be selected.
There are limitations in the choice of pins, but more importantly there a
many similarities and some differences between PICs.


<h3>Input Mapping</h3>
<p>Pin selection for an input function is controlled by assigning a
<b>pin number</b> to a specific register.
For example the Receive pin of ESUART2 is assigned to a specific pin
by putiing the pin number in RPINR16_RX2DT2 (x of pin_RPx).
The control registers for the all function are the same for all PICs.
Differences between PICs are only in the number of remappable pins.


<h3>Output Mapping</h3>
<p>Pin selection for an output function is controlled by assigning a
<b>function number</b> to a specific register.
For example to give pin_RP10 the Transmit function of ESUART2 the
function number of TX2/DT2 (number 5 for an 18F26J50) to RPOR10_RPOR.
Unfortunately not all function numbers are the same for all PICs.
For example the TX2/DT2 function has number 6 with the 18F27J53.

<p>Currently there are 2 groups of PICs:
<p>The differences between the groups are in numbers for output function,
as shown in the following table:
<table>
<tr><th>Func.<th> Group 1  <th> Group 2   </tr>
<tr><td>  0  <td> NULL     <td> NULL      </tr>
<tr><td>  1  <td> C1OUT    <td> C1OUT     </tr>
<tr><td>  2  <td> C2OUT    <td> C2OUT     </tr>
<tr><td>  3  <td>          <td> C3OUT     </tr>
<tr><td>  4  <td>          <td>           </tr>
<tr><td>  5  <td> TX2/CK2  <td>           </tr>
<tr><td>  6  <td> DT2      <td> TX2/CK2   </tr>
<tr><td>  7  <td>          <td> DT2       </tr>
<tr><td>  8  <td>          <td>           </tr>
<tr><td>  9  <td> SDO2     <td>           </tr>
<tr><td> 10  <td> SCK2     <td> SDO2      </tr>
<tr><td> 11  <td>          <td> SCK2      </tr>
<tr><td> 12  <td> SSDMA    <td> SSDMA     </tr>
<tr><td> 13  <td> ULPOUT   <td> ULPOUT    </tr>
<tr><td> 14  <td> CCP1/P1A <td> CCP1/P1A  </tr>
<tr><td> 15  <td> P1B      <td> P1B       </tr>
<tr><td> 16  <td> P1C      <td> P1C       </tr>
<tr><td> 17  <td> P1D      <td> P1D       </tr>
<tr><td> 18  <td> CCP2/P2A <td> CCP2/P2A  </tr>
<tr><td> 19  <td> P2B      <td> P2B       </tr>
<tr><td> 20  <td> P2C      <td> P2C       </tr>
<tr><td> 21  <td> P2D      <td> P2D       </tr>
<tr><td> 22  <td>          <td> CCP3/P3A  </tr>
<tr><td> 23  <td>          <td> P3B       </tr>
<tr><td> 24  <td>          <td> P3C       </tr>
<tr><td> 25  <td>          <td> P3D       </tr>
</table>
<p>The following table shows which PICs belong in which group:
<table>
<tr><th>PPS group <th>Datasheet <th>PICs </tr>
<tr><td>1         <td>39932     <td>18f24j11 18f25j11 18f26j11 18f44j11 18f45j11 18f46j11</tr>
<tr><td>          <td>39931     <td>18f24j50 18f25j50 18f26j50 18f44j50 18f45j50 18f46j50</tr>
<tr><td>2         <td>39974     <td>18f26j13 18f27j13 18f46j13 18f47j13</tr>
<tr><td>          <td>39964     <td>18f26j53 18f27j53 18f46j53 18f47j53</tr>
</table>
<p>The 'LF' variants these PICs are not listed, but belong to the same
groups!

<p>To simplify the use of the PPS feature every device file has been given a
constant 'PPS_GROUP' with the appropriate group number.
A symbolic name of the format 'PPS_x' is used, in which x is 0,1 or 2.
'PPS_0' means: this PIC does not support Peripheral Pin Selection.
The symbolic numbers are defined in constants_jallib.jal.
<p>With new PICS more groups may have to be introduced.


<h2><a name="fuses">Naming convention for configuration bit fields (fuses)</a></h2>


<h3>Pragma fuse_def</h3>
<p>The MPLAB .dev files contain a <b>keyword</b> for every configuration
bit or group of bits,
and a <b>description</b> of the possible bit settings.
Unfortunately not always the same keyword is used for essentially the same
configuration bit or bit-field, and the keyword is sometimes different from
the keyword in the datasheet, or is simply spelled wrongly!
The descriptions have an even larger variation and are sometimes very long.
<p>For use with Jal, in particular for the 'pragma fuse_def' declarations,
a consistent keyword (in JalV2 called 'opt') and single-word symbolic values
(in JalV2 called 'tag') are desired.
The Jallib 'standard' is described below.


<h3>Fuse_def keywords, synonyms and replaced words</h3>
<p>For all pragma fuse_defs a keyword and
a number of symbolic values are declared in the device files.
This section deals with the keywords, the next section with symbolic values.

<p>Every configuration word or byte is preceeded with a comment line
indicating its address in memory.
<br>The meaning of configuration bits can in most cases be found in the
DataSheet of the specific chip, in the section 'Special Features of the
CPU'.
This info can also be found in the Programming Specifications of the chip.
For convenience the MicroChip document numbers of the specific PIC are
mentioned in the heading of its device file.

<p>To minimize misunderstanding and confusion the description for every
keyword as found in the MPLAB .dev file is appended as comment on the
'pragma fuse_def' line.
The combination of memory address and description should unambiguously
identify which configuration bits are controlled by the keyword,
even though the name might be different from that in the datasheet.

<p>Where convenient and intuitive enough the keywords found in the MPLAB
.dev files are used.
But synonyms are eliminated and some apparent misspellings are
corrected.
Sometimes an arbitrary keyword is chosen.

<p>The list below shows examples of most deviations of keywords from MPLAB .dev files:

<table>
<tr><th> keyword   </th><th>replaces synonym(s) and typo(s)</th></tr>
<tr><th> ABW       </th><td>ADDRBW                </td></tr>
<tr><th> BBSIZ     </th><td>BBSIZ0                </td></tr>
<tr><th> BROWNOUT  </th><td>BODEN, BOREN, DSBOREN </td></tr>
<tr><th> BW        </th><td>DATABW                </td></tr>
<tr><th> CCP(x)MUX </th><td>CCP(x)MX              </td></tr>
<tr><th> CPD       </th><td>CPDF, CPSW            </td></tr>
<tr><th> CPx       </th><td>CP_x                  </td></tr>
<tr><th> DEBUG     </th><td>BACKBUG, BKBUG        </td></tr>
<tr><th> EBTRx     </th><td>EBTR_x, EBRTx (typo)  </td></tr>
<tr><th> ECCPMUX   </th><td>ECCPMX                </td></tr>
<tr><th> EXCLKMUX  </th><td>EXCLKMX               </td></tr>
<tr><th> FCMEN     </th><td>FSCM                  </td></tr>
<tr><th> FLTAMUX   </th><td>FLTAMX                </td></tr>
<tr><th> OSC       </th><td>FOSC                  </td></tr>
<tr><th> IOSCFS    </th><td>IOFSCS (typo)         </td></tr>
<tr><th> MCLR      </th><td>MCLRE                 </td></tr>
<tr><th> MSSPMASK  </th><td>MSSP7B_EN, MSSPMSK    </td></tr>
<tr><th> P2BMUX    </th><td>P2BMX                 </td></tr>
<tr><th> PMODE     </th><td>PM                    </td></tr>
<tr><th> PMPMUX    </th><td>PMPMX                 </td></tr>
<tr><th> PWM4MUX   </th><td>PWM4MX                </td></tr>
<tr><th> PWRTE     </th><td>PUT, PWRT, PWRTEN, NPWRTE, NPWRTEN </td></tr>
<tr><th> RTCOSC    </th><td>RTCSOSC               </td></tr>
<tr><th> SOSCSEL   </th><td>SOSCEL                </td></tr>
<tr><th> SSPMUX    </th><td>SSPMX                 </td></tr>
<tr><th> STVR      </th><td>STVREN                </td></tr>
<tr><th> T1OSCMUX  </th><td>T1OSCMX               </td></tr>
<tr><th> T3CMUX    </th><td>T3CMX                 </td></tr>
<tr><th> VOLTAGE   </th><td>BODENV, BOR4V, BORV   </td></tr>
<tr><th> WDT       </th><td>WDTEN                 </td></tr>
<tr><th> WRT       </th><td>WRT_ENABLE, WRTE      </td></tr>
<tr><th> WRTx      </th><td>WRT_x                 </td></tr>
</table>
Notes:
<ol>
<li>Keywords for pin multiplexing end in 'MUX', like CPPxMUX.
<li>Not all declared keywords in the MPLAB .dev files may be 'catched',
there may be some inconveniently (long) keywords left.
<li>When the compiler stalls over a fuse-def line a correction should be
applied.
If you encounter such an occasion please report it in the Jallib
discussion group at Google Groups.
</ol>


<h3>Fuse_def symbolic values</h3>
<p>As mentioned above the MPLAB .dev files contain frequently long and
descriptions with many variations of the same story.
Only for the oscillator specification alone the MPLAB .dev files contains
about 200 different descriptions!
But often the description is a single word like DISABLED or ACTIVE.

Multi-word descriptions have been reduced to a single word or at least a
single string (multiple words coupled by underscore characters).

<p>Like for the keywords also for the symbolic values many synonyms can be
found in the MPLAB .dev files.
These synonyms are eliminated to a large extent.
For example 'ENABLE' is often used even when the datasheet or MPLAB .dev
file specifies 'ON' or 'ACTIVE'.

<p>Below a set of 'normalized' pragma fuse_def:

<h4>Fuse_def  ADSEL  (ADC resolution)</h4>
<pre>
   B10                -- 10 bits
   B12                -- 12 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  ABW  (Address Bus Width)</h4>
<pre>
   B8                 -- 8 bits
   B16                -- 16 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  BBSIZ  (Boot Block Size)</h4>
<pre>
   W256               -- 256 words
   W512               -- 512 words
   W1K                -- 1024 words (1K words)
   W2K                -- 2048 words (2K words)
   W...               -- any other number of words
</pre>

<h4>Fuse_def  BG  (Band Gap)</h4>
<pre>
   ADJUST_NEG         -- negative adjustment
   ADJUST_POS         -- positive adjustment
   ...                -- other
</pre>

<h4>Fuse_def  BROWNOUT  (Brown Out detection)</h4>
<pre>
   ENABLED            -- BOD enabled, SBOREN disabled
   RUNONLY            -- BOD enabled in run, disabled in sleep
   CONTROL            -- SBOREN controls BOR function
   DISABLED           -- BOD and SBOREN disabled
</pre>
BROWNOUT is also used for Deep Sleep BrownOut (DSBOREN).

<h4>Fuse_def  BW  (Bus Width)</h4>
<pre>
   B8                 -- 8 bits
   B16                -- 16 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  CCPxMUX (multiplexing of pin of CCP module x)</h4>
<pre>
   pin_xy             -- assigned to pin y of PORTx
   pin_..             -- any other
   Enabled            -- ) see datasheet
   Disabled           -- )
</pre>
<br>When the multiplexing is also dependend of the microprocessor mode
(with some high end 18Fs) the pin for 'Microcontroller mode' is specified.
Of course in other modes another alternate pin will actually be configured!

<h4>Fuse_def  CP  (Code Protection)</h4>
<pre>
   ENABLED            -- Code memory read protection on
   DISABLED           -- Code mewmory read protection off
</pre>

<h4>Fuse_def  CPD  (Data Code Protection)</h4>
<pre>
   ENABLED            -- Data (EEPROM) memory read protection on
   DISABLED           -- Data (EEPROM) memory read protection off
</pre>

<h4>Fuse_def  CPUDIV  (CPU clock divisor)</h4>
Specifies the divisor value for the Primary Oscillator to obtain the desired
CPU frequency.
<pre>
   P1                 -- No divide *)
   P2                 -- CPU freq. is oscillator freq. divided by 2 *)
   P3                 -- CPU freq. is oscillator freq. divided by 3 *)
   P4                 -- CPU freq. is oscillator freq. divided by 4 *)
</pre>
<p><b> * </b>The symbolic values P1, P2, P3 and P4 have a one-to-one
relationship with the divisor value, but <b>only when PLL is not enabled</b>.
<br>When the PIC has a PLL module and PLL is enabled the output of the PLL
module (96 MHz) is used obtain the desired CPU frequency
and the corresponding divisor values may be different!
For example: when PLL is enabled with the 18f4550
P1 gives a divisor value 2, P2 divisor 3, P3 divisor 4, P4 divisor 6.
<br>See the Oscillator chapter in the datasheet for actual values.

<h4>Fuse_def  DSWDTOSC (Watchdog oscillator selections)</h4>
<pre>
   INTOSC             -- internal oscillator
   OSC                -- oscillator determined by OSC fuse_def
</pre>

<h4>Fuse_def  DSWDTPS  and WDTPS (Deep Sleep) WatchDog Timer PostScaler</h4>
<pre>
   P2G                -- 1 : 2G  (2 * 1073741824)
   P...
   P2M                -- 1 : 2M  (2 * 1048576)
   P...
   P2K                -- 1 : 2K  (2 * 1024)
   P..
   P2                 -- 1 : 2
</pre>

<h4>Fuse_def  EBTRB  (bootblock write protection)</h4>
<pre>
   ENABLED            -- boot block table read protected
   DISABLED           -- boot block may be table read
</pre>

<h4>Fuse_def  ECCPxMUX  (ECCP pin multiplexing)</h4>
<pre>
   pin_xy             -- pin y of portx is used
</pre>

<h4>Fuse_def  EMB (External memory bus width)</h4>
<pre>
   B12                -- 12 bits
   B16                -- 16 bits
   B20                -- 20 bit
   DISABLED           -- disabled
</pre>

<h4>Fuse_def ETHLED  (Ethernet LED)</h4>
<pre>
   ENABLED            -- Ethernet LED enabled
   DISABLED           -- Ethernet LED disabled
</pre>

<h4>Fuse_def EXCLKMUX (TMR1/T5CLKI assignement)</h4>
<pre>
   pin_xy             -- Clock input assigned to pin y of portx
</pre>

<h4>Fuse_def FLTAMUX (FLTA multiplexing)</h4>
<pre>
   pin_xy             -- pin y of portx is used
</pre>

<h4>Fuse_def FOSC2  (default/reset system clock select)</h4>
<pre>
   INTOSC             -- Internal oscillator
   OSC                -- Clock selected by OSC setting
</pre>

<h4>Fuse_def HFOFST  (...)</h4>
<pre>
   ENABLED            -- enable
   DISABLED           -- disabled
</pre>

<h4>Fuse_def IOSCFS  (Internal Oscillator Frequency Select)</h4>
<pre>
   F4MHZ              -- 4 MHz
   F8MHZ              -- 8 MHz
</pre>

<h4>Fuse_def LPT1OSC  (Low Power Timer1 Oscillator)</h4>
<pre>
   LOW_POWER          -- low power, low noise immunity
   HIGH_POWER         -- high power high noise immunity
</pre>

<h4>Fuse_def LVP  (Low Voltage Programming)</h4>
<pre>
   ENABLED            -- LVP on
   DISABLED           -- LVP off
</pre>

<h4>Fuse_def MCLR  (reset)</h4>
<pre>
   EXTERNAL           -- /MCLR pin enabled
   INTERNAL           -- /MCLR pin is digital I/O
</pre>

<h4>Fuse_def OSC  (oscillator)</h4>
<pre>
   LP                 -- Low Power crystal on OSC1,OSC2
   XT                 -- Crystal or Resonator on OSC1,OSC2
   HS                 -- High Speed Crystal or Resonator on OSC1,OSC2
   HS_PLL             -- HS with (hardware) PLL active
   EC_CLKOUT          -- External Clock (TTL) signal on OSC1, ClockOut on OSC2
   EC_NOCLKOUT        -- External Clock (TTL) signal on OSC1, OSC2 is I/O
   EC_CLKOUT_PLL      -- EC_CLKOUT with PLL active
   EC_NOCLKOUT_PLL    -- EC_NOCLKOUT with PLL active
   ECH_NOCLKOUT       -- external clock, high power mode
   ECL_NOCLKOUT       -- external clock, low power mode
   ECM_NOCLKOUT       -- external clock, medium power mode
   RC_CLKOUT          -- (external) Resistor/Capacitor oscillator on OSC1, ClockOut on OSC2
   RC_NOCLKOUT        -- (external) Resistor/Capacitor oscillator on OSC1, OSC2 is I/O
   INTOSC_CLKOUT      -- Internal oscillator, OSC1 is I/O, ClockOut on OSC2
   INTOSC_NOCLKOUT    -- Internal oscillator, OSC1 and OSC2 are I/O
</pre>
The first or only part is the oscillator type, the [optional] second part
indicates a related subfunction.
For example it may indicate if the OSC2 pin is CLKOUT or I/O, or if PLL is
active.
Several other keywords are possible, for example:
<ul compact>
<li>with USB
<li>with dual oscillator sources
<li>low, medium, and high power oscillators
</ul>
The datasheet will specify the possibilities, browse the device file for
the applicable keywords.

<h4>Fuse_def PLLDIV (PLL prescaler)</h4>
<pre>
   P1                 -- 1 : 1
   P..                -- etc
   P12                -- 1 : 12
</pre>

<h4>Fuse_def PLLEN (PLL enable)</h4>
<pre>
   P1                 -- 1 : 1
   P4                 -- 4 : 1
   F500KHZ            -- freq 500 KHz
   F16MHZ             -- freq 16 MHz
</pre>

<h4>Fuse_def PWM4MUX (PWM4 multiplexing)</h4>
<pre>
   pin_xy             -- PWM4 assigned to pin_y of portx
</pre>

<h4>Fuse_def PMODE (Extended memory bus)</h4>
<pre>
   B12                 -- extended microcontroller 12-bit
   B16                 -- extended microcontroller 16-bit
   B20                 -- extended microcontroller 20-bit
   EXT                 -- extended microcontroller
   MICROCONTROLLER     -- microcontroller
   MICROPROCESSOR      -- microprocessor
   MICROPROCESSOR_BOOT -- microprocessor with boot block
</pre>

<h4>Fuse_def PMPMUX (PMP multiplexing)</h4>
<pre>
   PORTx              -- PMP on PORTx and other ports
</pre>

<h4>Fuse_def PWRTE  (Power-up Timer Enable)</h4>
<pre>
   ENABLED            -- Power up timer enabled
   DISABLED           -- Power Up timer disabled
</pre>

<h4>Fuse_def RTCOSC  (RTC reference clock selection)</h4>
<pre>
   INTOSC             -- Internal oscillator
   T1OSC              -- Timer 1 oscillator
</pre>

<h4>Fuse_def SIGN (bulk erase)</h4>
<pre>
   NOT_CONDUCATED
   AREA_COMPLETE
</pre>

<h4>Fuse_def SSPMUX (SPI I/O multiplexing)</h4>
<pre>
   pin_xy             -- SPI active on pin y of portx
   DISABLED           -- SPI not assigned
</pre>

<h4>Fuse_def T1OSCMUX  (Timer 1 multiplexing)</h4>
<pre>
   pin_A6_A7          -- pin_A6 and pin_A7 are used
   pin_B2_B3          -- pin_B2 and pin_B3 are used
</pre>

<h4>Fuse_def USBDIV  (USB clock selection)</h4>
<pre>
   P1                 -- no divide
   P2                 -- divide by 2
</pre>

<h4>Fuse_def USBPLL  (USB PLL source)</h4>
<pre>
   F48MHZ             -- from 96MHZ PLL / 2
   OSC                -- from Oscillator
</pre>

<h4>Fuse_def VCAPEN  (Voltage regulator capacitor pin)</h4>
<pre>
   DISABLED
   pin_A0
   <i>...  etc (other pins which could be assigned</i>
</pre>

<h4>Fuse_def VOLTAGE  (Brown out voltage)</h4>
<pre>
   V20                -- 2.0 Volt
   V27                -- 2.7 Volt
   V42                -- 4.0 Volt
   V45                -- 4.5 Volt
   <i>...  etc (whatever voltages are applicable)</i>
</pre>

<h4>Fuse_def WAIT  (Wait ...)</h4>
<pre>
   ENABLED            -- synchronous
   DISABLED           -- asynchronous
</pre>

<h4>Fuse_def WDT  (WatchDog Timer)</h4>
<pre>
   ENABLED            -- Watchdog enabled
   DISABLED           -- Watchdog disabled
   HARDWARE           -- Watchdog enabled in hardware, SWDTEN bit disabled
   CONTROL            -- Software controlled by SWDTEN bit
   RUNNING            -- Enabled while running, disabled in sleep.
</pre>

<h4>Fuse_def WDTCS  (WatchDog Timer Clock Select)</h4>
<pre>
   STANDARD
   LOW_POWER
</pre>

<h4>Fuse_def WPEND  (Write protect area)</h4>
<pre>
   P0_WPFP            -- from page 0 to write protect page
   PWPFD_END          -- from write protect page to end of memory
</pre>

<h4>Fuse_def WPFP (Write Protect Flash Page)</h4>
<pre>
   P0                 -- Write protect flash page 0
   P1                 -- Write protect flash page 1
   P..                -- etc
   P127               -- Write protect flash page 127
</pre>

<h4>Fuse_def WRT  (Program Memory Self-Write Protection)</h4>
<pre>
   NO_PROTECTION      -- All program memory writable
   ALL_PROTECTED      -- Writing of program memory prohibited
   Rxxxx_yyyy         -- Protected memory range
                      -- <i>(only specific ranges can be write protected)</i>
</pre>

<h4>Fuse_def WRTx (Write Protection of Table/Region)</h4>
<pre>
   ENABLED            -- table/region is not write protected
   DISABLED           -- table/region is write protected
</pre>

Notes:
<ol>
<li>The list above in not exhaustive there may be others,
depending on the features of the specific PICmicro.
To conform to a compiler requirement names must start with a letter or
an underscore and may not contain special characters and spaces.
Multi-word descriptions as found in the MPLAB .dev files (other than those
listed above) have been transformed to a keyword as follows:
<ul>
<li>special characters and spaces are translated to underscores
<li>leading and trailing underscores are removed
<li>multiple consecutive underscores are reduced to a single underscore
<li>when the first character is a digit a letter is added as prefix,
which can be 'R' for range, 'F' for frequency, 'B' for number of bits,
or 'N' otherwise.
</ul>
<li>As an example of an address range specification for PICs with the
possibility to protect certain code memory areas you may have to specify:
<pre>
pragma target CP R0F00_0FFF
</pre>
<li>The device file contains a specification for the fuses array.
how many words or bytes and their corresponding memory addresses.
Also a default fuse setting is specified, which may or may not be
suitable for your application!
<b>Never trust defaults!</b>
</ol>


<h2>Alternate ways to specify configuration bits</h2>
<p>When you find the specification of fuse_def inconvenient or
you want to specify the bits one-by-one by yourself, the compiler
allows you to do so.
For example for the PIC16F690 the following group of statements:
<pre>
   pragma target OSC       HS
   pragma target WDT       Disabled
   pragma target PWRTE     Enabled
   pragma target MCLR      External
   pragma target CP        Disabled
   pragma target CPD       Disabled
   pragma target BROWNOUT  Enabled
   pragma target IESO      Disabled
   pragma target FCMEN     Disabled
</pre>
is equivalent with:
<pre>
   pragma target fuses   0b11_0011_1110_0010
</pre>

<p>PICs with 16-bits core (the 18F series) have such a large set and
variety of configuration bits that explicit specification is probably
the best way to make sure all configuration bits are set correctly for
your program.
As an example see the following list for a simple blink-a-led program
with an 18F242.
<pre>
   pragma  target fuses 0  0b0000_0000       -- (n/a)
   pragma  target fuses 1  0b0010_0010       -- not switchable, HS osc, no PLL
   pragma  target fuses 2  0b0000_0001       -- BOR disabled, PWTR disabled
   pragma  target fuses 3  0b0000_0000       -- watchdog disabled
   pragma  target fuses 4  0b0000_0000       -- (n/a)
   pragma  target fuses 5  0b0000_0001       -- CCP2 on RC1
   pragma  target fuses 6  0b1000_0001       -- no bg debug, no LVP, STVREN
   pragma  target fuses 7  0b0000_0000       -- (n/a)
   pragma  target fuses 8  0b0000_1111       -- no code protection
   pragma  target fuses 9  0b1100_0000       -- no data protection
   pragma  target fuses 10 0b0000_1111       -- no code write protection
   pragma  target fuses 11 0b1110_0000       -- no other write protection
   pragma  target fuses 12 0b0000_1111       -- no table read protection
   pragma  target fuses 13 0b0100_0000       -- no boot block write protect
</pre>
(n/a) means not applicable to this specific PIC, but may be specified
(as all zeroes).

<p>Notes:
<ol>
<li>When a PIC has multiple configuration words or bytes the index value
of the word or byte must be specified between 'fuses' and the value.
</ol>


<h3><a name="cfg_defaults">Default Configuration Bits Settings</a></h3>
<p>The device files contain both the address as well as default settings of
configuration bits.
For the baseline and midrange this is units of words (16 bits)
(of which only 12 or 14 bits are available),
in most cases a single word, but it can be multiple words.
For the 18F series the configuration bits are in a (varying) number of bytes.
<p>The specified defaults are those supposed to be found in the datasheets,
but these derived from the MPLAB .dev files.
Unfortunately these two sources do not always match!
When your PIC programmer detects a verifycation error with the configuration
bits, this is probably caused by a wrong default in the device file.
Suspect especially the setting of 'reserved' or 'unused' bits!
The rules for unused configuration bits are:
<ul>
<li>Baseline and (extended) midrange: '0'
<li>18F series: '1'
</ul>
<p>But there are exceptions which may not be caught in the device files!


<hr>


<h2><a name="compiler">Data Memory and Compiler requirements</a></h2>

<p>The compiler - at the moment of this writing version 2.4p - has a
number of requirements for device specifications.
The most important from a user perspective are the following:


<h3><a name="memdata">Data memory</a></h3>
<p>The device files specify the amount of available data memory (RAM)
for variables in bytes with <b>pragma data</b>.
<br>The log of a compilation contains a line like:
<pre>
 Data area: 250 of 368 used
</pre>
for a specific PIC and program.
The first number is the amount of bytes actually used,
the last number is the total amount of data memory
available to a user program and libraries.


<h3><a name="membanks">Memory banks</a></h3>
<p>The compiler supports for the baseline and classic midrange PICs a
maximum of 4 memory banks.
PICs with more than 4 memory banks are supported, but only for the first 4
banks of data memory.
Only few PICs have more than 4 banks (example: 16f59)!


<h3><a name="highmem">INTOSC calibration</a></h3>
<p>Baseline and some midrange PICs have in the last word of code memory
an instruction for calibration of the internal oscillator.
This is a reserved word and not counted in the amount of available
code memory.
See also <a href="#osccal">Calibration of Internal Oscillator</a>.


<h3><a name="memusb">Data memory for PICs with USB module</a></h3>
This is data memory sometimes dedicated to the USB module.
Sometimes it can be used as regular data memory by the user program,
but only when the USB module is inactive,
and sometimes it can be shared between USB module and user program.
So the amount of available data memory as specified in the device file
can be smaller than the total amount of memory specified in the
datasheet due to reservation by the USB module.


<h3><a name="memshare">Shared Memory</a></h3>
<p>The compiler recognises another pragma for data memory:
<b>pragma shared</b>.

<p>For the compiler 'shared' means:
<ul compact>
<li>For baseline and midrange PICs: the part of data memory which is
accessible in all banks regardless the settings of the bank selection bits
(STATUS_RPx, or similar bits in FSR).
Note: Memory which is mirrored in other bank(s), but not in all banks,
is in this context not shared memory!
<li>For the extended midrange and 18F PICs: GPR-memory in the access bank.
</ul>

<p>Shared memory is used <b>for specific variables used by the compiler</b>:
<dl>
<dt><b>_pic_isr_w</b>
<dd>A byte variable used for saving the W register with interrupts.
<br>This variable is only needed for baseline and midrange PICs
(core 12 and 14).
<br><i>It is not required for PICs without interrupt support (like 10f20x),
but the current device files still declare it for these PICs.
However unused variables are removed by the compiler!</i>
<dt><b>_pic_accum</b>
<dd>A byte variable used for saving the W register with multi-byte additions
and subtractions when the two involved variables are in different memory banks,
and for sign extensions of signed variables (adding sbyte to sword, etc.).
<dt><b>Shadowing bytes</b>
<dd>Bytes for port and other register shadowing
(baseline and midrange PICs only, and when enough shared memory available!).
</dl>

<p>Shared memory can be used for other variables as well
by explicitly assigning it an address with 'at &lt;address&gt;',
whereby &lt;address&gt; must be in the shared memory region.
Remember that device files allocate shared memory!
Do not allocate the same addresses as already assigned by te device file.
<br>By using this feature you take over part of memory management of the
compiler at your own risk!

<p>With most PICs only part of data memory shared.
Some midrange PICs have all data memory memory shared,
some others have no shared memory.
There is no problem with 'all shared memory', but with 'no shared memory'
the memory for the compiler required variables is declared as 'shared' even
though it is in fact unshared memory!
In this case the locations with the same (7-bits) offset in other banks are
reserved (excluded from the available data memory for user variables).
However this is only partly a solution.
It avoids problems with interrupt handlers (which use _pic_isr_w),
but it does not completely avoid problems with calculations with multi-byte
variables (word, dword, etc., which use _pic_accum) when the variables
are in different banks.
<br>Examples: <b>16F73 and 16F74. With these PICs it is not safe for
programs to perform calculations with multi-byte variables!</b>.


<h3><a name="analog">Analog modules</a></h3>
<p>(to be done)

<hr>


<h2><a name="compat">Compatibility and Miscellaneous Remarks</a></h2>

<p>These device files are part of the central JalV2 repository 'Jallib'
(http://jallib.googlecode.com).
Other libraries of Jallib have been or are being converted to use the names
in these device files.
You are strongly recommended to use only this combination of include files.
Using these device files in combination with other libraries may cause
problems, especially with libraries for the old (pre JalV2) compiler.

<ul>

<li>The naming convention of ports and subfields maybe different, you may
have to convert the other libraries.

<li>Bank switching functions are not needed with JalV2 and do not appear in
the device files.
This may cause compile-time errors when using programs or libraries which
still use these procedures.
You must remove these bank switching functions from your programs and
libraries!

<li>The device specific include files are generated from the MPLAB .dev
files.
This may cause confusion or even conflicts because the register and bit
names are not always identical to those in the datasheets!
Apart from that, MPLAB is not errorfree, consequently include files generated
from this source cannot expected to be errorfree either!

<li>The device files contain some information for specific function
libraries to make life of function library builders easier.
For example a constant 'ADC_GROUP' is declared and assigned a value.
This value can be used by ADC libraries to handle groups of PICs
similarly and groups of other PICs differently.
This grouping is inspired by the Microchip MCC18 compiler.

</ul>

<p>Note: With Jallib version 0.7 a number of constants, formerly
declared in each device file is moved to a file 'constants_jallib.jal'.
This file is included by chipdef_jallib.jal (which is on its turn
included by every device file).
Don't worry about memory occupation: unused constants are removed by the
compiler automatically and don't occupy memory!



<!- ---------------------------------------------------------------------- -->
<hr>

<h1><a name="gen">4. Generating device files</a></h1>


<h2><a name="genproc">The process</a></h2>
<p>The device files are generated by transforming MPLAB files with a script
'dev2jal.cmd' in the /Jallib/tools directory.
The script is developed and executed with 'classic' Rexx as standardly delivered
with eComStation (OS/2).
To run it:
<ul>
<li>Start a commandline session ('command prompt')
<li>Go to the directory k:/Jallib/Tools
<li>Type: dev2jal test
</ul>
<p>Notes:
<ol>
<li>The dev2jal script expects both MPLAB and a local copy of Jallib
    installed on drive K.
    The script contains comments with instructions for possible changes in
    the script to run it on a different system configuration.
    This concerns only a few variables in the top of the script file.
<li>The 'test' commandline argument will put the device files in a 'test'
    subdirectory of the current directory.
</ol>

<p>The dev2jal script can be executed on other systems (Linux, Windows)
when a compatible Rexx interpreter is installed.
The free 'Regina Rexx' has proven to do fine for this script
(tested under Windows XP and Windows 7).
For more information about Regina Rexx see:
<ul>
<li>http://regina-rexx.sourceforge.net/index.html
</ul>
<p>Download and install the package (latest version 3.5) when you want to
run the script on a non-eComStation system.
Probably the easiest way to run the script is:
<ul>
<li>Copy /jallib/tools/dev2jal.cmd to the directory where you installed
Regina Rexx.
<li>Make the necessary changes in the script.
<li>Start a CommandLine session ('command prompt' / 'MS-DOS prompt' / 'terminal').
<li>Go to the directory with Regina Rexx.
<li>Enter the command: regina dev2jal.cmd test
</ul>
The generated device files will be in subdirectory 'test' (./test).


<h2><a name="gennewds">To do with new datasheets</a></h2>
<p>Generally MPLAB contains .dev files of PICs of which the datasheet is not
yet available.
The dev2jal script does not generate device files when the datasheet number
is (yet) unknown.
When a datasheet becomes available the following actions are needed to
generate device files (by 'manual' editing the involved tools files):
<ul>
<li>Make a new entry in the file 'datasheet.list' in the jallib tools
directory for each new Datasheet or Programming Specifications.
<li>Make a new entry or update an existing entry in the file
'devicespecific.json' in the tools directory for each of the PICs described
in the new datasheet.
An entry may contain the following elements:
<table>
<tr><th>Keyword</th>
    <th>Description</th>
    <th>Format</th>
    <th>Remarks</th>
    </tr>
<tr><td>DATASHEET</td>
    <td>Datasheet number</td>
    <td>5 digits</td>
    <td>Mandatory (otherwise no device files will be produced)</td>
</tr>
<tr><td>PGMSPEC</td>
    <td>Programming Specifications number</td>
    <td>5 digits</td>
    <td>Optional, no default</td>
</tr>
<tr><td>NONSHAREDDATA</td>
    <td>Range of unshared data memory (RAM)</td>
    <td>0x...-0x...[,0x...-0x...,etc]</td>
    <td>Mandatory, may be multiple ranges.
        Info to be obtained from datasheet or .lkr file</td>
</tr>
<tr><td>SHAREDDATA</td>
    <td>Range of shared data memory (RAM)</td>
    <td>0x...-0x...</td>
    <td>Mandatory.
        Info to be obtained from datasheet or .lkr file</td>
</tr>
<tr><td>ADCGROUP</td>
    <td>Analog-to-Digital group number</td>
    <td>ADC_V...</td>
    <td>Optional, default 0 (no ADC module present)</td>
    </tr>
<tr><td>ADCMAXRESOLUTION</td>
    <td>Analog-to-Digital resolution (# bits)</td>
    <td>0, 8, 10, 12</td>
    <td>Optional, default 10 (8 without ADRESH)</td>
    </tr>
<tr><td>FUSESDEFAULT</td>
    <td>Default configuration bits contents</td>
    <td>hexdecimal digits</td>
    <td>Optional, default from .dev file</td>
</tr>
<tr><td>PPSGROUP</td>
    <td>Peripheral Pin Selection group</td>
    <td>PPS_. (1 or 2)</td>
    <td>Optional, default PPS_0</td>
</tr>
</table>
<p>See for more details of the specifications the related sections in this
document and the comments in the Dev2jal script.
The usual way to make new entries: copy an existing entry and
modify the field contents according to the information in the datasheet
or in this document.
<li>Make a new entry or update an existing entry in the file 'pinmap.py' for
each of the PICs described in the new datasheet.
In most cases the datasheet contains a table 'Pinout I/O descriptions' or
'Pin allocation' with the required information to define aliases.
<li>Run the python script extract_pininfos.py to obtain an up-to-date
pinmap_pinsuffix.json and some other tools files.
<li>The dev2jal script may have to be adapted for new device files.
For example the assigment of pin_ANx (JANSEL) may have to be enhanced
(the procedure ansel2j in the dev2jal script).
<li>Now run the Rexx script dev2jal.cmd with the TEST option to generate a
new set of device files.
<li>Run the Rexx blink-a-led script with TEST option to verify all device
files and to generate blink samples.
<li>Run the script 'createdswikis' with TEST option to update datasheet
wikis.
</ul>
<p>Re-iterate these actions (the whole set or parts of it) until you are
satisfied and everything is OK.
<p>
<ul>
<li>Run the dev2jal.cmd script with the 'PROD' option,
SVN-propset keywords (svn propset svn:keywords Revision <device>.jal) of the
new device files,
SVN-add the device files
and commit these and other changed files in the tools and wiki
directories.
<li>Run the blink-a-led script with PROD option, SVN_propset and SVN-add any
new blink samples and commit these.
<li>Run the Rexx script 'createdswikis.cmd' to generate up-to-date wiki
files related to datasheets.
Note: This script needs to be run after new device files have been generated
because it considers only 'existing' Jallib device files.
<li>Update CHANGELOG and TORELEASE when relevant.
Note: TORELEASE may contain only device files and blink samples when at
least one PIC of a group described in the same datasheet has actually been
tested with good results.
</ul>


<h2><a name="genmplab">To do with a new release of MPLAB</a></h2>
<p>The dev2jal.cmd script contains several device specific 'adaptations' to make
the device files suitable for Jallib.
Most of these are mentioned in chapter 3 of this document.
When generating Jallib device files after a fresh install of MPLAB
in addition to the 'automatic' corrections some 'manual' editing is required.
These are mainly corrections of errors or omissions in the MPLAB .dev files,
which may have been corrected by Microchip from one to the next version of MPLAB!
<p>A Rexx script 'mplabclean' is available to take care of these changes in
stead of having to make the changes by manual editing.
However this script replaces whole lines and relies on the <b>exact</b> contents
of lines to replace in the .dev files.
From one version of MPlab to another line contents may change and
consequently the script may not change a line anymore or replaces different
lines!
A warning will be displayed when the number of lines replaced does not match
the expected number.
<ul>
<li>10F200,202,204,206
    <br>Remove Config 'OSC' field
<li>12F510
    <br>Enumerate individual bits for GPIO_GP5..0
    <br>Rename IOSCFS values: Enabled -> 8MHz and Disabled -> 4MHz
<li>12F519
    <br>Rename TRISGPIO -> TRISIO and bits TRISGPIOx to TRISIOx
<li>12F520, 12F529T39A, 12F529T48A
    <br>Rename PORTB to GPIO and individual bits RBx to GPx.
    <br>Rename TRISB to TRISIO and individual bits TRISBx to TRISIOx
<li>16F506,526
    <br>Enumerate individual bits of PORTB and PORTC.
<li>16F570
    <br>Enumerate individual biots of PORTA, PORTB and PORTC.
<li>16F627
    <br>Remove second option (value=0x2800) from CP cfgbits.
<li>16F87
    <br>Rename CCPMX -> CCP1MUX, and leave in descriptions only RB0 and RB3
<li>16LF1902
    <br>Correct devid: 1C00
<li>16LF1903
    <br>Correct devid: 1C20
<li>16LF1904/6/7
    <br>Add (activate) TRISE3 bit in TRISE register
<li>18F1230/1330:
    <br>Fuses ICPRT: Add value=0x8 with 'ICPORT Enabled'
<li>18F13K50,14K50 and LF-variants
    <br>Add LATA3,1,0 and TRISA3,1,0 when missing.
    <br>Check default fuse settings for CPUDIV and PLL (should be all 1:1)
<li>18F24K50,25K50
    <br>Add line with "Enabled" mask for ICPRT fusedef.
<li>18F66j16
    <br>Make ACQT bits in ADCON1 a 3 bits wide variable (not enumerated).
</ul>

<p>When there are new device files which are not in Jallib yet then before
running the dev2jal script you may have to perform the actions described
above in the section 'To do when new datasheets become available'.

<p>Now run the dev2jal script with the 'TEST' option, redirect the output to
a file and check this file for errors and warnings which need attention.
This output will normally contain of 1100 to 1200 lines,
which may sound a lot, but about 500 lines are for progress indication and
contain only the name of the PIC!
Of the remaining lines most warnings can be ignored, like:
<ul>
<li>'No "pin_ANx" alias in pinmap'
    <br>PICs with analog input modules may have 'active' bits
    in control registers like ANSEL, but no corresponding pin.
<li>'Duplicate keyword for fuse_def xxxxx (.....)'
    <br>Frequently there is more than one bit combination to disable
    or enable a configurable function.
    The device files decalre just one of these and reports other
    combinations as duplicate.
<li>'Possibly unbalanced enabled/disabled keywords for fuse_def xxx'
    <br>Frequently there are more bit combinations to enable than to
    disable (or vice versa) a configurable function.
</ul>
But of sourse warnings are not for nothing: check before release!

<p>The following corrective actions may be required:
<ul>
<li>Add an entry for each new PIC in the file devicespecific.json with the
    appropriate parameter values.
    Check for shared and unshared memory conventions of JalV2!
    Use the Memory organisation of the datasheet or the .lkr file
    of the MPASM SUITE to obtain the available memory.
<li>Add support for unrecognised Fuse_Def keywords to the dev2jal script.
<li>Probably the script file 'fusedefmap.cmd' needs to be updated
    because of new or changed descriptions of oscillator settings.
    And after an update the 'extract_pininfo.py' must be run to
    generate an up to date pinmap_pinsuffix.json.
<li>Maybe some corrections have to be applied to the dev2jal script
    when new PICs have exceptions not covered yet,
    for example JANSEL numbering (in procedure ansel2j)
<li>Visually check the new device files for irregularities.
    Use a file compare program (e.g. Kdiff3) to reveal differences
    between the new and current device files.
    When needed apply changes to the script and/or data files.
</ul>


</body>
</html>
