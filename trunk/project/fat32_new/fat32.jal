-- Title: FAT32 library for reading fat32 filesystem (beta version)
-- Author: Matthew Schinkel, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4k
-- Revision: $Revision$
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this library reads files & folders from a fat32 formatted media
--              such as sd cards & hard disks. BETA VERSION!
--
-- Sources:
-- http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
-- http://www.pjrc.com/tech/8051/ide/fat32.html
-- http://en.wikipedia.org/wiki/File_Allocation_Table
--
-- Notes:
-- This lib does not create filename's on fat32 partitions, although it may
-- in the future. Please see this article http://www.desktoplinux.com/news/NS4980952387.html?kc=rss
-- before you think about implementing writing of filenames into your project.
--
-- some of the following may not be correct in this beta version
--
-- "file location list info"
-- choose max number of files, choose highest entry address (filename's address).
-- eg. chosen -> FAT32_ENTRIES_MAX = 1, FAT32_FILES_MAX = 30 and there are 3 files A, B & C all in c:\
-- File A is in sector 0, entry 6. file B is in sector 4, entry 2. file C is in sector 50, entry 2.
-- file A is entry address 0*16 + 6 = 6, file B is entry address 4*16 + 2 = 64, file C is entry address 50*16 + 2 = 802
-- therefore, file C is out of range and will not be accessable due to fragmentation of the directory structure.
-- memory space required is byte*1 times 30 = 30bytes
-- the theoretical max number of files for this config is 256 if
-- there have been no deleted files and all names are short filenames.
-- if you choose FAT32_ENTRIES_MAX = 2 you will use 2 times 30 = 60bytes and the
-- theoretical max number of files for this config is 65535
--
--     --here's an example:
--     ;const byte FAT32_ENTRIES_MAX = 1     -- highest file entry address can be 256
--     const byte FAT32_ENTRIES_MAX = 2      -- highest file entry address can be 65535
--     ;var byte*FAT32_ENTRIES_MAX fat32_entry_location[FAT32_FILES_MAX] -- we will use large_array library instead
--
-- Default uses internal memory for file location list. You may add an
-- external memory source if you want to have a large amount
-- of files in a directory. see the sample file

-- known bugs:
-- must get rid of create_dword procedure

------- GENERAL SETTINGS & VARS -------

-- vars you can read info from
var dword fat32_file_size              -- holds file size after file_read_info()
var byte  fat32_file_extension[3]      -- holds file extension after file_read_info()
var word  fat32_dir_file_count         -- number of files in current directory

var dword fat32_root_dir               -- sector location of the root dir
var volatile dword fat32_current_dir_location -- sector location of last dir read
var dword fat32_fat_begin              -- the location of the file alocation table for current partition
var byte  fat32_sectors_per_cluster    -- the number of sectors per cluster, usually 8
var dword fat32_root_dir_first_cluster -- the location of the root dir's first cluster, should be 2
var dword fat32_file_location          -- holds file location after file_read_info()
var dword fat32_cluster_begin          -- the location of the beginning of clusters (where files & folders data is)
var bit fat32_init_ok = FALSE          -- tells you if fat32 initalized ok or not.

-- Create file fat32_attribute variables
var byte fat32_attrib
var bit fat32_is_read_only at fat32_attrib : 0
var bit fat32_is_hidden at fat32_attrib    : 1
var bit fat32_is_system at fat32_attrib    : 2
var bit fat32_is_volume_id at fat32_attrib : 3
var bit fat32_is_directory at fat32_attrib : 4
var bit fat32_is_archive at fat32_attrib   : 5

-- filter file attributes
var byte fat32_attrib_filter = 0 -- default is do not filter any file attributes
var bit fat32_filter_is_read_only at fat32_attrib_filter : 0
var bit fat32_filter_is_hidden at fat32_attrib_filter    : 1
var bit fat32_filter_is_system at fat32_attrib_filter    : 2
var bit fat32_filter_is_volume_id at fat32_attrib_filter : 3
var bit fat32_filter_is_directory at fat32_attrib_filter : 4
var bit fat32_filter_is_archive at fat32_attrib_filter   : 5
-- move these filters to your your main program then modify there values.
-- filters out files with unwanted file types
;fat32_filter_is_read_only  = FALSE
;fat32_filter_is_hidden     = FALSE
;fat32_filter_is_system     = FALSE
;fat32_filter_is_volume_id  = FALSE
;fat32_filter_is_directory  = FALSE
;fat32_filter_is_archive    = FALSE

-- other intarnal vars
var byte*3 _fat32_file_sector_count    -- a sector counter
var word   _fat32_file_byte_count      -- a byte counter within a sector
var word   _fat32_file_fragment_number -- the fragment number being used

-- data media selection
if (DATA_MEDIA == PATA_HARD_DISK) then
   -- hard disk procedures
   alias fat32_start_read is pata_hd_start_read              -- get hard disk ready for reading
   alias fat32_stop_read is pata_hd_stop_read                -- tell hard disk we are done reading
   alias fat32_start_write is pata_hd_start_write            -- tell hard disk we are done reading
   alias fat32_stop_write is pata_hd_stop_write              -- tell hard disk we are done reading
   alias fat32_raw_read_sector is pata_hd_read_sector        -- read one sector to sector buffer array
   alias fat32_raw_read_sector_address is pata_hd_read_sector_address        -- read one sector to sector buffer array
   alias fat32_raw_write_sector is pata_hd_write_sector      -- read one sector to sector buffer array
   alias fat32_raw_write_sector_address is pata_hd_write_sector_address        -- read one sector to sector buffer array
   alias fat32_set_idle is pata_hd_set_idle                  -- sets hard disk to idle state
   alias fat32_raw_data_byte is pata_hd_data_byte            -- read one data byte from storage device
   alias fat32_read_pulse_byte is pata_hd_read_pulse_byte    -- one byte read pulse
   -- hard disk vars
   alias fat32_word_count is pata_hd_word_count              -- number of words read from current sector (byte var)
   alias fat32_sector_buffer is pata_hd_sector_buffer        -- sector buffer array
elsif DATA_MEDIA == SD_CARD then
   -- sd card procedures
   alias fat32_start_read is sd_start_read                   -- get sd card ready for reading
   alias fat32_stop_read  is sd_stop_read                    -- tell sd card we are done reading
   alias fat32_start_write is sd_start_write
   alias fat32_stop_write  is sd_stop_write                  -- tell sd card we are done reading
   alias fat32_raw_read_sector is sd_read_sector             -- read one sector to sector buffer array
   alias fat32_raw_write_sector is sd_write_sector           -- read one sector to sector buffer array
   alias fat32_raw_write_sector_address is sd_write_sector_address        -- read one sector to sector buffer array
   alias fat32_set_idle is sd_set_idle                       -- sets sd card to idle state
   alias fat32_raw_read_sector_address is sd_read_sector_address
   alias fat32_read_pulse_byte is sd_read_pulse_byte         -- one byte read pulse
   alias fat32_raw_data_byte is sd_data_byte                 -- read one data byte from storage device
   -- sd card vars
   alias fat32_word_count is sd_word_count                   -- number of words read from current sector (byte var)
   alias fat32_sector_buffer is sd_sector_buffer             -- sector buffer array
end if

-- ----------------------------------------------------------------------------
-- Start reading a file
-- ----------------------------------------------------------------------------
procedure fat32_start_file_read() is
   pragma inline
   fat32_start_read(fat32_file_location)

   -- reset read counts
   _fat32_file_sector_count = 0
   _fat32_file_byte_count = 0
   _fat32_file_fragment_number = 0
end procedure

-- ----------------------------------------------------------------------------
-- Start writing to a file
-- ----------------------------------------------------------------------------
procedure fat32_start_file_write() is
   pragma inline
   fat32_start_write(fat32_file_location)

   -- reset read counts
   _fat32_file_sector_count = 0
   _fat32_file_byte_count = 0
   _fat32_file_fragment_number = 0
end procedure

alias fat32_stop_file_read is fat32_stop_read
alias fat32_stop_file_write is fat32_stop_write

-- ----------------------------------------------------------------------------
-- creaate an array for fat32 filenames. You may define this
-- on your own (in a external memory device) if you want.
-- ----------------------------------------------------------------------------
if !defined(fat32_filename) then
   var byte fat32_filename[FAT32_FILENAME_SIZE]                                  -- make an array to hold filename characters
end if

-- ----------------------------------------------------------------------------
-- Reads a fat32 boot sector to get the location of the root directory
-- and FAT Location on the media for the partition selected.
-- Only primary partitions are supported. Secondary partitions are not.
-- ----------------------------------------------------------------------------
procedure fat32_read_boot_sector(byte in partition_select) is
   var dword sec_per_fat
   var byte _sec_per_fat[4] at sec_per_fat
   var word reserved_sectors -- usually 20h (may only need var reserved_sectors_1)
   var byte _reserved_sectors[2] at reserved_sectors
   var dword partition_lba_begin = 0
   var word part_addr = ((partition_select - 1)* 16)

   fat32_raw_read_sector_address(0)
   
   -- read the FileSystem Information Sector
   fat32_raw_read_sector_address((word(fat32_sector_buffer[49])*256)+fat32_sector_buffer[48])

   -- check for the signature of a FileSystem Information Sector
   -- "FS information sector signature"
   if ((fat32_sector_buffer[0] == 0x52) & (fat32_sector_buffer[1] == 0x52) &
      (fat32_sector_buffer[2] == 0x61) &(fat32_sector_buffer[3] == 0x41)) then
         -- Medium is identified as unpartitioned FAT32 filesystem
         fat32_raw_read_sector_address(0)
         fat32_init_ok = TRUE
   else -- Medium is partitioned or contains no FAT32 filesystem
     fat32_raw_read_sector_address(0)
      -- check if the partition is fat32
      var byte type_code -- partition type code
      type_code = fat32_sector_buffer[450 + part_addr]
      if (type_code == 0x0B) | (type_code == 0x0C) then
         fat32_init_ok = TRUE
      end if
       
      var byte _partition_lba_begin[4] at partition_lba_begin
       _partition_lba_begin[0] = fat32_sector_buffer[454 + part_addr]
       _partition_lba_begin[1] = fat32_sector_buffer[455 + part_addr]
       _partition_lba_begin[2] = fat32_sector_buffer[456 + part_addr]
       _partition_lba_begin[3] = fat32_sector_buffer[457 + part_addr]
   end if
   
   fat32_raw_read_sector_address(partition_lba_begin) -- read at sector at volume id location        --
   
   fat32_sectors_per_cluster = fat32_sector_buffer[13]

   -- reserved sectors
   _reserved_sectors[0] = fat32_sector_buffer[14]
   _reserved_sectors[1] = fat32_sector_buffer[15]

   _sec_per_fat[0] = fat32_sector_buffer[36]
   _sec_per_fat[1] = fat32_sector_buffer[37]
   _sec_per_fat[2] = fat32_sector_buffer[38]
   _sec_per_fat[3] = fat32_sector_buffer[39]
   
   -- get root dir first cluster (usually 00 00 00 02)
   var byte _fat32_root_dir_first_cluster[4] at fat32_root_dir_first_cluster
   _fat32_root_dir_first_cluster[0] = fat32_sector_buffer[44]
   _fat32_root_dir_first_cluster[1] = fat32_sector_buffer[45]
   _fat32_root_dir_first_cluster[2] = fat32_sector_buffer[46]
   _fat32_root_dir_first_cluster[3] = fat32_sector_buffer[47]
   
   -- get fat begin
   fat32_fat_begin = partition_lba_begin + reserved_sectors

   -- get cluster begin
   fat32_root_dir = partition_lba_begin + reserved_sectors + (2 * sec_per_fat)

   fat32_cluster_begin = fat32_root_dir - (16)
   
   fat32_current_dir_location = fat32_root_dir -- same as cluster_begin
end procedure

-- ----------------------------------------------------------------------------
-- read fragment locations from fat, store in
-- fat32_dir_fragments_start & fat32_dir_fragment_cluster_count arrays
-- ----------------------------------------------------------------------------
const byte FAT32_DIRECTORY = 0
const byte FAT32_FILE = 1
var dword fat32_current_cluster
if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then

   -- the user may create these arrays themselves in an external memory source
   if !defined(fat32_dir_fragments_start) then
      -- start cluster location of each directory fragment
      var dword fat32_dir_fragments_start[FAT32_DIR_FRAGMENTS_TO_ALLOW]
      -- count clusters that are next to eachother, max 32 if byte (256/8), var fat32_dir_count_3 must be same (default byte)
      var byte fat32_dir_fragment_cluster_count[FAT32_DIR_FRAGMENTS_TO_ALLOW]
   end if
   
   -- the user may create these arrays themselves in an external memory source
   if !defined(fat32_file_fragments_start) then
      -- start cluster location of each file fragment
      var dword fat32_file_fragments_start[FAT32_FILE_FRAGMENTS_TO_ALLOW]
      -- count sectors that are next to eachother, max fragment size is 4.19 megabites if word, 274.878 gb if dword, var fat32_file_count_3 must be same (default dword)
      var dword fat32_file_fragment_cluster_count[FAT32_FILE_FRAGMENTS_TO_ALLOW]
   end if
   
   procedure fat32_read_fragments(dword in dir_cluster_start, bit in file_or_dir) is
      if file_or_dir == FAT32_DIRECTORY then
         var byte fat32_dir_fragments_start_count = 0
         var word cluster_location_in_sector
         fat32_current_cluster = dir_cluster_start
         var bit done = false
         var dword custers_sector
         var byte custers_sector_array[4] at custers_sector
         var byte fat32_dir_count_3 = 1
         
         -- next cluster variables
         var byte next_cluster_array[4]
         var byte in_0, in_1, in_2, in_3
         var dword next_cluster at next_cluster_array
         
         var byte fat32_current_cluster_array[4] at fat32_current_cluster
         
         fat32_dir_fragments_start[0] = dir_cluster_start -- store the first cluster's start location in first array value
         
         fat32_dir_fragments_start_count = fat32_dir_fragments_start_count + 1 -- increment fat32_dir_fragments_start address
         
         while done == FALSE loop
            
            fat32_current_cluster = fat32_current_cluster << 1
            
            custers_sector_array[0] = fat32_current_cluster_array[1]
            custers_sector_array[1] = fat32_current_cluster_array[2]
            custers_sector_array[2] = fat32_current_cluster_array[3]
            custers_sector_array[3] = 0
            
            cluster_location_in_sector = fat32_current_cluster_array[0]
            
            fat32_current_cluster = fat32_current_cluster >> 1
            
            -- for troubleshooting only
            ;print_dword_dec(serial_hw_data, custers_sector)
            ;print_dword_dec(serial_hw_data, cluster_location_in_sector)
            
            
            fat32_start_read (fat32_fat_begin + custers_sector) -- go to the fat's sector where the first cluster value is located
            ;fat32_read_pulse (cluster_location_in_sector)       -- go to the location of the value in the sector
            fat32_read_pulse_byte (cluster_location_in_sector*2)
            
            -- get the location of the next cluster
            -- put it into a dword
            next_cluster_array[0] = fat32_raw_data_byte
            next_cluster_array[1] = fat32_raw_data_byte
            next_cluster_array[2] = fat32_raw_data_byte
            next_cluster_array[3] = fat32_raw_data_byte
            
            -- for troubleshooting only
            ;print_dword_dec(serial_hw_data,fat32_current_cluster
            ;print_dword_dec(serial_hw_data,next_cluster
            
            -- store number of clusters that are beside eachother
            fat32_dir_fragment_cluster_count[fat32_dir_fragments_start_count - 1] = 1
            
            if next_cluster == 0x0F_FF_FF_FF then -- exit if the file is only 1 cluster
               done = TRUE
            end if
            
            while done == FALSE loop
               fat32_dir_count_3 = 1
               if fat32_current_cluster + 1 == next_cluster  then -- if no fragmentation
                  while fat32_current_cluster + 1 == next_cluster loop
                     fat32_current_cluster = next_cluster -- increment since we read the next cluster, no fragmentation
                     
                     -- get the location of the next cluster
                     -- put it into a dword
                     next_cluster_array[0] = fat32_raw_data_byte
                     next_cluster_array[1] = fat32_raw_data_byte
                     next_cluster_array[2] = fat32_raw_data_byte
                     next_cluster_array[3] = fat32_raw_data_byte
                     
                     -- store number of clusters that are beside eachother
                     fat32_dir_count_3 = fat32_dir_count_3 + 1
                  end loop
                  fat32_dir_fragment_cluster_count[fat32_dir_fragments_start_count - 1] = fat32_dir_count_3
               elsif next_cluster == 0x0F_FF_FF_FF then -- if end of clusters
                  done = TRUE -- we are done, quit all loops
               else -- if fragmentation
               
                  fat32_dir_fragments_start[fat32_dir_fragments_start_count] = next_cluster -- store the location of the start of the next fragment
                  fat32_dir_fragments_start_count = fat32_dir_fragments_start_count + 1 -- increment fat32_dir_fragments_start address
                  fat32_current_cluster = next_cluster
                  
                  -- for troubleshooting only
                  ;_fat32_send_dword (fat32_current_cluster)
                  
                  exit loop -- exit this loop and go to the next fragment
               end if

               -- exit if there are more fragments then FAT32_DIR_FRAGMENTS_TO_ALLOW
               if fat32_dir_fragments_start_count == FAT32_DIR_FRAGMENTS_TO_ALLOW then
                  done = TRUE
                  exit loop
               end if
               
            end loop
            fat32_stop_read() -- stop reading media

         end loop
         
         ;-- set the rest of the values to 0x0F_FF_FF_FF
         ;for FAT32_DIR_FRAGMENTS_TO_ALLOW - fat32_dir_fragments_start_count loop
         ;   fat32_dir_fragments_start[fat32_dir_fragments_start_count] = 0xFF_FF_FF_FF
         ;   ;fat32_dir_fragment_cluster_count[fat32_dir_fragments_start_count] = 0xFF
         ;   fat32_dir_fragments_start_count = fat32_dir_fragments_start_count + 1
         ;end loop
         
      else -- if file
         
         -- same as above but renamed variables to fat32_file_fragments_start, fat32_file_fragments_start_count
         -- finds fragments in files
         var byte fat32_file_fragments_start_count = 0
         var word cluster_location_in_sector
         var dword fat32_current_cluster = dir_cluster_start
         var bit done = false
         var dword custers_sector
         var byte custers_sector_array[4] at custers_sector
         var dword fat32_file_count_3 = 1
         
         -- next cluster variables
         var byte next_cluster_array[4]
         var byte in_0, in_1, in_2, in_3
         var dword next_cluster at next_cluster_array
         
         var byte fat32_current_cluster_array[4] at fat32_current_cluster
         
         fat32_file_fragments_start[0] = dir_cluster_start -- store the first cluster's start location in first array value
         fat32_file_fragments_start_count = fat32_file_fragments_start_count + 1 -- increment fat32_file_fragments_start address

         while done == FALSE loop
         
            fat32_current_cluster = fat32_current_cluster << 1
            
            custers_sector_array[0] = fat32_current_cluster_array[1]
            custers_sector_array[1] = fat32_current_cluster_array[2]
            custers_sector_array[2] = fat32_current_cluster_array[3]
            custers_sector_array[3] = 0
            
            cluster_location_in_sector = fat32_current_cluster_array[0]
            
            fat32_current_cluster = fat32_current_cluster >> 1
            
            -- for troubleshooting only
            ;_fat32_send_dword (custers_sector)
            ;_fat32_send_dword (cluster_location_in_sector)
            
            
            fat32_start_read (fat32_fat_begin + custers_sector) -- go to the fat's sector where the first cluster value is located
            ;fat32_read_pulse (cluster_location_in_sector)       -- go to the location of the value in the sector
            fat32_read_pulse_byte (cluster_location_in_sector*2)
            
            -- get the location of the next cluster
            -- put it into a dword
            next_cluster_array[0] = fat32_raw_data_byte
            next_cluster_array[1] = fat32_raw_data_byte
            next_cluster_array[2] = fat32_raw_data_byte
            next_cluster_array[3] = fat32_raw_data_byte
            
            -- for troubleshooting only
            ;_fat32_send_dword (fat32_current_cluster)
            ;_fat32_send_dword (next_cluster)
            ;send_word (0xAA, 0xAA)
            
            -- store number of clusters that are beside eachother
            fat32_file_fragment_cluster_count[fat32_file_fragments_start_count - 1] = 1
            
            if next_cluster == 0x0F_FF_FF_FF then -- exit if the file is only 1 cluster
               done = TRUE
            end if
            
            while done == FALSE loop
            
               fat32_file_count_3 = 1
               if fat32_current_cluster + 1 == next_cluster  then -- if no fragmentation
                  while fat32_current_cluster + 1 == next_cluster loop

                     -- increment since we read the next cluster, no fragmentation
                     fat32_current_cluster = next_cluster
                     
                     -- get the location of the next cluster
                     -- put it into a dword
                     next_cluster_array[0] = fat32_raw_data_byte
                     next_cluster_array[1] = fat32_raw_data_byte
                     next_cluster_array[2] = fat32_raw_data_byte
                     next_cluster_array[3] = fat32_raw_data_byte

                     -- store number of clusters that are beside eachother
                     fat32_file_count_3 = fat32_file_count_3 + 1
                  end loop

                  fat32_file_fragment_cluster_count[fat32_file_fragments_start_count - 1] = fat32_file_count_3

               elsif next_cluster == 0x0F_FF_FF_FF then -- if end of clusters
                  done = TRUE -- we are done, quit all loops
               else -- if fragmentation
                  fat32_file_fragments_start[fat32_file_fragments_start_count] = next_cluster -- store the cluster location of the start of the next fragment
                  fat32_file_fragments_start_count = fat32_file_fragments_start_count + 1 -- increment fat32_file_fragments_start address
                  fat32_current_cluster = next_cluster
                  exit loop -- exit this loop and go to the next fragment
               end if
               
               -- exit if there are more fragments then FAT32_FILE_FRAGMENTS_TO_ALLOW
               if fat32_file_fragments_start_count == FAT32_FILE_FRAGMENTS_TO_ALLOW then
                  done = TRUE
                  exit loop
               end if
               
            end loop
            fat32_stop_read() -- stop reading media
            

         end loop
         
         ;-- set the rest of the values to 0x0F_FF_FF_FF
         ;for FAT32_DIR_FRAGMENTS_TO_ALLOW - fat32_file_fragments_start_count loop
         ;   fat32_file_fragments_start[fat32_file_fragments_start_count] = 0xFF_FF_FF_FF
         ;   fat32_file_fragment_cluster_count[fat32_file_fragments_start_count] = 0xFF_FF
         ;   fat32_file_fragments_start_count = fat32_file_fragments_start_count + 1
         ;end loop
      end if
      
      fat32_stop_read() -- stop reading media
   end procedure
end if

;-- ----------------------------------------------------------------------------
;-- read one entire sector (fragmented file needs to be tested)
;-- ----------------------------------------------------------------------------
;procedure fat32_read_sector() is
;   if FAT32_FILE_FRAGMENTS_TO_ALLOW == 0 then
;      fat32_raw_read_sector()
;   else
;      -- if between fragments, go to the next fragment and read
;      if fat32_sector_count == fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster then
;         fat32_stop_read() -- stop the current read process if any
;         _fat32_file_fragment_number = _fat32_file_fragment_number + 1  -- increment the fragment number being read
;         -- start reading at the beginning of the fragment
;         fat32_start_read (fat32_cluster_begin + (fat32_file_fragments_start[_fat32_file_fragment_number] * fat32_sectors_per_cluster) )
;         fat32_sector_count = 0 -- reset the sector counter.
;      end if
;      fat32_sector_count = fat32_sector_count + 1 -- increment sector number
;      fat32_raw_read_sector()
;   end if
;end procedure

-- ----------------------------------------------------------------------------
-- READ DIR INFO, STORE INTO fat32_entry_location ARRAY
-- refers to fat32 directory entry characters
-- ----------------------------------------------------------------------------
const byte FAT32_ENTRY_NOT_IN_USE = 0xE5            -- usually from a deleted file
const byte FAT32_ENTRY_IS_PART_OF_LONG_NAME = 0x0F  -- entry has a few characters of a long filename

procedure fat32_read_dir_info(dword in dir) is
   var byte*FAT32_ENTRIES_MAX filename_location
   var byte x,y
   var bit send_it = false
   var byte long_name_check
   var word sectors_read = 0
   var bit exit_procedure = FALSE
   var word current_entry

   var dword read_address
   var byte sectors_read_2 = 0

   var dword clusters_to_read = 1   -- number of clusters to read
   var word fragment_number = 0  -- the fragment number being read

   var byte attrib -- this attrib is different var then fat32_attrib
   var bit fat32_is_read_only at attrib : 0
   var bit fat32_is_hidden at attrib    : 1
   var bit fat32_is_system at attrib    : 2
   var bit fat32_is_volume_id at attrib : 3
   var bit fat32_is_directory at attrib : 4
   var bit fat32_is_archive at attrib   : 5

   fat32_dir_file_count = 0

   if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
      fat32_read_fragments (fat32_root_dir_first_cluster , FAT32_DIRECTORY) -- read the fragment locations
   else
      read_address = dir
      sectors_read_2 = 0
   end if

   fat32_current_dir_location = dir

   while exit_procedure == FALSE loop
      if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
         -- start reading at the beginning of the fragment
         read_address = (fat32_cluster_begin + (fat32_dir_fragments_start[fragment_number] * fat32_sectors_per_cluster) )
         clusters_to_read = fat32_dir_fragment_cluster_count[fragment_number] -- the number of clusters beside eachother
         fragment_number = fragment_number + 1  -- increment the fragment number being read
         sectors_read_2 = 0
      end if

      for clusters_to_read * fat32_sectors_per_cluster loop            -- loop till end of fragment
         ;fat32_start_read(read_address + sectors_read_2)
         ;;fat32_read_sector()
         ;fat32_raw_read_sector()
         ;fat32_stop_read()
         fat32_raw_read_sector_address(read_address + sectors_read_2)
         
         sectors_read_2 = sectors_read_2 + 1
         current_entry = 0

         for 16 loop         -- loop once per sector & count sectors read
            y                = fat32_sector_buffer [(current_entry * 32) + 0]
            long_name_check  = fat32_sector_buffer [(current_entry * 32) + 6]
            attrib           = fat32_sector_buffer [(current_entry * 32) + 11]
            current_entry    = current_entry + 1

            if (y == 0) then -- exit if no more files in current directory
               exit_procedure = TRUE
               exit loop
            end if

            if (fat32_dir_file_count > FAT32_FILES_MAX) then
               fat32_dir_file_count = fat32_dir_file_count - 1
               exit_procedure = TRUE
               exit loop
            end if

            ;-- get the location of the start of the filename
            if y != FAT32_ENTRY_NOT_IN_USE & attrib == FAT32_ENTRY_IS_PART_OF_LONG_NAME then   -- if longname, FAT32_ENTRY_NOT_IN_USE (unused entry), FAT32_ENTRY_IS_PART_OF_LONG_NAME (long filename)
               if y >= 0x41 then

                  -- calculate the entry location
                  if (current_entry) != 0 then -- do not decrement a zero value
                     filename_location = (current_entry) + (16 * sectors_read) - 1
                  else
                     filename_location = FAT32_ENTRY_IS_PART_OF_LONG_NAME + (16 * sectors_read)
                  end if

                  send_it = TRUE
                  ;send_word (0xFF,0xFF)
                  ;send_word (filename_location,fat32_word_count)
               end if
            elsif (y != FAT32_ENTRY_NOT_IN_USE) & (long_name_check != "~") then -- if shortname only ("~" = "~")

               -- calculate the entry location
               if (current_entry) != 0 then
                  filename_location = (current_entry) + (16 * sectors_read) - 1
               else -- do not decrement a zero value
                  filename_location = FAT32_ENTRY_IS_PART_OF_LONG_NAME + (16 * sectors_read)
               end if

               send_it = TRUE

               -- fat32_attrib_filter out unwanted attributes
               if (attrib & fat32_attrib_filter) > 0 then
                  send_it = false
               end if

            elsif y != FAT32_ENTRY_NOT_IN_USE & long_name_check == "~" then -- if shortname entry that has a long name

               -- fat32_attrib_filter out unwanted attributes
               if (attrib & fat32_attrib_filter) > 0 then
                  fat32_dir_file_count = fat32_dir_file_count - 1
               end if

               send_it = false
            else
               send_it = false
            end if

            if send_it == TRUE then
               -- reset stuff
               send_it = false

               fat32_entry_location [fat32_dir_file_count] = filename_location

               ;serial_hw_data = fat32_dir_file_count
               ;serial_hw_data = filename_location
               
               fat32_dir_file_count = fat32_dir_file_count + 1
            end if

         end loop

         if (y == 0) | (fat32_dir_file_count > FAT32_FILES_MAX) | exit_procedure == TRUE then -- exit if no more files in current directory or if max files reached
            exit_procedure = TRUE
            exit loop
         end if
         sectors_read = sectors_read + 1
      end loop -- end sector loop

      if (y == 0) | (fat32_dir_file_count > FAT32_FILES_MAX) | exit_procedure == TRUE then -- exit if no more files in current directory or if max files reached
         exit_procedure = TRUE
         exit loop
      end if

   end loop

   fat32_entry_location[fat32_dir_file_count] = 0
   fat32_stop_read() -- let media wait for next operation
end procedure

-- ----------------------------------------------------------------------------
-- reads file info such as filename, filesize, filelocation, etc. into memory.
-- ----------------------------------------------------------------------------
procedure fat32_read_file_info(byte*FAT32_ENTRIES_MAX in file_number) is
   var dword read_fat32_entry_location
   var byte line[32]
   var byte long_name_pos = FAT32_FILENAME_SIZE + 0 - 1
   var byte long_filename_char[13]
   var byte count1
   var byte long_name_entries
   var word x

   read_fat32_entry_location = fat32_entry_location[file_number]
   
   if (FAT32_DIR_FRAGMENTS_TO_ALLOW > 0) then
      -- start reading at the correct sector
      -- calculate how many clusters forward the filename is
      -- get how many sectors into the current dir the filename is located
      
      -- get the entrie's directory sector number
      var dword entry_sector_number
      entry_sector_number = read_fat32_entry_location >> 4
      
      -- find what fragment the filename is located in
      var word fragment_count = 0
      var dword sector_adder = 0
      var dword sector_prev_added = 0
      
      sector_adder = fat32_dir_fragment_cluster_count[0] -- read location of first fragment
      
      -- not sure why this is needed here, if this is not here,
      -- when files_max is = between 15-25 files don't list correctly.
      if fat32_dir_fragment_cluster_count[0] == 0 then
         sector_adder = 1
      end if
      
      forever loop
         if (entry_sector_number < (sector_adder * fat32_sectors_per_cluster) ) then            -- check if filename is in current fragment
            exit loop
         else
            sector_prev_added = sector_adder                      -- remember number of sectors counted so far from last fragment
            fragment_count = fragment_count + 1                   -- go to next fragment
            sector_adder = sector_adder + fat32_dir_fragment_cluster_count[fragment_count] -- add number of sectors in current fragment
         end if
      end loop
      
      -- start reading at the correct fragment and sector number
      if !(entry_sector_number == 0) then -- not sure why this if is needed when files_max is < 8
         fat32_start_read (fat32_cluster_begin + fat32_dir_fragments_start[fragment_count]*fat32_sectors_per_cluster + (entry_sector_number - (sector_prev_added * fat32_sectors_per_cluster)) )
      else
         fat32_start_read (fat32_current_dir_location + (read_fat32_entry_location >> 4))
      end if
   else
      -- start reading at the correct sector
      fat32_start_read (fat32_current_dir_location + (read_fat32_entry_location >> 4))
   end if

   -- start reading at the correct 32 byte entry
   x = byte(read_fat32_entry_location) & 0x0F -- get lower nibble out of read_fat32_entry_location

   fat32_read_pulse_byte (x * 32)
   
   if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
      var word entry_count = x -- count entries read incase we go over a fragment boarder, may be able to get rid of this var
   end if
   -- CLEAR LAST filename ENTRY
   count1 = 0
   for FAT32_FILENAME_SIZE loop
      fat32_filename[count1] = 0
      count1 = count1 + 1
   end loop
   
   -- read the filename, fat32_attributes, location, ext
   forever loop
      -- GET LINE OF CLUSTER
      line[0] = fat32_raw_data_byte
      line[1] = fat32_raw_data_byte
      line[2] = fat32_raw_data_byte
      line[3] = fat32_raw_data_byte
      line[4] = fat32_raw_data_byte
      line[5] = fat32_raw_data_byte
      line[6] = fat32_raw_data_byte
      line[7] = fat32_raw_data_byte
      line[8] = fat32_raw_data_byte
      line[9] = fat32_raw_data_byte
      line[10] = fat32_raw_data_byte
      line[11] = fat32_raw_data_byte
      line[12] = fat32_raw_data_byte
      line[13] = fat32_raw_data_byte
      line[14] = fat32_raw_data_byte
      line[15] = fat32_raw_data_byte
      line[16] = fat32_raw_data_byte
      line[17] = fat32_raw_data_byte
      line[18] = fat32_raw_data_byte
      line[19] = fat32_raw_data_byte
      line[20] = fat32_raw_data_byte
      line[21] = fat32_raw_data_byte
      line[22] = fat32_raw_data_byte
      line[23] = fat32_raw_data_byte
      line[24] = fat32_raw_data_byte
      line[25] = fat32_raw_data_byte
      line[26] = fat32_raw_data_byte
      line[27] = fat32_raw_data_byte
      line[28] = fat32_raw_data_byte
      line[29] = fat32_raw_data_byte
      line[30] = fat32_raw_data_byte
      line[31] = fat32_raw_data_byte
      
      long_name_entries = line[0] -- get the number of entries a longname takes up if it is a long name
      
      fat32_attrib = line[11] -- get file fat32_attributes if short name, 0x0F if part of long name.
      
      -- if line is part of long filename
      if fat32_attrib == FAT32_ENTRY_IS_PART_OF_LONG_NAME & line[0] != FAT32_ENTRY_NOT_IN_USE then
         for long_name_entries - 0x40 loop
            
            long_filename_char[12] = line[1]
            long_filename_char[11] = line[3]
            long_filename_char[10] = line[5]
            long_filename_char[9] = line[7]
            long_filename_char[8] = line[9]
            long_filename_char[7] = line[14]
            long_filename_char[6] = line[16]
            long_filename_char[5] = line[18]
            long_filename_char[4] = line[20]
            long_filename_char[3] = line[22]
            long_filename_char[2] = line[24]
            long_filename_char[1] = line[28]
            long_filename_char[0] = line[30]
            
            -- put zero's in long name characters if character is not valid
            count1 = 0
            for 13 loop
               if long_filename_char[count1] == 0xFF then
                  long_filename_char[count1] = 0x00         -- may not need to do this
               end if
               if long_filename_char[count1] <= 0x1F then
                  if long_filename_char[count1] >= 0x7F then
                     long_filename_char[count1] = 0x00
                  end if
               end if
               count1 = count1 + 1
            end loop
            
            -- store the long filename into 'longname'
            count1 = 0
            for 13 loop
               if long_filename_char[count1] == 0x00 then
                  ;long_filename_char[count1] = 0xFF
               end if
               if (long_name_pos < FAT32_FILENAME_SIZE) then
                  fat32_filename[long_name_pos] = long_filename_char[count1];fat32_write_filename ( long_name_pos, long_filename_char[count1])
                  long_name_pos = long_name_pos - 1
                  count1 = count1 + 1
               end if
            end loop
            
            if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
               -- if filename is going over a frabment boarder (if at last sector of current fragment), change to next fragment.
               if (entry_sector_number - (sector_prev_added * fat32_sectors_per_cluster) ) == (sector_adder * fat32_sectors_per_cluster - 1) then
                  if entry_count == 15 then -- * dir_fragment_entry_count) -- if we finnished the last sector in fragment
                     fat32_stop_read()
                     -- start reading at the beginning of the next fragment
                     fat32_start_read (fat32_cluster_begin + (fat32_dir_fragments_start[fragment_count + 1]*fat32_sectors_per_cluster) )
                  end if
               end if
               entry_count = entry_count + 1 -- increment entry counter
            end if
            
            -- use this to get file info such as the longname's shortname, file ext, file fat32_attrib
            
            line[0] = fat32_raw_data_byte
            line[1] = fat32_raw_data_byte
            line[2] = fat32_raw_data_byte
            line[3] = fat32_raw_data_byte
            line[4] = fat32_raw_data_byte
            line[5] = fat32_raw_data_byte
            line[6] = fat32_raw_data_byte
            line[7] = fat32_raw_data_byte
            line[8] = fat32_raw_data_byte
            line[9] = fat32_raw_data_byte
            line[10] = fat32_raw_data_byte
            line[11] = fat32_raw_data_byte
            line[12] = fat32_raw_data_byte
            line[13] = fat32_raw_data_byte
            line[14] = fat32_raw_data_byte
            line[15] = fat32_raw_data_byte
            line[16] = fat32_raw_data_byte
            line[17] = fat32_raw_data_byte
            line[18] = fat32_raw_data_byte
            line[19] = fat32_raw_data_byte
            line[20] = fat32_raw_data_byte
            line[21] = fat32_raw_data_byte
            line[22] = fat32_raw_data_byte
            line[23] = fat32_raw_data_byte
            line[24] = fat32_raw_data_byte
            line[25] = fat32_raw_data_byte
            line[26] = fat32_raw_data_byte
            line[27] = fat32_raw_data_byte
            line[28] = fat32_raw_data_byte
            line[29] = fat32_raw_data_byte
            line[30] = fat32_raw_data_byte
            line[31] = fat32_raw_data_byte
            
         end loop
         
         exit loop
         
      elsif (fat32_attrib != FAT32_ENTRY_IS_PART_OF_LONG_NAME)  & (line[0] != FAT32_ENTRY_NOT_IN_USE) then ; IF LINE IS SHORT FILENAME
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 12] = line[0]  -- first char
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 11] = line[1]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 10] = line[2]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 9] = line[3]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 8] = line[4]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 7] = line[5]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 6] = line[6]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 5] = line[7]
         
         -- remove extra spaces from the end of a short filename
         var byte count_up = 0    -- count how many spaces
         var byte count_up2 = 5   -- char address to read
         for 8 loop
            ;;fat32_get_filename (FAT32_FILENAME_SIZE + 0 - count_up2, check_for_space) -- read a character
            ;check_for_space =
            if fat32_filename[FAT32_FILENAME_SIZE + 0 - count_up2] == 0x20 then -- check for a "space" character
               count_up = count_up + 1       -- increment spaces found
               count_up2 = count_up2 + 1     -- increment char address
            end if
         end loop

         
         if (fat32_is_directory == false) & (fat32_is_volume_id == false) then
            fat32_filename[FAT32_FILENAME_SIZE + 0 - 4 - count_up] = "." -- add "." if it is a file
         end if
         
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 3 - count_up] = line[8] -- FILE EXTENSION
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 2 - count_up] = line[9]
         fat32_filename[FAT32_FILENAME_SIZE + 0 - 1 - count_up] = line[10]
         
         exit loop
         
      end if
   end loop
   
   fat32_stop_read() -- let media wait for next operation
   
   ;Get Extension
   fat32_file_extension[0] = line[8]
   fat32_file_extension[1] = line[9]
   fat32_file_extension[2] = line[10]
   
   ;Get Cluster high, Cluster low, file location
   fat32_root_dir_first_cluster = line[21]
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster << 8
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster + line[20]
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster << 8
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster + line[27]
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster << 8
   fat32_root_dir_first_cluster = fat32_root_dir_first_cluster + line[26]
   
   if fat32_root_dir_first_cluster == 0 then   -- if dir cluster location = 0, file location is the root dir
      fat32_root_dir_first_cluster = 2
   end if
   
   fat32_file_location = fat32_cluster_begin + (fat32_root_dir_first_cluster * fat32_sectors_per_cluster)
   
   ;Get File size
   fat32_file_size = line[31]
   fat32_file_size = fat32_file_size << 8
   fat32_file_size = fat32_file_size + line[30]
   fat32_file_size = fat32_file_size << 8
   fat32_file_size = fat32_file_size + line[29]
   fat32_file_size = fat32_file_size << 8
   fat32_file_size = fat32_file_size + line[28]
   
   fat32_attrib = line[11] ; GET FILE fat32_attributes
end procedure

-- ----------------------------------------------------------------------------
-- initalize fat32
-- ----------------------------------------------------------------------------
procedure fat32_init(byte in primary_partition_number) is
   fat32_read_boot_sector (primary_partition_number) -- get the location of first partition ( c:\ )
   fat32_read_dir_info (fat32_current_dir_location) -- put root directory into memory
end procedure

-- ----------------------------------------------------------------------------
-- change directory, returns 1 = success, 0 = not a directory
-- ----------------------------------------------------------------------------
function fat32_cd(byte in file_number) return bit is
   fat32_read_file_info(file_number) -- read file's name, location, size, attributes
   if fat32_is_directory then  -- if it is a directory
      fat32_read_dir_info (fat32_file_location)        -- read info about the dir chosen
      return 1
   elsif fat32_is_volume_id then
      -- if it is a volume id, we are already in the root dir so don't read the dir
      return 1
   else
      return 0
   end if
end function

-- ----------------------------------------------------------------------------
-- check if file is ok to start reading, returns 1 = success, 0 = not a file
-- ----------------------------------------------------------------------------
function fat32_file_open(byte in file_number) return bit is
   fat32_read_file_info(file_number) -- read file's name, location, size, attributes
   
   if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
      fat32_read_fragments (fat32_root_dir_first_cluster , FAT32_FILE) -- read the fragment locations
   end if
   if (!fat32_is_directory) & (!fat32_is_volume_id) then -- if it is a file
      _fat32_file_sector_count = 0
      if FAT32_DIR_FRAGMENTS_TO_ALLOW > 0 then
         _fat32_file_fragment_number = 0 -- the current fragment of a file we are in
      end if
      return 1
   else
      return 0
   end if
end function

-- ----------------------------------------------------------------------------
-- close the currently opened file.
-- ----------------------------------------------------------------------------
procedure fat32_file_close() is
   -- ensure all reading/writing is done
   fat32_stop_file_write()
   fat32_stop_file_read()
end procedure

-- ----------------------------------------------------------------------------
-- read one sector from a file starting at the beginning of the file.
-- auto increments to next sector in file. fragmented files work.
-- requires: fat32_start_file_read(fat32_file_location), fat32_stop_file_read()
-- faster then fat32_read_file_sector_number() procedure
-- ----------------------------------------------------------------------------
procedure fat32_read_file_sector() is
   if FAT32_FILE_FRAGMENTS_TO_ALLOW == 0 then
      fat32_raw_read_sector()
   else
      -- if between fragments, go to the next fragment and read
      if _fat32_file_sector_count == (fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster) then

         fat32_stop_read() -- stop the current read process if any
         _fat32_file_fragment_number = _fat32_file_fragment_number + 1  -- increment the fragment number being read

         -- start reading at the beginning of the fragment
         fat32_start_read (fat32_cluster_begin + (fat32_file_fragments_start[_fat32_file_fragment_number] * fat32_sectors_per_cluster) )
         _fat32_file_sector_count = 0 -- reset the sector counter.
      end if

      _fat32_file_sector_count = _fat32_file_sector_count + 1 -- increment sector number
      fat32_raw_read_sector()
   end if
end procedure

-- ----------------------------------------------------------------------------
-- reads selected sector from a file. fragmented files work.
-- slower then fat32_read_file_sector() procedure, but user friendly.
-- ----------------------------------------------------------------------------
procedure fat32_read_file_sector_number(dword in file_sector_number) is
   if FAT32_FILE_FRAGMENTS_TO_ALLOW == 0 then
      -- just read the file at the address. assume no fragments.
      fat32_raw_read_sector_address(fat32_file_location + file_sector_number)
   else
      -- find what fragment the requested file sector number is located in
      
      -- rename/reuse the input variable
      alias sectors_left is file_sector_number
      
      -- start at first fragment
      _fat32_file_fragment_number = 0

      -- calculate how many sectors are in the current fragment
      var dword count_fragment_sectors = fat32_file_fragment_cluster_count[0] * fat32_sectors_per_cluster

      -- while we are not at the correct fragment,
      -- number of sectors left is > the number of sectors in the current fragment.
      while !((fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster) > sectors_left) loop
         -- subtract the number of sectors in the current fragment from sectors left
         sectors_left = sectors_left - (fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster)
         -- increment to the next fragment
         _fat32_file_fragment_number = _fat32_file_fragment_number + 1
      end loop

      -- calculate the address
      var dword address
      address = fat32_cluster_begin + (fat32_file_fragments_start[_fat32_file_fragment_number] * fat32_sectors_per_cluster) + sectors_left

      -- read a sector at the address
      fat32_raw_read_sector_address(address)
   end if
end procedure

-- ----------------------------------------------------------------------------
-- read one byte from a file starting at the beginning of the file.
-- auto increments to next byte in file. fragmented files work.
-- requires: fat32_start_file_read(fat32_file_location), fat32_stop_file_read()
-- faster then fat32_read_file_address() procedure
-- ----------------------------------------------------------------------------
function fat32_read_file_byte() return byte is
   var byte data
   if _fat32_file_byte_count == 0 then
      fat32_read_file_sector()
      _fat32_file_byte_count = _fat32_file_byte_count + 1
      return fat32_sector_buffer[0]
   else
      data = fat32_sector_buffer[_fat32_file_byte_count]
      _fat32_file_byte_count = _fat32_file_byte_count + 1
      if _fat32_file_byte_count == 512 then
         _fat32_file_byte_count = 0
      end if
      return data
   end if
end function

-- ----------------------------------------------------------------------------
-- reads selected byte from a file. fragmented files work.
-- slower then fat32_read_file() procedure, but user friendly.
-- ----------------------------------------------------------------------------
var dword current_address = 0xFFFFFFFF
function fat32_read_file_byte_address(dword in address) return byte is
   var byte data
   var word sector_location = 0

   while address > 512 loop
      -- calculate what sector the byte is in
      sector_location = sector_location + 1
      
      -- calculate where the byte is in the sector
      address = address - 512
   end loop
   
   -- read the sector
   if !(sector_location == current_address) then
      fat32_read_file_sector_number(sector_location)
      current_address = sector_location
   end if
   
   -- return the data byte
   return fat32_sector_buffer[word(address)]
end function

-- ----------------------------------------------------------------------------
-- write one sector to a file starting at the beginning of the file.
-- auto increments to next sector in file. fragmented files work.
-- requires: fat32_start_file_write(fat32_file_location), fat32_stop_file_write
-- faster then fat32_write_file_sector_number() procedure
-- ----------------------------------------------------------------------------
procedure fat32_write_file_sector() is
   if FAT32_FILE_FRAGMENTS_TO_ALLOW == 0 then
      fat32_raw_write_sector()
   else
      -- if between fragments, go to the next fragment and write
      if _fat32_file_sector_count == (fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster) then

         fat32_stop_write() -- stop the current write process if any
         _fat32_file_fragment_number = _fat32_file_fragment_number + 1  -- increment the fragment number being write

         -- start writeing at the beginning of the fragment
         fat32_start_write (fat32_cluster_begin + (fat32_file_fragments_start[_fat32_file_fragment_number] * fat32_sectors_per_cluster) )
         _fat32_file_sector_count = 0 -- reset the sector counter.
      end if

      _fat32_file_sector_count = _fat32_file_sector_count + 1 -- increment sector number
      fat32_raw_write_sector()
   end if
end procedure

-- ----------------------------------------------------------------------------
-- writes selected sector to a file. fragmented files work.
-- slower then fat32_write_file_sector() procedure, but user friendly.
-- ----------------------------------------------------------------------------
procedure fat32_write_file_sector_number(dword in file_sector_number) is
   if FAT32_FILE_FRAGMENTS_TO_ALLOW == 0 then
      -- just write the file at the address. assume no fragments.
      fat32_raw_write_sector_address(fat32_file_location + file_sector_number)
   else
      -- find what fragment the requested file sector number is located in

      -- rename/reuse the input variable
      alias sectors_left is file_sector_number

      -- start at first fragment
      _fat32_file_fragment_number = 0

      -- calculate how many sectors are in the current fragment
      var dword count_fragment_sectors = fat32_file_fragment_cluster_count[0] * fat32_sectors_per_cluster

      -- while we are not at the correct fragment,
      -- number of sectors left is > the number of sectors in the current fragment.
      while !((fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster) > sectors_left) loop
         -- subtract the number of sectors in the current fragment to sectors left
         sectors_left = sectors_left - (fat32_file_fragment_cluster_count[_fat32_file_fragment_number] * fat32_sectors_per_cluster)
         -- increment to the next fragment
         _fat32_file_fragment_number = _fat32_file_fragment_number + 1
      end loop

      -- calculate the address
      var dword address
      address = fat32_cluster_begin + (fat32_file_fragments_start[_fat32_file_fragment_number] * fat32_sectors_per_cluster) + sectors_left

      -- write a sector at the address
      fat32_raw_write_sector_address(address)
   end if
end procedure

-- ----------------------------------------------------------------------------
-- print a filename to an output device
-- ----------------------------------------------------------------------------
procedure fat32_print_filename(volatile byte out output_device) is
   var byte step1
   for count(fat32_filename) using step1 loop
      if fat32_filename[step1] != 0 then
         output_device = fat32_filename[step1]
      end if
   end loop
end procedure

-- ----------------------------------------------------------------------------
-- print the current directory to an output device
-- ----------------------------------------------------------------------------
procedure fat32_print_directory(volatile byte out output_device, bit in with_file_numbers) is
   var word count4 = 0          -- set count to 0
   for fat32_dir_file_count loop          -- loop untill end of files
      -- send file number via serial port in ascii format

      if with_file_numbers == TRUE then
         print_word_dec(output_device,count4)
         const byte string1[] = {0x2E,0x20,0x20} -- ".  "
         print_string(output_device,string1)
      end if

      -- write entery location via serial port
;    serial_hw_write (0x20)
;    format_word_dec(serial_hw_data,fat32_entry_location[count4],6,0)
;    serial_hw_write (0x20)

      -- choose the file number to read acording to the count
      fat32_read_file_info(count4) -- read file's name, location, size, attributes
      fat32_print_filename(output_device)
      print_crlf(output_device) -- cend CRLF to serial port

      count4 = count4 + 1                  -- increment count
   end loop
end procedure
