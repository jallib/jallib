#def header
-- Title: ADC channel configuration.
-- Author: Sebastien Lelong, Copyright (C) 2009, all rights reserved. 
-- Adapted-by: 
-- Compiler: >=2.4k
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this library acts as a wrapper. When included, it'll define ways to
-- configure the number ADC channels. There are 3 different cases:
--    1. the number of channels is specified setting/clearing PCFG bits
--       => a combination of PCFG bits selects a given number of ADC channels.
--          It is not possible to independently select which pins as ADC pins.
--          If available, Vref+ and Vref- are part of these combinations.
--          PCFG bits are in ADCON1, as ADCON1_PCFG
--    2. the number of channels is specified clearing PCFG bits (case only found in 18F, I think)
--       => pins can be configured independently (you can decide which pin will act as
--          an analog pin, and define your own combination
--          Vref+/Vref- are configured using VCFG bits.
--          PCFG bits are in ADCON0 and ADCON1, and are numbered (eg. ADCON_PCFG5)
--    3. the number of channels is set using ANS bits (18F and non-18F)
--       => same as case 2., channels can be configured independently
--          Vref+/Vref- are configured using VCFG bits.
--
--
-- Notes: this file is generated, don't modify it directly...
--

#end def

#import copy

#def deps
#end def


#def analyze_config(bits,dpins,mapping)
	#set analog = [d for d in dpins.items() if d[1] == 'A']
	#set vrefs = [d for d in dpins.items() if d[1].startswith('VREF')]
	#set num_a = len(analog)
	#set num_vref = len(vrefs)
	## There can be "anything" bits...
	#silent bits = bits.replace("x","0")
	## Mapping for 0, 1 or 2 VREF
	#silent mapping.setdefault(num_a + num_vref,{0 : '0', 1 : '0', 2 : '0', 'analog_pins' : []})[num_vref] = bits
	#silent mapping[num_a + num_vref]['analog_pins'] = analog + vrefs
	#return "const bit*%d ADC_PCFG_%sANA_%sREF = 0b_%s" % (len(bits),num_a,num_vref,bits)
#end def

#def parse_analog_pin(strpin)
	#if "/" in strpin
		#return strpin.split("/")[0]
	#else
		#return strpin
	#end if
#end def

#def pcfg_conf(dsref,pics)
	#set confs = copy.deepcopy($adc_pcfg[$dsref])
	## clean/remove some pins when not available in given PICs
	## (given PICs all have the same pins, but the confs/combination
	##  may be a merge for different PICs. Ex: 16F77 has RE pins, not 16F76)
	#set dummy_pic = $pics[-1]
	#set availpins = $adc_pins[dummy_pic]
	#for conf,dpins in confs.items():
		#for pin in dpins.keys()
			#set an_pin = $parse_analog_pin(pin)
			## search by digital and analog names
			#if not an_pin in availpins.keys() and not an_pin in availpins.values()
				#silent dpins.pop(pin)
			#end if
		#end for
	#end for

	#set mapping = dict()
         ##-- These are some constants similar to what can be found in MCC18 adc.h header file
	#for bits,dpins in confs.items()
		#set r = $analyze_config(bits,dpins,mapping)
		## remove generation of constants, as there can be duplicate, and 
		## since they're used and since I'm not lazy for now to fix these dups
		## I prefer "silent" this !
		## Please forgive me...
        ##$r
	#end for
	## mapping contains only valid/existing config, but these aren't continue:
	## we can have 1 ANA, then 3 ANA, but no 2 ANA config.
	## We need to have "padding" configs, because these aren going to be put
	## in a array, and accessed by ADC_NCHANNEL/ADC_NVREF
	#set tmpmap = dict().fromkeys(range(0,max(mapping.keys()) + 1))
	#for k,v in tmpmap.items()
		#if not k in mapping
			#silent mapping[k] = {0 : '0', 1 : '0', 2 : '0', 'analog_pins' : []}
		#end if
	#end for
	#set smap = sorted(mapping.items())
	#set lmap = []
	#silent [(lmap.append(m[1][0]),lmap.append(m[1][1]),lmap.append(m[1][2])) for m in smap]
	#set lenlmap = str(len(lmap))
	#set lenbits = str(len(bits))
	#set map = "const byte ADC_PCFG_MAP [" + lenlmap + "] = {0b_" + ", 0b_".join(lmap) + "}"

         -- This array stores PCFG config bits, 3 by 3, for each number of 
         -- ADC channels, from 1 to the max:
         -- For each 3-tuple: (no vref, 1 vref, 2 vref)
         $map
         var bit*$lenbits no_vref = 0
         var bit*$lenbits one_vref = 0
         var bit*$lenbits two_vref = 0

	## Generate procedure to access combinations
    #for i,(numch,dconf) in enumerate(smap)
		#if i == 0
         if (ADC_NCHANNEL) == $numch then
		#else
         elsif (ADC_NCHANNEL) == $numch then
		#end if
		#if dconf['analog_pins']
			#for strpin in dconf['analog_pins']:
				## pin can looks like "AN0" or a couple like "AN0/RA0"
				#set an_pin = $parse_analog_pin(strpin[0])
				## check pin exists in this pic (there can be multiple PIC in the 
				## same datasheets, but with different analog pins, and the same
				## PCFG combinations, exceptions (eg. "RE1 pin only exist for 16F77")
				#if an_pin.startswith("AN")
					#if not an_pin in $adc_pins[dummy_pic].values()
						#continue
					#end if
				#else
					#if not an_pin in $adc_pins[dummy_pic].keys()
						#continue
					#end if
				#end if
				#if not an_pin.startswith("AN")
					#silent an_pin = $adc_pins[dummy_pic][an_pin]
				#end if
            pin_${an_pin}_direction = input
			#end for
		#else
		    asm nop
		#end if
	#end for
         end if
#end def


#def pcfg_combination
	#set bydsref = {}
	#silent [bydsref.setdefault($pic_ds[p],[]).append(p) for p in $pcfg_combination_pics]
	#for dsref, pics in bydsref.items()
		## Even if PICs are in the same datasheets, there can be differences
		## regarding the number of 
		#set pics = $ds_pic[dsref]
		#set pingrps = {}
		#for p in pics
			#silent pingrps.setdefault(tuple($adc_pins[p]),[]).append(p)
		#end for

		#for pins,picsgrp in pingrps.items()
			#set condition = " | ".join(map(lambda x: "target_chip == PIC_%s" % x.upper(),picsgrp))
			#set ds_refs = list(set([$pic_ds[p] for p in picsgrp]))
			#assert len(ds_refs) == 1

   -- Datasheet: $ds_refs[0]
   if $condition then

$pcfg_conf($dsref,$picsgrp)
   end if

		#end for

	#end for

   -- Retrieve config bits according to selected number of ADC channels
   -- ADC_PCFG_MAP contains all confs, from 0 analog to the max
   const byte idx = ADC_NCHANNEL * 3
   if ADC_NVREF == 0 then
      no_vref = ADC_PCFG_MAP[idx]
      ADCON1_PCFG = no_vref
   elsif ADC_NVREF == 1 then
      one_vref = ADC_PCFG_MAP[idx + 1]
      ADCON1_PCFG = one_vref
   elsif ADC_NVREF == 2 then
      two_vref = ADC_PCFG_MAP[idx + 2]
      ADCON1_PCFG = two_vref
   else
      _error "You can't have more than 2 VRef..."
   end if


#end def

#def pcfg_18f
	## PCFG0  in ANCON0
	## PCFG1  in ANCON0
	## PCFG2  in ANCON0
	## PCFG3  in ANCON0
	## PCFG4  in ANCON0
	## PCFG5  in ANCON0
	## PCFG6  in ANCON0
	## PCFG7  in ANCON0
	## PCFG8  in         ANCON1
	## PCFG9  in         ANCON1
	## PCFG10 in         ANCON1
	## PCFG11 in         ANCON1
	## PCFG12 in         ANCON1

   -- Selecting the number of ADC channels is done using PCFG bits
   -- User can optionally specify ADC channels number
   if defined(ADC_NCHANNEL) == true then
      if ADC_NCHANNEL > ADC_NTOTAL_CHANNEL then
         _error "More ADC channels than available, adjust ADC_NCHANNEL"
      end if
      -- Max 13 ADC channels
      -- At least 1 channel
      if ADC_NCHANNEL > 0 then
         ANCON0_PCFG0 = false
         pin_AN0_direction = input
      end if
      -- At least 2 channels
      if ADC_NCHANNEL > 1 then
         ANCON0_PCFG1 = false
         pin_AN1_direction = input
      end if
      -- At least 3 channels
      if ADC_NCHANNEL > 2 then
          ANCON0_PCFG2 = false
         pin_AN2_direction = input
      end if
      -- At least 4 channels
      if ADC_NCHANNEL > 3 then
         ANCON0_PCFG3 = false
         pin_AN3_direction = input
      end if
      -- At least 5 channels
      if ADC_NCHANNEL > 4 then
         ANCON0_PCFG4 = false
         pin_AN4_direction = input
      end if
      -- At least 6 channels
      if ADC_NCHANNEL > 5 then
         ANCON0_PCFG5 = false
         pin_AN5_direction = input
      end if
      -- At least 7 channels
      if ADC_NCHANNEL > 6 then
         ANCON0_PCFG6 = false
         pin_AN6_direction = input
      end if
      -- At least 8 channels
      if ADC_NCHANNEL > 7 then
         ANCON0_PCFG7 = false
         pin_AN7_direction = input
      end if
      -- At least 9 channels
      if ADC_NCHANNEL > 8 then
         ANCON1_PCFG8 = false
         pin_AN8_direction = input
      end if
      -- At least 10 channels
      if ADC_NCHANNEL > 9 then
         ANCON1_PCFG9 = false
         pin_AN9_direction = input
      end if
      -- At least 11 channels
      if ADC_NCHANNEL > 10 then
         ANCON1_PCFG10 = false
         pin_AN10_direction = input
      end if
      -- At least 12 channels
      if ADC_NCHANNEL > 11 then
         ANCON1_PCFG11 = false
         pin_AN11_direction = input
      end if
      -- At least 13 channels
      if ADC_NCHANNEL > 12 then
         ANCON1_PCFG12 = false
         pin_AN12_direction = input
      end if
   end if

   -- Or specify manually which pin should act as ADC
   -- Provide procedure for this (eg. for pin AN7 to be analog, set_analog_pin(7))

   -- Configure a pin to act as an analog pin.
   -- an_pin_num references the 'x' in ANx notation.
   -- Say you want to activate pin AN7, which is pin #12, also named RA4 in digital mode:
   --     - set_analog_pin(7) will set this pin as analog
   --     - set_analog_pin(12) won't set this pin as analog, but the equivalent
   --       one named AN12, if any
   --     - set_analog_pin(4) will do the same for AN4
   procedure set_analog_pin(byte in an_pin_num) is
      -- There's a mininum of 5 channels, so ANCON0_PCFG0, ANCON0_PCFG1,
      -- ANCON0_PCFG2, ANCON0_PCFG3 and ANCON0_PCFG4 are always defined
      if an_pin_num == 0 then
         ANCON0_PCFG0 = false
         pin_AN0_direction = input
      end if
      if an_pin_num == 1 then
         ANCON0_PCFG1 = false
         pin_AN1_direction = input
      end if
      if an_pin_num == 2 then
         ANCON0_PCFG2 = false
         pin_AN2_direction = input
      end if
      if an_pin_num == 3 then
         ANCON0_PCFG3 = false
         pin_AN3_direction = input
      end if
      if an_pin_num == 4 then
         ANCON0_PCFG4 = false
         pin_AN4_direction = input
      end if

      -- Sometimes, there are gaps in PCFG bits
      -- 18lf24j50 has PCFG0 to PCFG12 bits, but without PCFG5, PCFG6 and PCFG7
      -- (this is because these bits only exist in the 44-pins version, according to DS)
      -- This shouldn't be a problem because numbering between PCFG bits and
      -- analog pins is respected: there's no AN5, AN6 and AN7 as well)

      -- PCFG5, PCFG6 and PCFG7 are always found together
      if defined(ANCON0_PCFG5) == true & defined(ANCON0_PCFG6) == true & defined(ANCON0_PCFG7) == true then
         if an_pin_num == 5 then
            ANCON0_PCFG5 = false
            pin_AN5_direction = input
         end if
         if an_pin_num == 6 then
            ANCON0_PCFG6 = false
            pin_AN6_direction = input
         end if
         if an_pin_num == 7 then
            ANCON0_PCFG7 = false
            pin_AN7_direction = input
         end if
      end if

      -- PCFG8, PCFG9, PCFG10, PCFG11 and PCFG12 are always found together
      if defined(ANCON1_PCFG8) == true & defined(ANCON1_PCFG9) == true & defined(ANCON1_PCFG10) == true & defined(ANCON1_PCFG11) == true & defined(ANCON1_PCFG12) == true then
         if an_pin_num == 8 then
            ANCON1_PCFG8 = false
            pin_AN8_direction = input
         end if
         if an_pin_num == 9 then
            ANCON1_PCFG9 = false
            pin_AN9_direction = input
         end if
         if an_pin_num == 10 then
            ANCON1_PCFG10 = false
            pin_AN10_direction = input
         end if
         if an_pin_num == 11 then
            ANCON1_PCFG11 = false
            pin_AN11_direction = input
         end if
         if an_pin_num == 12 then
            ANCON1_PCFG12 = false
            pin_AN12_direction = input
         end if
      end if
   end procedure

   -- Configure a pin to act as an digital pin.
   -- Because setting a pin to act as digital makes only sens for
   -- pins which can also be configured as analog,
   -- an_pin_num references the 'x' in ANx notation.
   -- Say you want to deactivate pin AN7, which is pin #12, also named RA4 in digital mode:
   --     - set_digital_pin(7) will set this pin as digital
   --     - set_analog_pin(12) won't set this pin as digital, but the equivalent
   --       one named AN12, if any
   --     - set_analog_pin(4) will do the same for AN4
   -- 
   -- Note: the pin direction is not modified
   procedure set_digital_pin(byte in an_pin_num) is
      if an_pin_num == 0 then
         ANCON0_PCFG0 = true
         pin_AN0_direction = input
      end if
      if an_pin_num == 1 then
         ANCON0_PCFG1 = true
         pin_AN1_direction = input
      end if
      if an_pin_num == 2 then
         ANCON0_PCFG2 = true
         pin_AN2_direction = input
      end if
      if an_pin_num == 3 then
         ANCON0_PCFG3 = true
         pin_AN3_direction = input
      end if
      if an_pin_num == 4 then
         ANCON0_PCFG4 = true
         pin_AN4_direction = input
      end if

      -- PCFG5, PCFG6 and PCFG7 are always found together
      if defined(ANCON0_PCFG5) == true & defined(ANCON0_PCFG6) == true & defined(ANCON0_PCFG7) == true then
         if an_pin_num == 5 then
            ANCON0_PCFG5 = true
            pin_AN5_direction = input
         end if
         if an_pin_num == 6 then
            ANCON0_PCFG6 = true
            pin_AN6_direction = input
         end if
         if an_pin_num == 7 then
            ANCON0_PCFG7 = true
            pin_AN7_direction = input
         end if
      end if

      -- PCFG8, PCFG9, PCFG10, PCFG11 and PCFG12 are always found together
      if defined(ANCON1_PCFG8) == true & defined(ANCON1_PCFG9) == true & defined(ANCON1_PCFG10) == true & defined(ANCON1_PCFG11) == true & defined(ANCON1_PCFG12) == true then
         if an_pin_num == 8 then
            ANCON1_PCFG8 = true
            pin_AN8_direction = input
         end if
         if an_pin_num == 9 then
            ANCON1_PCFG9 = true
            pin_AN9_direction = input
         end if
         if an_pin_num == 10 then
            ANCON1_PCFG10 = true
            pin_AN10_direction = input
         end if
         if an_pin_num == 11 then
            ANCON1_PCFG11 = true
            pin_AN11_direction = input
         end if
         if an_pin_num == 12 then
            ANCON1_PCFG12 = true
            pin_AN12_direction = input
         end if
      end if
   end procedure

#end def

#def ans
   -- Selecting the number of ADC channels is done using ANS bits
   -- There are many different cases where ANS bits can be found
   --   - bit*2 ADCON0_ANS
   --   - bit ANSEL0_ANSx (x in [0,7])
   --   - bit ANSEL1_ANSx (x in [8,11])
   --   - bit*6 ANSELA_ANSA
   --   - bit*6 ANSELB_ANSB
   --   - byte ANSELD_ANSD
   --   - bit*3 ANSELE_ANSE
   --   - bit*4 ANSELH_ANSELH
   --   - bit*4 ANSEL_ANS
   --   - bit ANSEL_ANSx (x in [0,7] or x in [0,4], or x in [0,1]U[4,7], or x in [0,6])
   --   - bit ANSEL_ANSELx (0 <= x <= 7, or 3 <= x <= 7)
   --   - bit ANSELH_ANSx (8 <= x <= 13, or 8 <= x <= 12)
   --
   -- There's a need for normalization...
   -- ANS bits are now normalized in device files :)
   -- I (Seb) keep these grep & sed rules as tools to check future changes

   -- Provide helper func to configure pins either in digital or analog mode
   -- (/!\, true/false logic is inverted compared to PCFGx bits)

   -- Some exceptions have been reported related to 16f72X family. These devises
   -- have gaps within their analog pins, but ANSx bits are continued. For instance,
   -- for 16f722, JANSEL_ANS5 should refer to analog pin AN5, but it does not exist !
   -- We need to put some more exceptions here, hoping there won't be much more. If so, 
   -- these would have to be dealt an in external file people could easily enrich.
   -- Anyway... here we go !
   -- Guilty PICs: 16F722, 16F723, 16F724, 16F726, 16F727 + LF versions
   -- Here's how ANSx bits are mapped to analog pins:
   ## stores JANSEL_ANSx <=> AN pin number
   ## 16F72X_map = {0:0, 1:1, 2:2, 3:3, 4:5, 6:12, 7:10, 8:8, 9:9, 10:11, 11:13, 20:5, 21:6, 22:7}
   ## Maybe this should be in an external python lib file...

   if target_chip == PIC_16F722 | target_chip == PIC_16F723 | target_chip == PIC_16F724 | target_chip == PIC_16F726 | target_chip == PIC_16F727 |
      target_chip == PIC_16LF722 | target_chip == PIC_16LF723 | target_chip == PIC_16LF724 | target_chip == PIC_16LF726 | target_chip == PIC_16LF727 then

	  ## always exists in all 16F72X family
	  alias ADC_JANSEL_ANS0  is JANSEL_ANS0
	  alias ADC_JANSEL_ANS1  is JANSEL_ANS1
	  alias ADC_JANSEL_ANS2  is JANSEL_ANS2
	  alias ADC_JANSEL_ANS3  is JANSEL_ANS3
	  alias ADC_JANSEL_ANS4  is JANSEL_ANS5
	  alias ADC_JANSEL_ANS12 is JANSEL_ANS6
	  alias ADC_JANSEL_ANS10 is JANSEL_ANS7
	  alias ADC_JANSEL_ANS8  is JANSEL_ANS8
	  alias ADC_JANSEL_ANS9  is JANSEL_ANS9
	  alias ADC_JANSEL_ANS11 is JANSEL_ANS10
	  alias ADC_JANSEL_ANS13 is JANSEL_ANS11




	  ## only for these
	  if target_chip == PIC_16F724 | target_chip == PIC_16F727 | target_chip == PIC_16LF724 | target_chip == PIC_16LF727 then
		 alias ADC_JANSEL_ANS5 is JANSEL_ANS20
	  	 alias ADC_JANSEL_ANS6 is JANSEL_ANS21
	  	 alias ADC_JANSEL_ANS7 is JANSEL_ANS22
	  end if

   else
	  -- no exception here: ANSx corresponds to analog pin nÂ°x
      #for i in range(23)
		 if defined(JANSEL_ANS$i) == true then
			alias ADC_JANSEL_ANS$i is JANSEL_ANS$i
		 end if
	  #end for
   end if

   -- Configure a pin to act as an analog pin.
   -- an_pin_num references the 'x' in ANx notation.
   -- Say you want to activate pin AN7, which is pin #12, also named RA4 in digital mode:
   --     - set_analog_pin(7) will set this pin as analog
   --     - set_analog_pin(12) won't set this pin as analog, but the equivalent
   --       one named AN12, if any
   --     - set_analog_pin(4) will do the same for AN4
   procedure set_analog_pin(byte in an_pin_num) is
      #for i in range(23)
      if defined(ADC_JANSEL_ANS$i) == true then
         if an_pin_num == $i then
            ADC_JANSEL_ANS$i = true
            pin_AN${i}_direction = input
         end if
      end if
      #end for
   end procedure

   -- Configure a pin to act as an digital pin.
   -- Because setting a pin to act as digital makes only sens for
   -- pins which can also be configured as analog,
   -- an_pin_num references the 'x' in ANx notation.
   -- Say you want to deactivate pin AN7, which is pin #12, also named RA4 in digital mode:
   --     - set_digital_pin(7) will set this pin as digital
   --     - set_analog_pin(12) won't set this pin as digital, but the equivalent
   --       one named AN12, if any
   --     - set_analog_pin(4) will do the same for AN4
   -- 
   -- Note: the pin direction is not modified
   procedure set_digital_pin(byte in an_pin_num) is
      #for i in range(23)
      if defined(ADC_JANSEL_ANS$i) == true then
         if an_pin_num == $i then
            ADC_JANSEL_ANS$i = false
         end if
      end if
      #end for
   end procedure

   -- Because there are many different combinations when specifying the number of
   -- wanted adc channles, because I think it's more user-friendly to use 
   -- set_analog_pin() instead of specifying ADC_NCHANNEL and then always wondering
   -- which ADC pin to use, and finally, because I'm lazy, there won't be automatic
   -- ADC_NCHANNEL settings in this case
   if defined(ADC_NCHANNEL) == true then
      _error "You can't specify the number of ADC channel with ADC_NCHANNEL, you have to use set_analog_pin(...)"
   end if

#end def


#def vcfg()


-- Configure Voltage reference using VCFG bits
procedure adc_vcfg() is
   pragma inline
   -- Configure Voltage Reference, Vref bits
   -- This is only valid for PICs where Vref isn't part of PCFG bits combination

   var byte vcfg_shadow = ADC_NVREF
   if ADC_NVREF == 2 then
      vcfg_shadow = 3   -- 0b_10 | 0b_01 => 0b_11 => one bit per VCFG bit*2
   end if
   
   if defined(ADCON0_VCFG) == true then
      ADCON0_VCFG = vcfg_shadow
   elsif defined(ADCON1_VCFG) == true then
      ADCON1_VCFG = vcfg_shadow

   -- VCFG0 bit can be found in ADCON0 or ADCON1 register
   elsif defined(ADCON1_VCFG0) == true then
      if ADC_NVREF == 1 then
         ADCON1_VCFG0 = true
      elsif ADC_NVREF == 2 then
         ADCON1_VCFG0 = true
         ADCON1_VCFG1 = true
      end if
   elsif defined(ADCON0_VCFG0) == true then
      if ADC_NVREF == 1 then
         ADCON0_PVCFG0 = true
      elsif ADC_NVREF == 2 then
         ADCON0_VCFG0 = true
         ADCON0_VCFG1 = true
      end if
   -- Special case for PVCFG
   elsif defined(ADCON1_PVCFG0) == true then
      if ADC_NVREF > 0 then
         -- PVCFG = 0b_01
         ADCON1_PVCFG0 = false
         ADCON1_PVCFG1 = true
      elsif ADC_NVREF == 2 then
         -- NVCFG = 0b_01
         ADCON1_NVCFG0 = false
         ADCON1_NVCFG1 = true
      end if
   else
      if defined(ADC_NVREF) == true & ADC_NVREF != 0 then
         _error "You've specified ADC_NVREF, but I can't find VCFG bits. There should be VCFG bits, except if I've made a mistake..."
      end if
   end if
end procedure

#end def


#def adref

-- Configure Voltage reference using ADREF bits
-- Found in PICs: 16f722, 16f723, 16f724, 16f726, 16f727, 16lf722, 
--                16lf723, 16lf724, 16lf726, 16lf727,
-- Same family, DS 41341B
procedure adc_adref() is

   if defined(ADCON1_ADREF) == true then
      if ADC_NVREF == 1 then
         ADCON1_ADREF = 0b_10
      elsif ADC_NVREF != 0 then
         _error "ADC_NVREF must be 0 or 1"
      end if
   end if

end procedure

#end def


#def select_vref

   if defined(ADCON0_VCFG) == true | defined(ADCON1_VCFG) then
      adc_vcfg()
   elsif defined(ADCON1_ADREF) == true then
      adc_adref()
   end if

#end def


#def main
$header
$deps

$vcfg
$adref

#set pcfg_combination_condition = " | ".join(map(lambda x: "target_chip == PIC_%s" % x.upper(),$pcfg_combination_pics))

-- -----------------------------------------
-- FIRST CASE: 
--  - PCFG bits exist, 
--  - analog are dependent from each other
--  - Vref config is done via PCFG bits
--    combination
-- -----------------------------------------

## Check PICs which use PCFG bits as combinations
if $pcfg_combination_condition then
$pcfg_combination


-- --------------------------------------------
-- SECOND CASE: 
--  - PCFG bits exist 
--  - analog are independent from each other
--  - Vref config is done via VCFG bits
-- --------------------------------------------

## 18F PICs, which use PCFG bits
elsif target_cpu == PIC_16 & (defined(ANCON0_PCFG0) | defined(ANCON0_PCFG1) | defined(ANCON0_PCFG2) | defined(ANCON0_PCFG3) | defined(ANCON0_PCFG4) | defined(ANCON0_PCFG5) | defined(ANCON0_PCFG6) | defined(ANCON0_PCFG7) | defined(ANCON1_PCFG10) | defined(ANCON1_PCFG11) | defined(ANCON1_PCFG12) | defined(ANCON1_PCFG8) | defined(ANCON1_PCFG9)) then
$pcfg_18f
$select_vref


-- --------------------------------------------
-- THIRD CASE: 
--  - ANS bits exist, 
--  - analog are independent from each other
--  - Vref config is done via VCFG bits
-- --------------------------------------------

## So these are PICs which use ANS bits, wether non-18F or 18F
else
$ans
$select_vref


end if
#end def

$main

