-- ----------------------------------------------------------------------------
-- Title: Test program for queue01.jal
-- 
-- Author: Joep Suijs, Copyright (c) 2008..2014, all rights reserved.
-- 
-- Adapted-by: Albert Faber
-- 
-- Compiler: >=2.4q2
-- Revision: $Revision$
-- 
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: Test program
-- 
-- Sources:
-- 
-- Notes: as output, this sample produces characters on a serial link. First 
--        run serial tests to make sure serial comms works okay.
-- 
-- ----------------------------------------------------------------------------

;@jallib use chipdef
;@jallib use led     

-- set all IO as digital
enable_digital_io()

led_direction= output

const byte  queue01_size = 4           
include queue01         
queue01_clear()  
           
var byte isr_put_counter = 0
var volatile byte test_mode                                     
-- -----------------------------------------------------------------------
-- serial_receive_wedge - handle each received char at ISR level
-- -----------------------------------------------------------------------
-- receive wedge - a user defined procedure, which is called by 
-- serial_hw_int_cts from the receive ISR for each received char. 
--
-- CAUTION: the wedge is part of the ISR and should be designed
-- to behave accordingly. If you are not sure you need this, you
-- probably don't!
-- -----------------------------------------------------------------------
procedure serial_receive_wedge(byte in char) is          
   pragma inline
   
   var byte dummy
   var bit ret   
   
   
   if (char == "*") then                   
      -- when a space is received in the ISR
      LED = ! LED ; high
      
      if ((test_mode == 1) | (test_mode == 2)) then
         -- non-block-get            

         ret = queue01_nb_get(dummy)       
         return
      end if
      
      if ((test_mode == 3) | (test_mode == 4)) then
         -- non-block-put
         ret = queue01_nb_put(isr_put_counter)
         isr_put_counter = isr_put_counter + 1   
         return
      end if   
      
   end if                                     
   
end procedure                         

include delay

alias serial_ctsinv  is  pin_B4      -- incoming data flow control
var  bit serial_overflow_discard        -- With transmit buffer overflow
include serial_hw_int_cts
;include serial_hardware
serial_hw_init()


include print



const byte str1[] = " - Test queue\r\n"   -- define a string
print_string(serial_hw_data, str1)                 -- output string


 
var byte char, i
 
 forever loop
   delay_100ms( 2 )
;   LED = ! LED ; high
;   delay_100ms( 2 )
;   LED = low
   
   serial_hw_data = "."

   while (serial_hw_read(char)) loop               
      case char of 

         "0" : block
            test_mode = char - "0"
            
         end block
   
         "1" : block
            test_mode = char - "0"
            const byte str11[] = "\r\n1 - put 5 chars in queue (blocking), use * to remove them\r\n" 
            print_string(serial_hw_data, str11)      
            for 5 using i loop
               queue01 = i
               serial_hw_data = "0" | i
            end loop
         end block


;; note: due to compiler bug, we can't use non-blocking interface at both main and isr level   
;;         "2" : block
;;            test_mode = char - "0"
;;            const byte str11[] = "\r\n2 - try to put 5 chars in queue (non-blocking), use * to remove them\r\n" 
;;            print_string(serial_hw_data, str11)      
;;
;;            for 5 using i loop
;;               serial_hw_data = "0" | i
;;               if (queue01_nb_put(i) == true) then
;;                  serial_hw_data = "s" -- succes
;;               else 
;;                  serial_hw_data = "f" -- fail
;;               end if         
;;            end loop              
;;         end block
   
         "3" : block
            test_mode = char - "0"
            const byte str11[] = "\r\n1 - get 5 chars from queue (blocking), use * to add them\r\n" 
            print_string(serial_hw_data, str11)      
            for 5 loop
               i = queue01
               serial_hw_data = "0" | i
            end loop
         end block

;; note: due to compiler bug, we can't use non-blocking interface at both main and isr level      
;;         "4" : block
;;            test_mode = char - "0"
;;            const byte str11[] = "\r\n1 - get 5 chars from queue (non-blocking), use * to add them\r\n" 
;;            print_string(serial_hw_data, str11)      
;;
;;            for 5 loop
;;               if (queue01_nb_get(i) == true) then  -- get byte
;;                  serial_hw_data = "s" -- succes
;;               else 
;;                  serial_hw_data = "f" -- fail
;;               end if                        
;;               serial_hw_data = "0" | i             -- print byte
;;            end loop              
;;         end block

;; note: due to compiler bug, we can't use non-blocking interface at both main and isr level   
;;         "8" : block
;;            test_mode = char - "0"
;;            const byte str11[] = "put "
;;            print_string(serial_hw_data, str11)      
;;
;;            var bit ret = queue01_nb_put(99)  
;;            print_bit_logic(serial_hw_data, ret)
;;
;;            serial_hw_data = "+"
;;            print_byte_dec(serial_hw_data, queue01_in_pointer)
;;            serial_hw_data = " "
;;            print_byte_dec(serial_hw_data, queue01_out_pointer)
;;            print_crlf(serial_hw_data)
;;
;;         end block
;;
;; note: due to compiler bug, we can't use non-blocking interface at both main and isr level   
;;         "9" : block
;;            test_mode = char - "0"
;;            const byte str11[] = "get "
;;            print_string(serial_hw_data, str11)      
;;            var bit ret = queue01_nb_get(i)  
;;            print_bit_logic(serial_hw_data, ret)
;;            serial_hw_data = "+"
;;            print_byte_dec(serial_hw_data, queue01_in_pointer)
;;            serial_hw_data = " "
;;            print_byte_dec(serial_hw_data, queue01_out_pointer)
;;            print_crlf(serial_hw_data)
;;
;;         end block
      
      end case
   end loop     
end loop