-- Title: Minix FS sample showing how to read file's content
-- Author: SÃ©bastien Lelong, Copyright (c) 2011, all rights reserved.
-- Adapted-by:
-- Compiler: 2.4o
-- Revision: $Revision$
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this sample shows how to read file's content. This requires
-- to open a file, read some content, possibly seek (move) to a specific
-- location and, don't forget, close the file.
-- .
-- MinixFS uses some kind of file descriptor to access file, in order to know
-- current state, etc... Note there's only one file description available in
-- current MinixFS implementation.
-- .
-- This sample is based on a data set, available here:
-- http://code.google.com/p/jaluino/source/browse/trunk/tests/minix_data.tar.bz2
-- You can use this dataset to perform tests. It contains several files with
-- very specifc size, I used it to develop and test MinixFS, and this is a great
-- source of data to understand how MinixFS works.
--
-- Notes: this sample is derived from Jaluino Bee's sample, where SD-Card is
-- on MSSP2. That's why it's using Peripheral Pin Select to map MSSP2 pins
--
--

include 18f27j53
pragma target clock 48_000_000   -- oscillator frequency
-- magical statements
pragma target PLLDIV    P4
pragma target CPUDIV    P1
pragma target PLLEN  P1          -- PLL via fuse turned off
pragma target OSC    HS_PLL
pragma target WDT  disabled      -- no watchdog
pragma target IOL1WAY disabled   -- Mapping allowed multiple time at runtime
OSCTUNE_PLLEN = on               -- PLL via OSCTUNE enabled
-- declare secondary oscillator on T1OSI/T1OSO pins
pragma target RTCOSC T1OSC
pragma target SOSCSEL HP
_usec_delay(2000) -- PLL needs 2ms before stable
enable_digital_io()

-- -----------------------------------------------------------------
-- Configure Remappable Pins on MSSP2 to match SPI/SD-Card wiring,
-- configure MSSP2 and initialize SD-card library
-- -----------------------------------------------------------------
include pps
-- PPS module writes are protected, we need to first unlock it
pps_control_lock(false)
-- RP3 <-> /SS2
PPS_MAP_SS2IN = RP3
-- RP2 <-> SCK2
PPS_MAP_RP2 = PPS_SCK2
PPS_MAP_SCK2IN = RP2
-- RP5 <-> SDI2
PPS_MAP_SDI2 = RP5
-- RP6 <-> SDO2
PPS_MAP_RP6 = PPS_SDO2
-- PPS configuration is done, we can lock again
pps_control_lock(true)

-- Now specify SPI pins aliases
alias pin_ss2_direction is pin_b0_direction
alias pin_ss2 is pin_b0
alias pin_sdi2_direction is pin_b2_direction
alias pin_sdo2_direction is pin_b3_direction
alias pin_sck2_direction is pin_a5_direction

-- -----------------------------------------------------------------
-- configure SPI to use MSSP2 module
-- -----------------------------------------------------------------
include spi_master_hw2
pin_sdi2_direction = input    -- spi input
pin_sdo2_direction = output   -- spi output
pin_sck2_direction = output   -- spi clock
spi2_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
-- setup the sd card SPI "Slave Select" pin
alias sd_chip_select is pin_ss2
alias sd_chip_select_direction is pin_ss2_direction
sd_chip_select_direction = output
sd_chip_select = high
-- Aliases used for generic access for SD-card, pointing to MSSP2 related procedures
-- (you could change these aliases to use MSSP1, or even SPI software)
alias spi_master_set_mode is spi_master_hw2_set_mode
alias spi_master_set_speed is spi_master_hw2_set_speed

-- -----------------------------------------------------------------
-- setup the sd card library
-- -----------------------------------------------------------------
const bit SD_ALWAYS_SET_SPI_MODE = TRUE
const bit SD_DELAY_AFTER_WRITE = TRUE
-- define which data carrier to use to access sd-card
alias spi_master is spi_master_hw2
include sd_card
sd_init()

-- Misc includes
include print
include delay
include jascii
include strings

-- -----------------------------------------------------------------
-- Configure serial comms. to interact with Minix FS, send commands
-- and read results
-- -----------------------------------------------------------------
const serial_hw_baudrate = 115_200
include serial_hardware
serial_hw_init()

-- -----------------------------------------------------------------
-- Configure MinixFS aliases. We need to specify here how to access
-- underlying storage (here, SD-Card)
-- -----------------------------------------------------------------
alias minix_start_read is sd_start_read
alias minix_stop_read is sd_stop_read
alias minix_start_write is sd_start_write
alias minix_stop_write is sd_stop_write
alias minix_data_byte is sd_data_byte -- get|put byte
-- Underlying storage (SD-Card) uses 512 bytes buffer
-- Minix will need to access it
alias minix_read_sector is sd_read_sector
alias minix_write_sector is sd_write_sector
alias minix_sector_buffer is sd_sector_buffer
-- how do we know when we reach end of storage sector ?
alias MINIX_STORAGE_SECTOR_SIZE is SD_BYTE_PER_SECTOR

-- how to interact with Minix OS ? Through our serial comms.
alias minix_print_carrier is serial_hw_data

-- include main library
include minixfs

-- We're going to read data from file2K. This files has the following
-- structure:
--    "START1111....111NEXT2222....2222END"
--     ^----------------^^---------------^
--          1 block           1 block
--
-- Note the link between the two blocks: "NE" then "XT"

-- Here we go !

-- define which file we're going to open
-- minix_open() will expect a string of 30 chars
-- "file2K" has 6 chars, so either ignore the warning claiming
-- "fewer initializers than expected", or fill in extra space chars
-- Finally, because a filename can fit anywhere between 1 or 30 chars
-- we need to use NULL-terminated string in order MinixFS to know
-- where the filename fits
-- PS: I don't like warnings so I added extra padding chars
const byte myfile[MINIX_MAX_FILENANE_LEN] = "file2K\0                       "
minix_open(myfile,MINIX_MODE_READ)

-- let's read the "START"
for 4 loop
   serial_hw_data = minix_read()
end loop
-- can you see "START" on your serial link ?
print_crlf(serial_hw_data)

-- now let've move near the end of the first block
minix_seek(1022)
serial_hw_data = minix_read()
serial_hw_data = minix_read()
-- should give "NE"
serial_hw_data = minix_read() -- we moved to the 2nd block !
serial_hw_data = minix_read()
-- should give "XT"
print_crlf(serial_hw_data)

-- Now let's move to the end of file
minix_seek(2045)
serial_hw_data = minix_read()
serial_hw_data = minix_read()
serial_hw_data = minix_read()
-- should print "END"
print_crlf(serial_hw_data)

-- where are we within the file ?
-- well, what's the size ?
-- let's access some information from File Descriptor
-- and inode records
const byte sz[] = "Size: "
print_string(serial_hw_data,sz)
print_dword_dec(serial_hw_data,minix_filefd.inode.filesize)
print_crlf(serial_hw_data)
-- and how much did we read ?
const byte rd[] = "Read: "
print_string(serial_hw_data,rd)
print_dword_dec(serial_hw_data,minix_filefd.read)
print_crlf(serial_hw_data)
-- alright, this means there's nothing to read further ?
serial_hw_data = minix_read()
serial_hw_data = minix_read()
serial_hw_data = minix_read()
-- => print nothing !
-- ok, don't forget to close file. If you access another file
-- without closing previous, you may just get stuck ("crash")
minix_close()

print_crlf(serial_hw_data)
print_crlf(serial_hw_data)

-- Sounds like we have everything to implement "cat" command :)
-- note: minix v2have max filename lenght = 30
procedure my_cat(byte in filename[MINIX_MAX_FILENANE_LEN]) is
   minix_open(filename,MINIX_MODE_READ)
   while minix_filefd.read != minix_filefd.inode.filesize loop
      serial_hw_data = minix_read()
   end loop
   minix_close()
end procedure
-- (you can find this procedure in minixfs_cmd.jal)

my_cat(myfile)
print_crlf(serial_hw_data)

-- enough, let's do nothing...
forever loop
end loop

