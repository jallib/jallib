-- Title: Sample Webserver via ENC28j60 BETA
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2011, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4n
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: This is a sample webserver on ENC28j60. With this sample
--              you can remotly control a LED via an internet webpage.
--
-- Sources:
--
-- Notes:
-- This is being released as BETA.
--

-- include chip
include 18F4620                   -- target picmicro
-- this program assumes a 20 mhz resonator or crystal
-- is connected to pins osc1 and osc2.
pragma target osc INTOSC_NOCLKOUT              -- hs crystal or resonator
;pragma target osc hs              -- hs crystal or resonator
;pragma target clock 20_000_000    -- oscillator frequency
pragma target clock 32_000_000    -- oscillator frequency
--
pragma target wdt  CONTROL
pragma target lvp  disabled
pragma target MCLR external        -- reset externally
--;
;OSCCON_IRCF = 0b110   -- set int osc to 4mhz
OSCCON_IRCF = 0b111   -- set internal osc to 8mhz
OSCTUNE_PLLEN = true  -- multiply internal osc by 4
;--
_usec_delay(500_000)

include print

-- setup serial software
const serial_sw_baudrate = 115200
alias serial_sw_tx_pin is pin_B4
alias serial_sw_rx_pin is pin_B5
pin_B4_direction = output
pin_B5_direction = input
include serial_software
serial_sw_init()
alias serial_data is serial_sw_data

-- setup a button
alias button2 is pin_d0
alias button2_direction is pin_d0_direction
button2_direction = INPUT

-- setup a button
alias button is pin_d1
alias button_direction is pin_d1_direction
button_direction = INPUT

-- setup a button
alias button3 is pin_d3
alias button3_direction is pin_d3_direction
button3_direction = INPUT

-- setup a led
alias led is pin_d2
alias led_direction is pin_d2_direction
--
led_direction = OUTPUT
led = high

-- setup a led
alias led2 is pin_d4
alias led2_direction is pin_d4_direction
--
led2_direction = OUTPUT
led2 = high

-- setup a led
alias led3 is pin_b3
alias led3_direction is pin_b3_direction
--
led3_direction = OUTPUT
led3 = high

include spi_master_hw        -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_00,SPI_RATE_FOSC_4) -- init spi, choose mode and speed

-- setup debug lib
alias debug_data is serial_data
const bit DEBUG_MASTER_ENABLE = TRUE    -- enables debugging
include debug
--
-- turn on and off debug levels.
;debug_lvl_0 = ON
debug_lvl_1 = ON   -- network error messages
debug_lvl_2 = ON   -- network general text
debug_lvl_3 = ON   -- network packet data type text
debug_lvl_4 = OFF  -- network raw data
;debug_lvl_5 = ON
;debug_lvl_6 = ON
--
var byte debug_text1[] = "DEBUG STARTED"
debug_string(DEBUG_2,debug_text1)
debug_crlf(DEBUG_2)

-- setup ENC28j60
-- pin def
alias enc_reset is pin_a2
alias enc_reset_direction is pin_a2_direction
enc_reset_direction = output
enc_reset = 1
--
-- interrupt output pin
alias enc_int is pin_a4
alias enc_int_direction is pin_a4_direction
enc_int_direction = input
--
-- wake up on lan signal (some datasheets say this pin is not connected?)
;alias enc_wol is pin_ax
;alias enc_wol_direction is pin_ax_direction
;enc_wol_direction = input
--
-- chip select pin
alias enc_cs is pin_e0
alias enc_cs_direction is pin_e0_direction
enc_cs_direction = output
enc_cs = 1
--
-- set constants for enc28j60
const byte ENC_LOCAL_MAC[6] = {0x00,0x13,0xD4,0xC6,0x53,0x16} -- MAC address of PIC
const ENC_USE_INTERRUPT_PIN = FALSE -- TRUE -> not tested yet
const ENC_ARRAY_SIZE = 1500 -- max 1500. Please adjust this, I was able to use 600
const ENC_ALWAYS_SET_SPI_MODE = TRUE
--
-- if you wish to store the array on an external memory device, create a
-- pseudo array here and name it enc_array[]
--
include enc28j60
enc_init()
--
-- change clockout pin freq. good communication test if you have a scope
enc_set_clkout_freq(ENC_8_333)
enc_set_clkout_freq(ENC_3_125)
--
-- print chip revision. another communcation test for those who don't
-- have a scope. My chip prints: 6
;for 10 loop
;   print_byte_dec(serial_data, enc_read_revision() )
;   serial_data = " "
;end loop

-- Setup Networking
-- choose network protocols to use
--
-- choose network protocols to use. You must put TRUE
-- for each protocol you use.
-- If you set FALSE or don't a define constant, don't include the file.
const NETWORK_USE_IP = TRUE
--
const NETWORK_USE_ARP = TRUE -- suggested for ethernet, not slip
const NETWORK_USE_ARP_CALLBACKS = TRUE
--
const NETWORK_USE_ICMP = FALSE -- required for ping only
const NETWORK_USE_ICMP_CALLBACKS = FALSE
--
const NETWORK_USE_UDP = FALSE -- udp can transfer data
const NETWORK_USE_UDP_CALLBACKS = FALSE
--
const NETWORK_USE_TCP = TRUE -- under development. requires ARP
const NETWORK_USE_TCP_CALLBACKS = TRUE
--
const byte network_local_ip[4] = {192,168,0,60}  -- IP address of PIC
const byte network_gateway_ip[4] = {192,168,0,1} -- IP address of gateway/router
--
-- set network layer
const NETWORK_LINK_LAYER = NETWORK_ETHERNET
const NETWORK_LINK_DEVICE = NETWORK_ENC28J60
--
const NETWORK_USE_TIMER = 1 -- timer not implemented yet, but will be needed.
--
-- include networking main files
include networking
include ethernet_mac
include ip_header
include arp

-- setup TCP
const TCP_MAX_SOCKETS = 5 -- max number of TCP connections (9 bytes ram per connection)
const TCP_CHECKSUM_IN = FALSE -- TRUE not supported yet on incomming packets
const TCP_CHECKSUM_OUT = TRUE -- FALSE not supported yet. TCP MUST do checksum out??
--
include TCP
tcp_init()
--
-- LOCAL TCP SERVER SETTINGS
const byte TCP_LOCAL_SERVER_PORT = 222 -- port of local TCP server
;   --
;   -- LOCAL TCP CLIENT SETTINGS (NOTE: NOT FULLY TESTED, HAS ISSUES)
;   var byte tcp_conn_1                          -- create a variable to be used as a TCP client.
;   var word TCP_LOCAL_CLIENT_PORT = random_word -- port of local TCP client
;   const TCP_REMOTE_SERVER_PORT = 333           -- port of remote TCP server
;   network_set_remote_ip(192,168,0,10)          -- set IP of server to connect to.
;   tcp_conn_1 = tcp_socket_create(TCP_LOCAL_CLIENT_PORT,TCP_REMOTE_SERVER_PORT)  -- create a socket
;   --
;   -- connect to tcp client
;   network_set_remote_ip(192,168,0,10)
;   arp_get_mac(5,1_000)
;   tcp_connect(tcp_conn_1) -- connect to TCP server
;   ;TCP_socket_remove(tcp_conn_1) -- I guess we'll never remove this socket

-- web server data for TCP
-- must at least contain:
-- "HTTP/1.1 200 OK\r\n"
-- "Content-Length: X\r\n"               (where X = length of data in bytes)
-- "Content-Type: text/html\r\n\r\n"
-- webpage data

const byte HTTP_HEADER[] = {

---
-- add your own options here:
---
-- "Date: Tue, 15 Feb  2011 20:05:58 GMT"
;0x44,0x61,0x74,0x65,0x3a,0x20,0x54,0x75,0x65,0x2c,0x20,0x31,0x35,0x20,0x46,0x65,0x62,0x20,0x32,0x30,0x31,0x31,0x20,0x32,0x30,0x3a,0x30,0x35,0x3a,0x35,0x38,0x20,0x47,0x4d,0x54,0x0d,0x0a
;
-- "Server: IBM_HTTP_Server/6.0 Apache/2.0.47 (Win32)"
;,0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x49,0x42,0x4d,0x5f,0x48,0x54,0x54,0x50,0x5f,0x53,0x65,0x72,0x76,0x65,0x72,0x2f,0x36,0x2e,0x30,0x20,0x41,0x70,0x61,0x63,0x68,0x65,0x2f,0x32,0x2e,0x30,0x2e,0x34,0x37,0x20,0x28,0x57,0x69,0x6e,0x33,0x32,0x29,0x0d,0x0a
;
-- "Last-Modi fied: Tue, 08 Feb 2011 08:35:43 GMT"
;,0x4c,0x61,0x73,0x74,0x2d,0x4d,0x6f,0x64,0x69,0x66,0x69,0x65,0x64,0x3a,0x20,0x54,0x75,0x65,0x2c,0x20,0x30,0x38,0x20,0x46,0x65,0x62,0x20,0x32,0x30,0x31,0x31,0x20,0x30,0x38,0x3a,0x33,0x35,0x3a,0x34,0x33,0x20,0x47,0x4d,0x54,0x0d,0x0a
;
-- "ETag: "1c043-8-3bea1437"
;,0x45,0x54,0x61,0x67,0x3a,0x20,0x22,0x31,0x63,0x30,0x34,0x33,0x2d,0x38,0x2d,0x33,0x62,0x65,0x61,0x31,0x34,0x33,0x37,0x22,0x0d,0x0a
;
-- "Accept-Ranges: bytes"
;,0x41,0x63,0x63,0x65,0x70,0x74,0x2d,0x52,0x61,0x6e,0x67,0x65,0x73,0x3a,0x20,0x62,0x79,0x74,0x65,0x73,0x0d,0x0a
;
-- "Keep-Alive: timeout=10, max=100"
;,0x4b,0x65,0x65,0x70,0x2d,0x41,0x6c,0x69,0x76,0x65,0x3a,0x20,0x74,0x69,0x6d,0x65,0x6f,0x75,0x74,0x3d,0x31,0x30,0x2c,0x20,0x6d,0x61,0x78,0x3d,0x31,0x30,0x30,0x0d,0x0a
;
-- "Connection: Keep-Alive"
;,0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x4b,0x65,0x65,0x70,0x2d,0x41,0x6c,0x69,0x76,0x65,0x0d,0x0a,

-- "Content-Type: text/html\r\n"
0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x0d, 0x0a
, 0x0d, 0x0a
}

-- file names
const HTTP_FILE_NAME_LENGHT = 20 -- max length of a web page file name
const byte HTTP_FILE_1_NAME[] = "/"
const byte HTTP_FILE_2_NAME[] = "/INDEX.HTM"
const byte HTTP_FILE_3_NAME[] = "/Test.txt"
const byte HTTP_FILE_4_NAME[] = "/form.htm"

-- FILES
-- 404 file not found
const byte HTTP_FILE_0[] = "<!DOCTYPE HTML PUBLIC '-//IETF//DTD HTML 2.0//EN'><html><head><title>404 Not Found</title></head><body><h1>Not Found</h1><p>The requested URL was not found on this server.</p><hr><address>JALV2 WEB SERVER at test.justanotherlanguage.org Port 80</address></body></html>"
--
-- main page
;const byte HTTP_FILE_1[] = "" -- file 1 and file 2 are the same ("/" and "/INDEX.HTM")
const byte HTTP_FILE_2[] = "<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns='http://www.w3.org/1999/xhtml'><head><meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1' /><title>Matt's JALv2/JALLib PIC Webserver</title></head><body><p><strong>WELCOME TO MATT'S JALV2/JALLIB PIC WEBSERVER!</strong></p><p><a href='/form.htm'>Click here for LED demo</a> </p></body></html>"
--
-- text file
const byte HTTP_FILE_3[] = "This is a test text file from PIC"
--
-- LED status page
const byte HTTP_FILE_4[] = "<p><strong>WELCOME TO MATT'S JALV2/JALLIB PIC WEBSERVER!</strong></p><p>Turn led on or off (values 1 or 0 are accepted)</p><form name='input' action='form.htm' method='post'>  Set LED Status:   <input type='text' name='led' /><input type='submit' value='Submit' /></form></br>"

const HTTP_USE_GET_CALLBACK = TRUE
const HTTP_SERVER_PORT = 80
include http

--MAIN PROGRAM-----------------------------------------------------------------------------------------------------

-- CALLBACK PROCEDURES --

--------------------------------------------------------------------------------
-- called when a web page is requested
--------------------------------------------------------------------------------
procedure http_callback(byte in socket,byte in http_file_name[]) is
   -- set http data
   var word step
   
   -- print file name requested
   for count(http_file_name) using step loop
      serial_data = http_file_name[step]
   end loop

   -- if http POST command
   if string_compare_mid(http_command,0,HTTP_STRING_POST) then

      -- send post data to serial port
      ;var byte temp
      ;for http_data_size using temp loop
      ;   serial_data = http_data[temp]
      ;end loop

      -- store post data
      var byte post_data[50]
      for http_data_size using step loop
         post_data[step] = http_data[step]
      end loop
      
      -- get led's value
      const byte LED_NAME[] = "LED"
      led = http_data[count(LED_NAME) + 1] - "0"
         
      -- if webpage 4 "/form.htm"
      if http_is_filename(HTTP_FILE_4_NAME) then
      
         -- set web page data
         for count(HTTP_FILE_4) using step loop
            http_data[step] = HTTP_FILE_4[step]
         end loop

;         -- put post data at bottom of web page
;         for http_data_size using temp loop
;            http_data[step] = post_data[temp]
;            step = step + 1
;         end loop

         -- put led status text bottom of web page
         const byte LED_STATUS_ON[]  = "THE LED IS CURRENTLY ON "
         const byte LED_STATUS_OFF[] = "THE LED IS CURRENTLY OFF"
         var byte status_step
         for count(LED_STATUS_ON) using status_step loop
            if led == 0 then
               http_data[step] = LED_STATUS_OFF[status_step]
            elsif led == 1 then
               http_data[step] = LED_STATUS_ON[status_step]
            end if
            step = step + 1
         end loop

      -- if page not found
      else
         for count(HTTP_FILE_0) using step loop
            http_data[step] = HTTP_FILE_0[step]
         end loop
      end if

   -- if http GET command
   elsif string_compare_mid(http_command,0,HTTP_STRING_GET) then

      -- if webpage 4 "/form.htm"
      if http_is_filename(HTTP_FILE_4_NAME) then
         for count(HTTP_FILE_4) using step loop
            http_data[step] = HTTP_FILE_4[step]
         end loop

         -- put led status text bottom of web page
         const byte LED_STATUS_ON[]  = "THE LED IS CURRENTLY ON "
         const byte LED_STATUS_OFF[] = "THE LED IS CURRENTLY OFF"
         var byte status_step
         for count(LED_STATUS_ON) using status_step loop
            if led == 0 then
               http_data[step] = LED_STATUS_OFF[status_step]
            elsif led == 1 then
               http_data[step] = LED_STATUS_ON[status_step]
            end if
            step = step + 1
         end loop

      -- if webpage 3 "/Test.txt"
      elsif http_is_filename(HTTP_FILE_3_NAME) then
         for count(HTTP_FILE_3) using step loop
            http_data[step] = HTTP_FILE_3[step]
         end loop

      -- if webpage 2 "/" OR "/INDEX.HTM
      elsif http_is_filename(HTTP_FILE_2_NAME) | http_is_filename(HTTP_FILE_1_NAME) then
         for count(HTTP_FILE_2) using step loop
            http_data[step] = HTTP_FILE_2[step]
         end loop

      -- if page not found
      else
         for count(HTTP_FILE_0) using step loop
            http_data[step] = HTTP_FILE_0[step]
         end loop
      end if
   end if

   -- you must set webpage size at the end of this procedure
   webpage_size = step
end procedure

--------------------------------------------------------------------------------
-- called when we get a arp reply from an external source
--------------------------------------------------------------------------------
procedure arp_reply_callback() is
    -- print a message
    var byte get_arp[] = "ARP Reply Recieved!"
    print_string(serial_data,get_arp)
    print_crlf(serial_data)
end procedure
--------------------------------------------------------------------------------
-- called when we get a arp request
--------------------------------------------------------------------------------
procedure arp_request_callback() is
    -- print a message
    var byte get_ping[] = "arp request recieved, sending reply"
    print_string(serial_data,get_ping)
    print_crlf(serial_data)
end procedure

--------------------------------------------------------------------------------
-- Receive TCP data.
--------------------------------------------------------------------------------
procedure tcp_receive_callback(byte in socket,word in tcp_data_size) is
   -- do webserver stuff
   http_server(socket,tcp_data_size)
end procedure

-- MAIN PROGRAM LOOP --

-- print some start characters
for 10 loop
   serial_data = "!"
end loop
print_crlf(serial_data)

-- get the MAC of the gateway we will be talking to
network_set_remote_ip(192,168,0,1) -- ip address of your PC or router
;network_set_remote_ip(192,168,2,2)
-- print message
var byte sending_arp[] = "sending arp request, waiting for reply..."
print_string(serial_data,sending_arp)
print_crlf(serial_data)
--
if NETWORK_LINK_LAYER == NETWORK_ETHERNET then
   arp_get_mac(5,1_000)

   -- Get all the packets before we continue
   -- This is extra, it will just allow the next message to be
   -- printed last -> "You are connected! Your Router or PC mac address is:"
   for 1000 loop
      -- poll to see if there are network packets available
      network_poll()
   end loop

end if
--
if arp_reply_received == TRUE then
   print_crlf(serial_data)
   var byte get_arp[] = "You are connected! Your Router or PC mac address is:"
   print_string(serial_data,get_arp)
   print_crlf(serial_data)
   --
   print_byte_hex(serial_data,network_remote_mac[0])
   serial_data = "-"
   print_byte_hex(serial_data,network_remote_mac[1])
   serial_data = "-"
   print_byte_hex(serial_data,network_remote_mac[2])
   serial_data = "-"
   print_byte_hex(serial_data,network_remote_mac[3])
   serial_data = "-"
   print_byte_hex(serial_data,network_remote_mac[4])
   serial_data = "-"
   print_byte_hex(serial_data,network_remote_mac[5])
   print_crlf(serial_data)
   print_crlf(serial_data)
else
   print_crlf(serial_data)
   var byte arp_error[] = "ERROR: ARP did not get a reply. Is your network connected correctly?"
   print_string(serial_data,arp_error)
   print_crlf(serial_data)
end if

;-- uncomment if you are using WIN XP slip connection
;if NETWORK_LINK_LAYER == NETWORK_SLIP Then
;   -- wait for "CLIENT" from windows slip connection (yes, i got lazy)
;   while !serial_hw_data_available loop
;   end loop
;
;   -- reply with "CLIENTSERVER" to initiate connection
;   const byte str1[] = "CLIENTSERVER"   -- define a string
;   print_string(serial_hw_data, str1)   -- send via serial port
;end if

-- main loop
var word packet_size
forever loop

   -- poll to see if there are network packets available
   network_poll()
   
end loop

