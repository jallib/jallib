-- ------------------------------------------------------
-- Title: Test program for ds18b20.jal
-- 
-- Author: Vasile Guta Ciucur, Copyright (c) 2010..2014, all rights reserved.
-- 
-- Adapted-by: mkerna@gmail.com, Joep Suijs
-- 
-- Compiler: >=2.4q2
-- Revision: $Revision$
-- 
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: Test program
--    Read sensor temperature DS18B20 from a specific device using the
--    drive's ID
-- 
-- Sources:
-- 
-- Notes: requires LCD to display result
-- 
-- ------------------------------------------------------
--
-- This file has been generated by jallib.py from:
--    * board: board_18f4550_af.jal
--    * test : test_ds18b20_single.jal
--

;@jallib section chipdef
-- chip setup
include 18f4550

-- even though the external crystal is 20 MHz, the configuration is such that
-- the CPU clock is derived from the 96 Mhz PLL clock (div2), therefore set
-- target frequency to 48 MHz
pragma target clock       48_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P1          -- [primary oscillator src: /1][96 mhz pll src: /2]
pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           CONTROL     -- no watchdog
pragma target CCP2MUX       ENABLED     -- CCP2 pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         ENABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected


;@jallib section lcd_hd44780_4

procedure PORTLCD'put(byte in x) is

    var volatile bit x_0 at x:0
    var volatile bit x_1 at x:1
    var volatile bit x_2 at x:2
    var volatile bit x_3 at x:3

    pin_b1 = x_0
    pin_b2 = x_1
    pin_b3 = x_2
    pin_b4 = x_3
end procedure

function PORTLCD'get() return byte is
    var byte ret
    var volatile bit ret_0 at ret:0 = pin_b1
    var volatile bit ret_1 at ret:1 = pin_b2
    var volatile bit ret_2 at ret:2 = pin_b3
    var volatile bit ret_3 at ret:3 = pin_b4
    return ret
end function

procedure PORTLCD_direction'put(byte in x) is

    var volatile bit x_0 at x:0
    var volatile bit x_1 at x:1
    var volatile bit x_2 at x:2
    var volatile bit x_3 at x:3

    pin_b1_direction = x_0
    pin_b2_direction = x_1
    pin_b3_direction = x_2
    pin_b4_direction = x_3
end procedure

function PORTLCD_direction'get() return byte is
    var byte ret
    var volatile bit ret_0 at ret:0 = pin_b1_direction
    var volatile bit ret_1 at ret:1 = pin_b2_direction
    var volatile bit ret_2 at ret:2 = pin_b3_direction
    var volatile bit ret_3 at ret:3 = pin_b4_direction
    return ret
end function

-- LCD IO definition
alias lcd_rs           is pin_d2              -- LCD command/data select.
alias lcd_rs_direction is pin_d2_direction
alias lcd_en           is pin_b0              -- LCD data trigger
alias lcd_en_direction is pin_b0_direction

alias lcd_dataport is portlcd             -- LCD data  port
alias lcd_dataport_direction is portlcd_direction

const byte LCD_ROWS     = 2                     -- 2 lines
const byte LCD_CHARS    = 16                    -- 16 chars per line

include delay
include print  
include format
enable_digital_io()  -- set all IO as digital

-- setup lcd
lcd_rs_direction        = output
lcd_en_direction        = output
lcd_dataport_direction  = output

include lcd_hd44780_4                -- LCD library with 4 data lines
lcd_init()                           -- initialize LCD
alias device is lcd
                               
-- ----------------------------                               
-- start of setup ds18b20 stuff              
-- ----------------------------                               
              
-- setup pin definitions for dallas one-wire bus
alias d1w_bus            is pin_b1
alias d1w_bus_direction  is pin_b1_direction     
include one_wire           -- include one-wire library
d1w_init()                 -- init one-wire bus

-- select one of the output formats below
const ds18b20_value_raw          = 0
const ds18b20_value_celcius      = 1
const ds18b20_value_farenheit    = 0

const ds18b20_ignore_crc         = 0 -- 1 tell lib to ignore crc (code becomes smaller and faster, but reliability of data is less)
const ds18b20_max_retries        = 2 -- 1 means the library re-reads once when crc fails, 4 means up to 4 retries (so max 5 reads)

include ds18b20            -- include library for ds18b20 temperature sensor with one-wire interface

-- ---------------------------                               
-- end of setup ds18b20 stuff 
-- ---------------------------                               

-- strings and vars for the main loop
const byte str1[]       = "Temp="
const byte str_err1[]   = "ds18b20 read failed."
var byte i
var sword temperature                
var bit r                            

forever loop           
 
                 
   ds18b20_convert()  -- tell all ds18b20 devices to start conversion                 

   -- note: the statement above starts the conversion and it can take
   -- up to 750ms to complete. 
   -- If the sensor is in parasite mode, it is mandatory to leave the bus 
   -- during conversion. You could include a delay like:
   delay_1ms(750)
   -- If you have other stuff to do, feel free to do so and create proper
   -- timing in an other way. 
   --
   -- If the sensor is conventional powered, you don't have to keep the
   -- bus idle and could read the sensor before conversion is complete.
   -- The sensor will return the previous value.
   
   r = ds18b20_s_temp(temperature)                 -- read conversion result   
   lcd_cursor_position(0,0)                        -- first line
   if (r) then
      -- success, so print temperature
      print_string(device, str1)                   -- print string
      format_sword_dec(device, temperature, 4, 1)  -- print temperature in xx.x format
      device = "C"
      device = " "
   else
      -- print fail message
      print_string(device, str_err1)    
   end if

   -- read the device's ID and print it    
   lcd_cursor_position(1,0)          -- second line

   r = ds18b20_s_read_rom()
   if (r) then
      -- read_rom successful, so print ID which is now stored in scratchpad 
      for 8 using i loop
         print_byte_hex(device, scratchpad[i])
      end loop                
   else                      
      -- print fail message
      print_string(device, str_err1)
   end if
 
end loop