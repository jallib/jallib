-- Title: glcd_common - generic routines for graphic lcd
-- Author: Stef Mientki, Serkan Ayyýldýz Copyright (c) 2006..2009, all rights reserved.
-- Adapted-by: Joep Suijs
-- Compiler: >=2.2
-- Revision: $Revision$
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources: 
-- 
-- Description: Generic routines for graphic lcd.
-- glcd_box
-- glcd_line
-- --
-- And mapping to char based lcd:
-- lcd_put
-- lcd_...
--
-- Notes: 
--

-- ----------------------------------------------------------
-- ----------------------------------------------------------
procedure lcd_line(byte in x0, byte in y0, byte in x1, byte in y1, bit in onoff) is
 var byte xi,yi , xfark,yfark, fark , xx

   xi = x0
   yi = y0
   if x1 >= x0  then  xfark = x1 - x0 else  xfark = x0 - x1 end if
   if y1 >= y0  then  yfark = y1 - y0 else  yfark = y0 - y1 end if

   if xfark >= yfark then fark = xfark else fark = yfark end if
   xx = 0
   for fark loop
      lcd_write_pixel ( xi, yi ,onoff)
      if xx < xfark then
          if x1 >= x0 then xi = xi + 1 else xi = xi - 1 end if
      end if
      if xx < yfark then
          if y1 >= y0 then yi = yi + 1 else yi = yi - 1 end if
      end if
      xx = xx + 1
   end loop
end procedure

-- ----------------------------------------------------------
-- ----------------------------------------------------------
procedure lcd_rect(byte in x0, byte in y0, byte in x1, byte in y1) is
   pragma inline 
   
   lcd_line ( x0,y0, x1,y0 ,1)
   lcd_line ( x1,y0, x1,y1 ,1)
   lcd_line ( x1,y1, x0,y1 ,1)
   lcd_line ( x0,y1, x0,y0 ,1)
end procedure

procedure lcd_filled_rect(byte in x0, byte in y0, byte in x1, byte in y1, bit in state) is
	var byte xDiff = x1 - x0
	var byte yDiff = y1 - y0
	var byte currX = 0
	var byte currY = 0
	var bit write
	
	var word area = xDiff * yDiff

	for area loop
		if (currY == yDiff) & (currX == xDiff) then
			write = 1
		else
			write = 0
		end if
		lcd_write_pixel_buff(x0 + currX, y0 + currY, state, write)

		currY = currY + 1
		if currY == yDiff then
			currY = 0
			currX = currX + 1
		end if
		if (currY == yDiff) & (currX == xDiff) then
			write = 1
		else
			write = 0
		end if
	end loop
end procedure

var byte glcd_char_x_pos = 0;
var byte glcd_char_y_pos = 0;


-- ----------------------------------------------------------
-- Pseudo variable 'lcd' as alternative for lcd_writechar(<byte>)
-- ----------------------------------------------------------
procedure lcd'put(byte in char) is
    lcd_write_char(glcd_char_x_pos, glcd_char_y_pos, char,0)
    glcd_char_x_pos = glcd_char_x_pos + 5
end procedure

;-- ----------------------------------------------------------
;-- Send byte to the LCD and automatically set the cursor one 
;-- position right.
;-- There is no check on line overflow.
;-- ----------------------------------------------------------
;procedure  lcd_writechar(byte in c) is    
;   _warn "lcd_writechar() is deprecated - please use lcd_write_char()" 
;   lcd = c
;end procedure

-- ------------------------------------------------------------
-- Clear screen
-- (and set the cursor to the upper left corner: row 0, column 0)
-- ------------------------------------------------------------
procedure  lcd_clearscreen() is
   lcd_fill(0)           -- Clear the display                 
   glcd_char_x_pos = 0;
   glcd_char_y_pos = 0;   
end procedure                                 

-- ------------------------------------------------------------
-- Set cursor position
-- Specify row and column in base-0 notation (first line is 0).
-- ------------------------------------------------------------
procedure  lcd_setcursor(byte in row, byte in col)  is
   glcd_char_y_pos = row * 7 -- up to 9 rows
   glcd_char_x_pos = col * 5 -- up to 25 cols
end procedure

-- ----------------------------------------------------------------------------
-- cursor returns home(line 1, position 1)
-- ----------------------------------------------------------------------------
procedure lcd_home()  is  
   glcd_char_y_pos = 0
   glcd_char_x_pos = 0
end procedure
-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------
-- ----------------------------------------------------------
procedure lcd_num(byte in x, byte in y, word in num) is
	var byte hundrets = num / 100
	var byte tens = (num - (hundrets * 100)) / 10
	var byte ones = num - (hundrets * 100) - (tens * 10)

	lcd_write_char(x, y, hundrets + 48,0)
	lcd_write_char(x + 6, y, tens + 48,0)
	lcd_write_char(x + 12, y, ones + 48,0)
end procedure


-- ----------------------------------------------------------
-- ----------------------------------------------------------
procedure lcd_print(byte in x, byte in y, byte in str[]) is
	var byte i
	var byte j
	for count(str) using i loop
		j = x
		j = j + (i * 6)
		lcd_write_char(j, y, str[i],0)
	end loop
end procedure


-- ----------------------------------------------------------
-- ----------------------------------------------------------
--procedure lcd_circle(byte in x, byte in y, byte in r) is
--	var byte xb, yb, xc, yc
--	xb=x
--	yb=y
--	xc = xb
--	yc = yb
--	var byte i, j, z, k, s
--	
--	for (r+r) using i loop
--		s = i -r
--		j = r*r
--		z = (s*s)
--		k = j+z
--		xc = sqrt32(k)
--		xc = xc + xb
--		lcd_write_pixel(xc, yc, 1)
--		xc = xc - (xb + xb)
--		lcd_write_pixel(xc, yc, 1)
--		yc = yb + i
--	end loop
--end procedure


procedure lcd_prg_ver(byte in x, byte in y0, byte in y1, word in value, word in max, bit in startTop) is
	pragma inline
	var byte maxY
	var word theValue
	
	maxY = y1 -y0 - 1 			-- Calculate our maximum vertical space we can use.
	theValue = (value*100)		-- Times 100.. Because we cannot handle numbers > 1
	theValue = theValue / max	-- Calculate percentage
	theValue = theValue * maxY	-- Times the maxX so that 100% = maxY
	theValue = theValue / 100	-- And divide that by 100, so that we get a number that is below maxY
	
	--Fill it!
	if startTop then
		lcd_filled_rect(x, y0, x + 5, theValue+1, 1)		-- Fill the part that needs filling
		lcd_filled_rect(x, theValue, x + 5, y1, 0)			-- And empty the part that doesn't
	else
		lcd_filled_rect(x, y0, x + 5, theValue+1, 0)		-- Fill the part that needs filling
		lcd_filled_rect(x, theValue, x + 5, y1, 1)			-- And empty the part that doesn't
	end if
	lcd_rect(x,y0,x+5,y1)							-- Draw the rectangle around it
end procedure 



procedure lcd_prg_hor(byte in x0, byte in y, byte in x1, word in value, word in max, bit in startLeft) is
	pragma inline
	var byte maxX
	var word theValue
	
	maxX = x1 - x0 - 1 			-- Calculate our maximum horizontal space we can use.
	theValue = (value*100)		-- Times 100.. Because we cannot handle numbers > 1
	theValue = theValue / max	-- Calculate percentage
	theValue = theValue * maxX	-- Times the maxX so that 100% = maxX
	theValue = theValue / 100	-- And divide that by 100, so that we get a number that is below maxX
	
	--Fill it!
	if startLeft then
		lcd_filled_rect(x0, y, theValue+1, y+5, 1)		-- Fill the part that needs filling
		lcd_filled_rect(theValue, y+1, x1-1, y+5, 0)	-- And empty the part that doesn't
	else
		lcd_filled_rect(x0, y, theValue+1, y+5, 0)		-- Fill the part that needs filling
		lcd_filled_rect(theValue, y+1, x1-1, y+5, 1)	-- And empty the part that doesn't
	end if
	lcd_rect(x0,y,x1,y+5)							-- Draw the rectangle around it
end procedure 
